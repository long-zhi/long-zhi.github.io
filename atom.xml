<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longzhiの个人博客</title>
  
  
  <link href="https://matthew84.cf/atom.xml" rel="self"/>
  
  <link href="https://matthew84.cf/"/>
  <updated>2020-11-04T03:27:09.718Z</updated>
  <id>https://matthew84.cf/</id>
  
  <author>
    <name>longzhi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Win10中Docker的安装与使用</title>
    <link href="https://matthew84.cf/archives/e94fadbe.html"/>
    <id>https://matthew84.cf/archives/e94fadbe.html</id>
    <published>2020-11-03T13:15:41.000Z</published>
    <updated>2020-11-04T03:27:09.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker的安装"><a href="#docker的安装" class="headerlink" title="docker的安装"></a>docker的安装</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Docker for Windows是一个Docker Community Edition（CE）应用程序。Docker for Windows安装包包含了在Windows系统上运行Docker所需的一切。如果你不想装虚拟机，想直接在你的Windows操作系统中安装与学习使用docker，那么你首先得查看你的系统是否满足Docker for Windows的安装与使用要求。</p><ol><li><p>Docker for Windows的当前版本运行在64位Windows 10 Pro，专业版、企业版和教育版（1607年纪念更新，版本14393或更高版本）上。Ps:家庭版是不行的，如果你是家庭版，那么一是升级到专业版，破解专业版推荐个地址：<a href="http://blog.csdn.net/SONGCHUNHONG/article/details/78006389">http://blog.csdn.net/SONGCHUNHONG/article/details/78006389</a> ，二是安装Docker Toolbox，自行网上百度<a href="http://blog.csdn.net/tina_ttl/article/details/51372604">http://blog.csdn.net/tina_ttl/article/details/51372604</a></p></li><li><p>如果你满足Docker for Windows的环境条件了，那么首先检查电脑的虚拟化开启了没有：进入任务管理器（ctrl+alt+delete），点击性能-&gt;cpu ,查看虚拟化是否已启用，如果虚拟化是已禁用，那么你需要重启电脑进入bios开启虚拟化（我们的发的笔记本cpu都是支持虚拟化的，重启时进入bios按esc -&gt; 再按f12 -&gt; 去开启虚拟化）</p></li><li><p>开启虚拟化重启后，进入任务管理器看虚拟化是否已启用。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin1.webp"></p></li><li><p>然后再是进入电脑的控制面板-&gt;程序-&gt;启用或关闭Windows功能-&gt;把Hyper-v勾上，启用后电脑会重启，后面就可以下载并安装Docker for Windows了。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin2.webp"></p></li></ol><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ol><li>进入网址<a href="https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows">https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows</a> 下载并安装。我安装的是稳定版。安装过程没什么要注意的。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin3.webp"></li><li>启动以后会出现在桌面的右下角区域，鼠标放上去以后显示Docker is running表示启动成功，第一次安装启用好像是会弹出个Docker Cloud登录界面，去注册然后登录，使用和git有点类似，可以pull图像等等<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin4.webp"></li></ol><h1 id="docker的入门"><a href="#docker的入门" class="headerlink" title="docker的入门"></a>docker的入门</h1><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><ol><li>检查Docker，Compose和Machine的版本<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin5.webp"></li><li>检查版本信息，并确保docker命令正常工作<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin6.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin7.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin8.webp"></li><li>运行docker run hello-world以测试从Docker Hub中拉取图像并启动容器<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin9.webp"></li><li>使用命令docker run -it ubuntu bash运行一个Ubuntu容器，我之前已经拉取过这个容器了，大概是几十兆吧，所以直接启用了，输入exit命令停止容器<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin10.webp"></li><li>运行命令docker run -d -p 80:80 –name webserver nginx 启动一个Dockerized webserver 会下载nginx容器图像并启动它，然后再打开浏览器键入<a href="http://localhost/">http://localhost</a><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin11.webp"></li><li>运行docker ps 命令，检查容器的详细信息<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin12.webp"></li><li>停止或移除容器和图像。如果你想停止网络服务器，输入：docker stop webserver然后重新启动docker start webserver。要使用单个命令停止并删除正在运行的容器，请键入： docker rm -f webserver。这将删除容器，但不是 nginx图像。您可以列出本地图像docker images。你可能想要保留一些图片，这样你就不必再从Docker Hub中取出它们了。要删除不再需要的图像，请使用docker rmi后跟图像ID或图像名称。例如docker rmi nginx<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin13.webp"></li></ol><h1 id="docker的常用配置"><a href="#docker的常用配置" class="headerlink" title="docker的常用配置"></a>docker的常用配置</h1><p>在PowerShell中设置 tab键自动补全（其实用的都是cmd.exe）</p><ol><li>启动一个的PowerShell（即以管理员身份运行）。搜索PowerShell，右键单击，然后选择以管理员身份运行。在PowerShell提示符下键入：<code>Set-ExecutionPolicy RemoteSigned</code></li><li>检查策略设置是否正确，运行：<code>get-executionpolicy</code>，应该返回RemoteSigned。</li><li>安装posh-dockerPowerShell模块以自动完成Docker命令，键入：<code>Install-Module posh-docker</code>或者，要仅为当前用户安装模块，键入：<code>Install-Module -Scope CurrentUser posh-docker</code></li><li>安装完成后，只能为当前PowerShell启用自动完成功能，输入：<code>Import-Module posh-docker</code></li><li>为了在所有PowerShell会话中保持Tab完成状态$PROFILE，请在PowerShell提示符处输入：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (-Not (Test-Path $PROFILE)) &#123;</span><br><span class="line">    New-Item $PROFILE –Type File –Force</span><br><span class="line">&#125;</span><br><span class="line">Add-Content $PROFILE &quot;&#96;nImport-Module posh-docker&quot;</span><br></pre></td></tr></table></figure><p>这将创建一个<code>$PROFILE</code>如果不存在，并将此行添加到文件中：<code>Import-Module posh-docker</code><br>要检查文件是否已正确创建，或只需手动编辑，请在PowerShell中键入以下内容：<code>Notepad $PROFILE</code><br>打开一个新的PowerShell会话。现在，当你键入的前几个字母后按Tab键，Docker命令（如开始，停止，运行及其选项）以及容器和映像名称现在都应该自动完成。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin14.webp"></p><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><p>找到右下角的docker图标，右击选择settings进去</p><ol><li>General：这里是设置docker开机自启，应用程序启动时检查更新，发布使用情况统计信息<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin15.webp"></li><li>Advanced：分配cpu数量与内存量<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin16.webp"></li><li>Daemon：Docker for windows10 可以配置阿里云镜像，到<a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a> 注册一个账户，登录进去后再列表选择加速器，把你的专属加速器地址复制粘贴到Daemon的Registry mirrors中<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin17.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin18.webp"></li></ol><h1 id="用Dockerfile定义一个镜像"><a href="#用Dockerfile定义一个镜像" class="headerlink" title="用Dockerfile定义一个镜像"></a>用Dockerfile定义一个镜像</h1><p>在过去，如果你要开始编写一个Python应用程序，你的第一步就是在你的机器上安装一个Python运行库。但是，这会造成您的机器上的环境必须满足一定条件以使您的应用程序可以运行。<br>使用Docker，你可以将一个可移植的Python运行库作为一个映像，不需要安装。然后，您的构建可以将基础Python镜像与应用程序代码一起包括在内，确保您的应用程序，依赖项和运行时都一起运行。<br>这些可移植的镜像是由一个叫做Dockerfile的东西来定义的</p><h2 id="新建目录文件"><a href="#新建目录文件" class="headerlink" title="新建目录文件"></a>新建目录文件</h2><p>创建一个空目录，我取名叫docker，然后分别在里面新建三个文件：Dockerfile，app.py，requirements.txt<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin19.webp"><br>三个文件中的内容分别设计为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1.Dockerfile：</span><br><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at &#x2F;app</span><br><span class="line">ADD . &#x2F;app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br><span class="line"></span><br><span class="line">2.app.py：</span><br><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis &#x3D; Redis(host&#x3D;&quot;redis&quot;, db&#x3D;0, socket_connect_timeout&#x3D;2, socket_timeout&#x3D;2)</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits &#x3D; redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits &#x3D; &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;&#x2F;i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html &#x3D; &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;&#x2F;h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;&#x2F;b&gt; &#123;hostname&#125;&lt;br&#x2F;&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;&#x2F;b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name&#x3D;os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname&#x3D;socket.gethostname(), visits&#x3D;visits)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;80)</span><br><span class="line"></span><br><span class="line">3. requirements.txt：</span><br><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>在docker目录下打开cmd.exe运行命令（确保能够找到Dockerfile文件，镜像取名叫friendlyhello）：<code>docker build -t friendlyhello</code>.<br>ps：千万不要落了上面那行后面的那个点，曾经入过坑的。。命令包括后面的那个点</p><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin20.webp"><br>然后再执行命令：<br>docker images</p><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin21.webp"><br>运行镜像程序：<br>docker run -p 4000:80 friendlyhello</p><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin22.webp"><br>可以看到Python正在为应用程序提供消息的<a href="http://0.0.0.0:80。">http://0.0.0.0:80。</a> 但是，这个消息来自容器内部，它不知道我们将该容器的端口80映射到4000，从而打开URL： <a href="http://localhost:4000/">http://localhost:4000</a><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin23.webp"></p><h2 id="停止容器运行"><a href="#停止容器运行" class="headerlink" title="停止容器运行"></a>停止容器运行</h2><p>首先在接着上面的操作步骤后按下ctrl+c在终端退出，这并不意味着镜像停止运行了<br>键入docker container ls 列出正在运行的容器<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin24.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin25.webp"><br>运行命令：<code>docker container stop &lt;Container NAME or ID&gt;</code> 停止容器。否则，在下一步中重新运行容器时，将会收到错误响应。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin26.webp"></p><h1 id="联系Docker-Hub的常用操作"><a href="#联系Docker-Hub的常用操作" class="headerlink" title="联系Docker Hub的常用操作"></a>联系Docker Hub的常用操作</h1><h2 id="登录到Docker-Hub"><a href="#登录到Docker-Hub" class="headerlink" title="登录到Docker Hub"></a>登录到Docker Hub</h2><p>前面已经说过了，docker和git的操作有类似之处，所以docker也有远程仓库，如果前面已经注册过并登录了docker cloud，那么访问网址：<a href="https://hub.docker.com/">https://hub.docker.com</a> 在里面创建存储库，否则先注册吧。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin27.webp"></p><h2 id="push镜像"><a href="#push镜像" class="headerlink" title="push镜像"></a>push镜像</h2><p>前面在本地创建了一个friendlyhello的镜像，现在要把它push到<br>自己的docker hub的存储库中去，首先：</p><ol><li>登录docker hub （我已经登录过了。。再登录一次吧）<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin28.webp"></li><li>标记镜像：<br>把镜像放入wangliguo存储库并标记为test<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin29.webp"></li><li>查看镜像：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin30.webp"></li><li>发布镜像（推送镜像）<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin31.webp"></li><li>Docker Hub上查看镜像：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin32.webp"></li><li>从远程存储库中提取并运行镜像：现在当远程存储库有了镜像后，就可以从远程存储库提取并运行了<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin33.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin34.webp"></li></ol><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>在分布式应用程序中，应用程序的不同部分被称为“服务”。例如，想象一个视频共享站点，它可能包括用于将应用程序数据存储在数据库中的服务，用于用户上传东西的视频转码服务，为前端服务等等。<br>服务实际上只是“生产中的容器”。服务只运行一个镜像，但它编码镜像运行的方式 - 应该使用哪个端口，容器应该运行多少个副本，以便服务具有所需的容量，以及等等。缩放服务会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多的计算资源。<br>使用Docker平台定义，运行和扩展服务非常简单 - 只需编写一个docker-compose.yml文件即可。</p><h2 id="创建一个docker-compose-yml文件"><a href="#创建一个docker-compose-yml文件" class="headerlink" title="创建一个docker-compose.yml文件"></a>创建一个docker-compose.yml文件</h2><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin35.webp"><br>键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username&#x2F;repo:tag with your name and image details</span><br><span class="line">    image: 15433&#x2F;wangliguo:test</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><p>拉取的是上个步骤中的存储库的tag。<br>运行该镜像的5个实例作为一个服务调用web，限制每个使用，最多10％的CPU（跨所有核心）和50MB的RAM。<br>如果一个失败，立即重新启动容器。<br>将主机上的端口80映射到web端口80。<br>指导web容器通过一个负载平衡的网络共享80端口webnet。（在内部，容器本身将web在临时端口上发布到 端口80）。<br>webnet使用默认设置（这是一个负载平衡覆盖网络）定义网络。</p><h2 id="运行新的负载均衡应用程序"><a href="#运行新的负载均衡应用程序" class="headerlink" title="运行新的负载均衡应用程序"></a>运行新的负载均衡应用程序</h2><p>先运行命令：docker swarm init<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin36.webp"><br>然后再运行命令：docker stack deploy -c docker-compose.yml getstartedlab<br>给它取名叫getstartedlab<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin37.webp"><br>服务堆栈在这台主机上运行了5个部署镜像的容器实例<br>运行命令查看：docker service ls<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin38.webp"><br>在服务中运行的单个容器称为任务，可以看到上面有个getstartedlab_web的服务<br>运行命令docker service ps getstartedlab_web 查看此服务下的任务：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin39.webp"><br>如果只列出系统中的所有容器，也会显示任务，但不会被服务过滤：<br>运行命令：docker container ls -q<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin40.webp"><br>然后打开浏览器，键入<a href="http://localhost/">http://localhost</a><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin41.webp"><br>点击刷新多次，可以发现Hostname的更改，以循环方式选择5个任务中的一个来响应。容器ID将与前一个命令（docker container ls -q）的输出相匹配。</p><h2 id="更改应用程序"><a href="#更改应用程序" class="headerlink" title="更改应用程序"></a>更改应用程序</h2><p>比如更改docker-compose.yml中的replicas值，保存更改并重新运行docker stack deploy命令来更新应用程序：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin42.webp"><br>运行命令：<br>docker stack deploy -c docker-compose.yml getstartedlab<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin43.webp"><br>Docker会做一个就地更新，然后重新运行docker container ls -q以查看重新配置的已部署实例<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin44.webp"><br>可以看到之前是6个，现在是7个，刚好多了一个任务<br>ps:电脑中还运行这之前步骤中从docker hub中拉取并运行着的那个任务，所以会看到6个和7个</p><h2 id="关闭应用程序和群"><a href="#关闭应用程序和群" class="headerlink" title="关闭应用程序和群"></a>关闭应用程序和群</h2><p>关闭应用程序docker stack rm getstartedlab<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin45.webp"><br>关闭群docker swarm leave –force<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin46.webp"><br>现在服务中的任务都关闭了以后再运行命令：<br>docker container ls -q<br> <img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin47.webp"><br>这就是上面说的那个之前步骤中从docker hub中拉取并运行着的那个任务</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="了解集群"><a href="#了解集群" class="headerlink" title="了解集群"></a>了解集群</h2><p>swarm是运行Docker并加入到一个集群中的一组机器。但是现在它们将由群集管理器在群集上执行。群体中的机器可以是物理的或虚拟的。加入群体后，他们被称为节点。<br>Swarm管理人员可以使用多种策略来运行容器，比如“最空的节点”（emptiest node） - 它使用容器填充最少使用的机器。或“全局”，这确保了每台机器只能得到指定容器的一个实例。您可以指示swarm manager在Compose文件中使用这些策略。<br>群体管理者是群体中唯一可以执行你的命令的机器，或者授权其他机器作为工作者加入群体。工人提供能力，并没有权力告诉任何其他机器可以做什么和不可以做什么。<br>到目前为止，之前都是在本地机器上以单主机模式使用Docker。但是Docker也可以切换到群集模式，这就是使用群集的原因。启用群模式使当前机器成为群管理器。则Docker将运行您正在管理的群集上执行的命令，而不仅仅是在当前的机器上。</p><h2 id="创建一个集群"><a href="#创建一个集群" class="headerlink" title="创建一个集群"></a>创建一个集群</h2><p>一个群由多个节点组成，可以是物理机或虚拟机。基本的概念很简单：运行docker swarm init启用群模式，使当前的机器成为群管理器，然后docker swarm join在其他机器上运行 ，让它们作为工人加入群体。下面将使用虚拟机快速创建一个双机群集，并将其变成群集。<br>步骤：</p><ol><li>以管理员运行cmd.exe 这里必须是管理员运行，不然后续操作权限不够<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin48.webp"></li><li>运行docker swarm init启用群模式，使当前的机器成为群管理器，然后docker swarm join在其他机器上运行 ，让它们作为工人加入群体。</li><li>启动Hyper-V管理器<br>点击开始windows管理工具Hyper-V管理器<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin49.webp"></li><li>单击右侧菜单中的虚拟交换机管理器<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin50.webp"></li><li>单击创建类型为外部网络的虚拟交换机，给它的名称myswitch，并检查框共享您的主机的活动网络适配器<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin51.webp"></li><li>使用节点管理工具创建几个虚拟机docker-machine：<br>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm1<br>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm2<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin52.webp"><br>之前我已经创建过了，所以我现在再新建两个：myvm3 和 myvm4<br>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm3<br>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm4<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin53.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin54.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin55.webp"></li><li>现在创建了两个虚拟机，分别命名为myvm3和myvm4。使用命令<code>docker-machine ls</code>列出机器并获取其IP地址。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin56.webp"></li></ol><h2 id="初始化群并添加节点"><a href="#初始化群并添加节点" class="headerlink" title="初始化群并添加节点"></a>初始化群并添加节点</h2><ol><li>先使用命令docker-machine ssh myvm3<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin57.webp"><br>然后让myvm3 成为一个管理员：docker swarm init<br>注意红框中的内容，这是后面的myvm4 加入集群要执行的命令<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin58.webp"><br>运行命令：docker node ls<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin59.webp"><br>可以看到myvm3 已经成为管理员了</li><li>以管理员身份再运行一个cmd.exe.然后运行命令：docker-machine ssh myvm4<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin60.webp"><br>然后再运行命令：（这就是上一页中图片里红框中的内容，下面的token是我这里的，正常运行到这里的时候是去myvm3的docker swarm init命令中把红框框位置里的命令复制粘贴过来执行）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-0csyw4yz6uxob90h0b8ejoimimrgisiuy9t2ugm8c1mxfvxf99-7q7w5jw1mrjk1jlri2bcgqmu8 10.211.106.194:2377</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin61.webp"><br>然后再切换到myvm3 的cmd.exe中执行命令：docker node ls<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin62.webp"><br>可以看到，我们已经创建了一个简单的集群。、</p><p>附离开群命令：docker swarm leave</p><h2 id="在集群上部署应用程序"><a href="#在集群上部署应用程序" class="headerlink" title="在集群上部署应用程序"></a>在集群上部署应用程序</h2><ol><li><p>docker-machine为swarm管理器配置一个shell<br>运行命令：docker-machine env myvm3<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin63.webp"><br>注意最后一行的内容<br>我这里是<code>@FOR /f &quot;tokens=*&quot; %i IN (&#39;docker-machine env myvm3&#39;) DO @%i</code><br>复制粘贴运行它<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin64.webp"><br>再运行docker-machine ls以验证它myvm3 是否为活动机器<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin65.webp"></p></li><li><p>在swarm管理器上部署应用程序<br>以部署我们之前docker-compose.yml服务为例<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin66.webp"><br>首先在这个以管理员身份打开的cmd中进入到docker-compose.yml文件的所在的目录中去，我的因为在D/docker中，如果不过来，那么执行命令：<br>docker stack deploy -c docker-compose.yml getstartedlab会出现：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin67.webp"><br>进入目录后执行上面那条命令：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin68.webp"><br>再执行命令docker stack ps getstartedlab 查看服务详情：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin69.webp"><br>如果发现state存在shutdown的情况（也有可能出现你的图片上的实例数量大于你在服务文件中定义的数量的情况，这都是我爬过的坑，现在我这里定义的是6，图片上也是6，），那应该是你在之前服务哪一章运行过命令：<br>docker stack deploy -c docker-compose.yml getstartedlab 而没有把getstartedlab移除掉<br>这时应该执行命令：docker stack rm getstartedlab 把getstartedlab移除掉<br>Ps：我是d，c盘都执行了这个命令，因为之前运行docker stack deploy -c docker-compose.yml getstartedlab命令是在d盘的时候<br>然后重新运行：docker stack deploy -c docker-compose.yml getstartedlab 和<br>docker stack ps getstartedlab 就好了</p></li><li><p>浏览器访问集群的网址：<br>如图红框框所示，浏览器上访问其中的任何一个，然后刷新，将看到6个可能的容器ID，它们都是随机循环的，展示了负载平衡<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin70.webp"></p></li><li><p>其他的一些命令：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如说如果修改了docker-compose.yml文件后，执行命令：</span><br><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">再次运行以部署这些更改即可</span><br><span class="line">比如说前面提到的移除应用程序：docker stack rm getstartedlab</span><br><span class="line">离开群：docker swarm leave –force</span><br><span class="line">重新启动已停止的虚拟机，执行：</span><br><span class="line">docker-machine start &lt;machine-name&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerwin71.webp"><br>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=3bmjgxkdylogc">https://cloud.tencent.com/developer/support-plan?invite_code=3bmjgxkdylogc</a></p>]]></content>
    
    
    <summary type="html">本篇介绍了Win10中Docker的安装与使用</summary>
    
    
    
    <category term="Win10" scheme="https://matthew84.cf/categories/Win10/"/>
    
    <category term="Docker" scheme="https://matthew84.cf/categories/Win10/Docker/"/>
    
    
    <category term="Docker" scheme="https://matthew84.cf/tags/Docker/"/>
    
    <category term="Win10" scheme="https://matthew84.cf/tags/Win10/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="https://matthew84.cf/archives/532c0323.html"/>
    <id>https://matthew84.cf/archives/532c0323.html</id>
    <published>2020-11-03T13:15:23.000Z</published>
    <updated>2020-11-04T01:33:15.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门Docker，你要下载什么？注册什么？"><a href="#入门Docker，你要下载什么？注册什么？" class="headerlink" title="入门Docker，你要下载什么？注册什么？"></a>入门Docker，你要下载什么？注册什么？</h1><ul><li><p>Docker.app你肯定是要下载的！<br>Docker for mac，这个你肯定要下载：<a href="https://www.docker.com/products/container-runtime">点我下载Docker for mac的社区免费版本</a></p></li><li><p>注册Docker官方账号，你需要它！<br>注册一个Docker的官方账号，有利而无害，相信我！<a href="https://hub.docker.com/signup">点我注册Docker Cloud官方账号</a></p></li></ul><p>Docker安装好，账号也注册后，点击桌面顶栏的Docker图标，点击sign in，登录你的Docker账号。</p><ul><li>注册DaoCloud账号，获取加速服务！<br>不可否认，有时直接从Docker官方往本地pull镜像会十分缓慢。。。这时我们可以通过国内的Docker服务提供商免费获取加速pull镜像服务，阿里网易好像都有这种服务，我选择的是DaoCloud：<a href="https://account.daocloud.io/signup">点我注册DaoCloud账号</a></li></ul><p>注册后登录DaoCloud，找到这个按钮<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerrumf1.webp"><br>接着，按照它的步骤，为自己添加Docker加速服务<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerrumf2.webp"></p><ul><li>到此准备工作结束，进入下一部分！</li></ul><h1 id="要想入门Docker，首先你需要理解Docker！"><a href="#要想入门Docker，首先你需要理解Docker！" class="headerlink" title="要想入门Docker，首先你需要理解Docker！"></a>要想入门Docker，首先你需要理解Docker！</h1><p>我也不扯淡了，直接上我对Docker的理解：</p><p>Docker，可以说是一个终端命令行的虚拟机，但更准确的说法，其实应该是一个虚拟环境。比如，你想要在PC上无缝使用Linux么？那么虚拟机并不是你唯一的出路，你还有Docker！我更愿意称Docker为一个容器，当然这只是Docker的一个狭义解释，Docker不止是一个容器。Docker包含3个重要概念：</p><ul><li>一个，是镜像（Image），镜像是静态的、可以被用户互相分享的文件。我们玩过双系统和虚拟机的人都知道，首先你需要一个.iso镜像，才能安装系统。Docker中的镜像也是这个东西，镜像是静态的，你不能对他操作，只能pull别人的镜像或者push自己的镜像。</li><li>还有一个，是容器（Container），前面说过，镜像是静态不可操作的，只能被分享和下载，那什么是能被操作的呢？就是容器里！容器可以理解为镜像的动态状态，也就是我们虚拟机中系统装好后的状态，其实这么说是不对的，容器最符合的描述应该是Linux的iso文件的<code>Live CD</code>模式，比如我们玩双系统时都进入过<code>Live CD</code>模式，不安装系统而直接进入系统，很神奇是吧，Docker的容器就是这个概念，只不过更加轻量更加迅速便捷。但是<code>Live CD</code>的害处就是你关机后作出的修改安装的软件全部gg，容器也是一样，一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。</li><li>最后，是仓库（Repository）。各位在前面看到我写的pull和push什么的，有没有晕？不知道各位对于git熟悉不熟悉，Docker中的仓库很像git的代码仓库，你可以pull自己之前push到自己仓库的镜像到本地，也可以pull别人push到公共仓库的镜像到自己本地。说白了就是百度云盘，你可以上传（push）自己做好环境的Docker上去，也可以下载（pull）自己云端的镜像到本地。同时，我们知道百度云最大的特点就是分享（你懂的嘿嘿嘿），类比Docker，如果你得到百度云分享链接（别人的镜像名字、标签和别人的用户名），你还可以下载（pull）别人分享的镜像到自己的本地，别人也可以下载（pull）你的镜像，因为Docker仓库都是公共的。当然，每个免费用户有一个名额把自己的一个镜像设为私有，也就是禁止被分享给别人，类比百度云上你自己保存的而没有被生成分享链接的小姐姐。</li></ul><p>接下来来张高大上的概念图，各位看个热闹2333<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerrumf3.webp"></p><h1 id="接下来就是实战了"><a href="#接下来就是实战了" class="headerlink" title="接下来就是实战了"></a>接下来就是实战了</h1><p>打开你的iTerm2！（打开普通terminal也行，这个不影响）</p><ul><li>查看Docker版本信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">终端输入：</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p>显示的我的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ~$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.06.2-ce</span><br><span class="line"> API version:  1.30</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   cec0b72</span><br><span class="line"> Built:        Tue Sep  5 20:12:06 2017</span><br><span class="line"> OS&#x2F;Arch:      darwin&#x2F;amd64</span><br><span class="line"> ...</span><br><span class="line"> &#x2F;&#x2F;omitted by sgy(Copyright © http:&#x2F;&#x2F;blog.csdn.net&#x2F;s_gy_zetrov. All Rights Reserved)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>不过我一般不需要那么多信息，所以一直用的是<code>docker -v</code>命令</p><ul><li>是时候pull你的第一个镜像下来</li></ul><p>Docker安装好后是不会自带镜像的，你需要从仓库自己pull一个镜像下来，自己制作自己的镜像也是一个道理，你可以通过在已有的镜像基础上生成自己的镜像或者看一下这篇博客: <a href="https://blog.csdn.net/shiqiangdexin/article/details/52472195">随便百度的如何创建自己Docker镜像得到的教程</a><br>Docker镜像官方好像只提供Linux，这个很容易想，windows和mac是要交钱的吧大概？</p><p>搜索ubuntu的Docker镜像<code>docker search ubuntu</code>，这个如果你想要什么centos，直接改就行，不区分写法,我的返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~$ docker search ubuntu</span><br><span class="line">NAME                               DESCRIPTION                                     STARS   OFFICIAL   AUTOMATED</span><br><span class="line">ubuntu                             Ubuntu is a Debian-based Linux operating s...   6636                [OK]</span><br><span class="line">dorowu&#x2F;ubuntu-desktop-lxde-vnc     Ubuntu with openssh-server and NoVNC            131                 [OK]</span><br><span class="line">rastasheep&#x2F;ubuntu-sshd             Dockerized SSH service, built on top of of...   105                 [OK]</span><br><span class="line">ansible&#x2F;ubuntu14.04-ansible        Ubuntu 14.04 LTS with ansible                   86                  [OK]</span><br><span class="line">ubuntu-upstart                     Upstart is an event-based replacement for ...   80                  [OK]</span><br><span class="line">neurodebian                        NeuroDebian provides neuroscience research...   40                  [OK]</span><br><span class="line">ubuntu-debootstrap                 debootstrap --variant&#x3D;minbase --components...   31                  [OK]</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;omitted by sgy(Copyright © http:&#x2F;&#x2F;blog.csdn.net&#x2F;s_gy_zetrov. All Rights Reserved)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>拉取官方最新版的ubuntu镜像：<code>docker pull ubuntu:latest</code>，其中的latest是一个标签（tag），表示是当前最新版本。你应该得到的信息，类似这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">～$ docker pull ubuntu:latest</span><br><span class="line">Trying to pull repository docker.io&#x2F;library&#x2F;ubuntu ... </span><br><span class="line">latest: Pulling from docker.io&#x2F;library&#x2F;ubuntu</span><br><span class="line">aed158d74952: Pull complete </span><br><span class="line">773ae8273d14: Pull complete </span><br><span class="line">d1d487w88782: Pull complete </span><br><span class="line">cd3d6cd6c0cf: Pull complete </span><br><span class="line">8d73bu79120c: Pull complete </span><br><span class="line">Digest: sha256:35bc48a1ca97c3f74rhf378hj92hd82j29i4hf4hf84nf0dhnsid232de8d8</span><br><span class="line">Status: Downloaded newer image for docker.io&#x2F;ubuntu:latest</span><br></pre></td></tr></table></figure><p>你输入的命令实际上相当于<code>docker pull registry.hub.docker.com/ubuntu:latest</code>命令，即从注册服务器<code>registry.hub.docker.com</code>中的名为<code>ubuntu</code>的仓库中下载标签为<code>latest</code>的镜像。</p><p>由于我的lab统一要求，ubuntu需要14.04版本，所以我在hub里面搜了搜，找到了一个用户分享的14.04 64位纯净镜像（base image），下面将他的镜像扒下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull chug&#x2F;ubuntu14.04x64</span><br></pre></td></tr></table></figure><p>这个用户还有很多其他版本的ubuntu系统，12 13 14的32位64位都有，全是纯净镜像。</p><ul><li>查看你本地的镜像仓库！</li></ul><p>把初始镜像拉下来后，就可以启动它了，不过，可以先使用<code>docker images</code>命令查看你自己的本地镜像，我随便找了个例子，你的也应该是类似这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io&#x2F;ubuntu    16.04               e4415b714b62        11 days ago         128.1 MB</span><br><span class="line">docker.io&#x2F;ubuntu    latest              e4415b714b62        11 days ago         128.1 MB</span><br><span class="line">docker.io&#x2F;ubuntu    12.04               aefa163f7a7e        11 days ago         103.5 MB</span><br><span class="line">docker.io&#x2F;centos    latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br></pre></td></tr></table></figure><p>从网上一个教程中找到以下说法，比我说的好，那就看这个吧！</p><div class="note simple"><p>在列出信息中，可以看到几个字段信息:</p><ul><li>来自于哪个仓库，比如 ubuntu</li><li>镜像的标记，比如 16.04</li><li>它的 ID 号(唯一)，比如e4415b714b62</li><li>创建时间</li><li>镜像大小</li></ul><p>其中镜像的 ID 唯一标识了镜像，注意到 ubuntu:16.04 和 ubuntu:latest具有相同的镜像 ID ，说明它们实际上是同一镜像。 TAG 信息用来标记来自同一个仓库的不同镜像。例如 ubuntu 仓库中有多个镜像，通过 TAG 信息来区分发行版本，例如10.04 、 12.04 、 12.10 、 13.04 、 14.04 等。例如可以使用<code>docker run -t -i ubuntu:16.04 /bin/bash</code>命令指定使用镜像<code>ubuntu:16.04</code>来启动一个容器。如果不指定具体的标记，则默认使用<code>latest</code>标记信息。</p></div><ul><li>启动你的镜像并尽情安装软件吧！</li></ul><p>以下内容均以我自己pull下来的chug的初始镜像为例：</p><p>现在你已经有一个初始的镜像了，注意这个里面是什么都没有的，连vim都没装，是精简到不能再精简的镜像了。</p><p>首先启动它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -it chug&#x2F;ubuntu14.04x64 &#x2F;bin&#x2F;bash</span><br><span class="line">root@aa97ba3292ce:&#x2F;#</span><br></pre></td></tr></table></figure><p>-it 表示运行在交互模式，是-i -t的缩写，即-it是两个参数：-i和-t。前者表示打开并保持stdout，后者表示分配一个终端（pseudo-tty）一般这个模式就是可以启动bash，然后和容器有命令行的交互</p><p>可以看到我们终端的字头变成<code>root@aa97ba3292ce:/#</code>了，这就意味着我们的镜像已经创建了一个容器实例。现在我们可以对这个“ubuntu系统”进行操作了</p><p>比如安装vim：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@aa97ba3292ce:&#x2F;# apt-get install vim</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">The following extra packages will be installed:</span><br><span class="line">  file libexpat1 libffi6 libgpm2 libmagic1 libpython2.7 libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support vim-common vim-runtime</span><br><span class="line">Suggested packages:</span><br><span class="line">  gpm ctags vim-doc vim-scripts</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  file libexpat1 libffi6 libgpm2 libmagic1 libpython2.7 libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support vim vim-common vim-runtime</span><br><span class="line">0 upgraded, 14 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line">Need to get 10.7 MB of archives.</span><br><span class="line">After this operation, 50.7 MB of additional disk space will be used.</span><br><span class="line">Do you want to continue? [Y&#x2F;n]</span><br></pre></td></tr></table></figure><p>看到我没有用sudo，是因为本来就已经是超级用户（root）状态了。</p><p>同理按照我自己的需求，我安装了gcc和gdb</p><ul><li>想退出容器？很简单！</li></ul><p>如果使用exit，命令退出，则容器的状态处于Exit，而不是后台运行。如果想让容器一直运行，而不是停止，可以使用快捷键 ctrl+p ctrl+q 退出，此时容器的状态为Up。</p><p>查看当前正在运行的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps</span><br><span class="line">CONTAINER ID     IMAGE        COMMAND      CREATED       STATUS       PORTS        NAMES</span><br><span class="line">aa97ba3292ce  chug&#x2F;ubuntu14.04x64   &quot;&#x2F;bin&#x2F;bash&quot;    7 minutes ago  Up 7 minutes   relaxed_hoover</span><br></pre></td></tr></table></figure><p>看到当前有一个ID为aa97ba3292ce的容器。启动、停止、重启容器aa97ba3292ce的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker start aa97ba3292ce</span><br><span class="line">~$ docker stop aa97ba3292ce</span><br><span class="line">~$ docker restart aa97ba3292ce</span><br></pre></td></tr></table></figure><p>后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker attach aa97ba3292ce</span><br></pre></td></tr></table></figure><ul><li>软件装完，想保存环境？commit帮你！</li></ul><p>将容器转化为一个镜像，即执行commit操作，完成后可使用<code>docker images</code>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@aa97ba3292ce:&#x2F;#exit &#x2F;&#x2F;先退出容器</span><br><span class="line">~$ docker commit -m &quot;ubuntu with vim&quot; -a &quot;sgy&quot; aa97ba3292ce sgy&#x2F;ubuntu:vim</span><br><span class="line">~$ docker images</span><br><span class="line">REPOSITORY                    TAG    IMAGE ID         CREATED             SIZE</span><br><span class="line">sgy&#x2F;ubuntu                    vim    52166e4475ed     5 seconds ago       358.1 MB</span><br><span class="line">chug&#x2F;ubuntu14.04x64           latest 0584b3d2cf6d     9 days ago          196.5 MB</span><br></pre></td></tr></table></figure><p>其中，-m指定说明信息；-a指定用户信息；aa97ba3292ce代表容器的id；sgy/ubuntu:vim指定目标镜像的用户名、仓库名和 tag 信息。我这里都是为了博客瞎编的用户名，我自己的用户名也不是sgy，你运行命令的时候使用自己注册Docker时的用户名。</p><p>此时Docker中就有了我们新建的镜像sgy/ubuntu:vim，此镜像和原有的ubuntu镜像区别在于多了个vim工具。此时我们利用新镜像创建的容器，本身就自带vim了。</p><p>启动新创建的镜像，可以看到vim已经自带了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -it sgy&#x2F;ubuntu:vim &#x2F;bin&#x2F;bash</span><br><span class="line">root@520afc596c51:&#x2F;# vim --version</span><br><span class="line">VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Apr  4 2017 18:14:54)</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;omitted by sgy(Copyright © http:&#x2F;&#x2F;blog.csdn.net&#x2F;s_gy_zetrov. All Rights Reserved)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>利用exit退出容器。此时Docker引擎中就有了两个容器，可使用<code>docker ps -a</code>查看。</p><ul><li>想要删除容器或者镜像？用这个！</li></ul><p>如果想删除容器或者镜像，可以使用rm命令，注意：删除镜像前必须先删除以此镜像为基础的容器（哪怕是已经停止的容器），否则无法删除该镜像，会报错<code>Failed to remove image (e4415b714b62): Error response from daemon: conflict: unable to delete e4415b714b62 (cannot be forced) - image has dependent child images</code>类似这种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker rm container_id</span><br><span class="line">~$ docker rmi image_id</span><br></pre></td></tr></table></figure><p>有的时候尽管删除了全部容器，镜像还是无法删除，这时点击mac顶栏中的docker logo，选择restart，然后再试一次rmi，应该就没问题了。</p><ul><li>附上一张高大上的Docker命令图</li></ul><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/dockerrumf4.webp"></p><ul><li>一次配置，到处使用？那就push到hub上吧</li></ul><p>因为之前已经在Docker.app中登录了Docker账号，所以现在直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker push sgy&#x2F;ubuntu:vim</span><br></pre></td></tr></table></figure><p>就可以了！<br>下次到了机房，在ubuntu系统中安装Docker，配置好加速器，启动Docker，<code>docker login</code>登录自己的账号，然后直接<code>~$ docker pull sgy/ubuntu:vim</code>就可以把你push到hub的已经配置好的环境的镜像给扒下来。做完实验，再push上去就ok了！</p><h1 id="Docker中安装gcc、gdb时遇到的问题"><a href="#Docker中安装gcc、gdb时遇到的问题" class="headerlink" title="Docker中安装gcc、gdb时遇到的问题"></a>Docker中安装gcc、gdb时遇到的问题</h1><ul><li>add-apt-repository: command not found</li></ul><p>14.04系统解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install software-properties-common</span><br></pre></td></tr></table></figure><p>older版本的系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-software-properties</span><br></pre></td></tr></table></figure><ul><li>Docker中使用gdb无法进入断点，无法调试</li></ul><p>加上<code>--privileged</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -it --privileged sgy&#x2F;ubuntu:vim &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入门Docker，你要下载什么？注册什么？&quot;&gt;&lt;a href=&quot;#入门Docker，你要下载什么？注册什么？&quot; class=&quot;headerlink&quot; title=&quot;入门Docker，你要下载什么？注册什么？&quot;&gt;&lt;/a&gt;入门Docker，你要下载什么？注册什么？&lt;/</summary>
      
    
    
    
    <category term="Docker" scheme="https://matthew84.cf/categories/Docker/"/>
    
    <category term="入门" scheme="https://matthew84.cf/categories/Docker/%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Docker" scheme="https://matthew84.cf/tags/Docker/"/>
    
    <category term="入门" scheme="https://matthew84.cf/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB——软件及基本操作介绍</title>
    <link href="https://matthew84.cf/archives/db30bcc7.html"/>
    <id>https://matthew84.cf/archives/db30bcc7.html</id>
    <published>2020-11-03T13:15:00.000Z</published>
    <updated>2020-11-04T00:46:53.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB软件介绍"><a href="#MATLAB软件介绍" class="headerlink" title="MATLAB软件介绍"></a>MATLAB软件介绍</h1><h2 id="matlab的界面"><a href="#matlab的界面" class="headerlink" title="matlab的界面"></a>matlab的界面</h2><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/matlab1.webp"><br>左上角，home标签下，找到layout进行设置/复位，可以设置各板块的显示与隐藏。其中有几个部分，请务必要显示</p><ol><li>Current Folder：中文一般翻译成工作路径，一般设置成一个自己建立的、有读写权限的文件夹，例如我的文档下建立一个matlab文件夹</li><li>Command Window：字面意思是命令窗口，用来运行代码，所有的代码都是在这里输入</li><li>Workspace：字面意思是工作空间，其实就是暂存所有运行结果的地方，“暂”的具体含义是：关闭matlab后丢失</li></ol><h2 id="软件中的基本概念"><a href="#软件中的基本概念" class="headerlink" title="软件中的基本概念"></a>软件中的基本概念</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>matlab之所以强大，就是因为提供大量的函数，你也可以建立自定义函数，方法是：Home-&gt;New-&gt;function。自定义函数一般保存在工作路径下。函数文件的特征是：扩展名m，内容的第一行以function开头，后续内容是“输出变量=函数名(输入变量)”。且函数名和文件名相同。<br>每个函数在Command Window中运行，用来完成特定的计算任务，运行方式是输入“输出变量=函数名(输入变量)”，然后按回车。例如有个系统自带的函数是用来求绝对值的，函数名abs，所以在Command Window里输入“a=abs(-1)”，就会显示运算结果为“a=1”。且运算结果会在Workspace里出现一个变量a，双击后可看到a的值是1。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>可以理解为特殊的函数，这种函数内容的开头没有function那行，因此没有输入、输出变量，也没有函数名。文件扩展名和函数一样是m，也需要在Command Window里运行。脚本都是用户建立的，方法是：Home-&gt;New Script。一般保存在工作路径下。脚本的功能就是完成用户需要的、复杂的计算任务，通常脚本里会调用很多函数。</p><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>一般翻译为界面，就是人机交互界面的意思。写脚本处理问题的方法有点麻烦，让人看起来更像是码农，所以现在很多问题可以通过界面点点鼠标解决。这时候就需要打开界面，打开方法是：在APPS标签里可以找到所有已安装的GUI工具，单击即可。注意右边有个小三角可以点开。和函数一样，用户也可以自己建立自定义GUI，这部分较为复杂，对新手而言有点遥远。</p><h3 id="toolbox"><a href="#toolbox" class="headerlink" title="toolbox"></a>toolbox</h3><p>一般翻译成工具箱，matlab将功能相近或者应用上自成体系的一组函数和GUI打包成一个toolbox。正版的matlab在购买时，几乎每一个toolbox都是要单独收费的，所以toolbox也可以理解为matlab产品的模块，一个工具箱就是一个产品/商品。</p><h3 id="simulink"><a href="#simulink" class="headerlink" title="simulink"></a>simulink</h3><p>一般用matlab解决问题的过程是：用户自定义脚本，在Command Window里运行脚本。而脚本的运行逻辑是顺序执行，和一般的编程一样。simulink则提供另一种思路，图形化编程，有点像labview，这种方法很适合于物理模型的仿真，因此有时用“matlab编程”和“simulink仿真”强调。使用方法是在home标签下点击simulink。</p><h2 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h2><p>常用的获得帮助有四种方法</p><ol><li>右上角home标签里，有个Help标志，点开后可以获得各工具箱/产品的完整帮助文档。新版本中默认使用在线，改用本地帮助的办法是在home标签里，Preferences下的matlab/Help里选择installed locally</li><li>cn.mathworks.com官网上找到支持，然后可以获得教程。这种方法获得的帮助文档和第一种方法一样。</li><li>在Command Window里输入 doc+函数名 来获得帮助。比如输入”doc fft”可以获得离散傅里叶变换函数fft的帮助和范例。这种方法获得的文档是前两种方法文档中的部分。当然，前提是你要知道函数名，才能找到帮助。这种方法适合于获得系统自带函数的使用说明。</li><li>使用GUI时，通常界面的角落里有Help，点开可以获得帮助。这种方法获得的文档是第一和第二种方法文档中的部分。这种方法适合于获得系统自带GUI的使用说明。<br>这几种方法中，最常用的是第三种，只要知道自己需要的函数名，就可以用这种方式获得说明和范例。而实际使用中，一般常用的系统自带函数，也并不是非常多，大概几十个？真正需要牢记使用方法的可能就几个，通常都是知道函数名，要用的时候doc一下。</li></ol><h1 id="命令窗口的基本配置"><a href="#命令窗口的基本配置" class="headerlink" title="命令窗口的基本配置"></a>命令窗口的基本配置</h1><h2 id="format命令"><a href="#format命令" class="headerlink" title="format命令"></a>format命令</h2><p>进行数据类型转换，行间距调节等功能时，用</p><pre><code>format + 关键词 回车</code></pre><p>eg：format long 回车   //将数据变为长整型</p><pre><code>format compat/loose 回车  //调节行间距紧密/松散</code></pre><h2 id="clc命令"><a href="#clc命令" class="headerlink" title="clc命令"></a>clc命令</h2><p>清屏。即清理当前屏幕上的内容，屏幕上没有了，但保留在内存中了</p><h2 id="clear命令"><a href="#clear命令" class="headerlink" title="clear命令"></a>clear命令</h2><p>删除某一变量，或清空工作区</p><pre><code>clear + 变量名 回车</code></pre><p>eg：clear a 回车  //删除工作区中的a变量</p><pre><code>clear或者clear all //清空工作区。建议在刚打开matlab窗口时先清空一下工作区。</code></pre><h2 id="whos命令"><a href="#whos命令" class="headerlink" title="whos命令"></a>whos命令</h2><p>查看某变量详细信息</p><pre><code>whos 回车  //查看所有变量信息whos + 变量名 回车 // 查看该变量详细信息</code></pre><p>eg：whos a 回车</p><h2 id="x-ylable命令-给xy轴加横纵坐标说明"><a href="#x-ylable命令-给xy轴加横纵坐标说明" class="headerlink" title="x/ylable命令  //给xy轴加横纵坐标说明"></a>x/ylable命令  //给xy轴加横纵坐标说明</h2><p>eg：xlable （‘x轴’） 回车</p><h2 id="disp-屏幕输出函数，类似于c语言中的printf（）函数"><a href="#disp-屏幕输出函数，类似于c语言中的printf（）函数" class="headerlink" title="disp()  //屏幕输出函数，类似于c语言中的printf（）函数"></a>disp()  //屏幕输出函数，类似于c语言中的printf（）函数</h2><p>disp函数直接将内容输出在Matlab命令窗口中,关键是看disp函数怎么把字符和数字在一起进行显示。<br>disp(X)函数只有一个输入，当你有多个字符串作为输入时就会报错。<br>例如:</p><pre><code>disp(&#39;Alice is &#39; , num2str(12) , &#39; years old!&#39; );</code></pre><p>就会报错–输入参数过多。<br>但是将里边的内容用中括号一括就成了一个字符串，<br>例如:</p><pre><code>str=[&#39;Alice is &#39; num2str(12) &#39; years old!&#39;];disp(str);</code></pre><p>上边这句话也就等价于:</p><pre><code>disp=([&#39;Alice is &#39; num2str(12) &#39; years old!&#39;]);</code></pre><p>这就是加中括号的原因，而不是因为num2str()，<br>因为disp(num2str(12));也是正确的，因为里边就只有一个字符串。</p><h2 id="zeros函数-创建一个全为零元素的数组"><a href="#zeros函数-创建一个全为零元素的数组" class="headerlink" title="zeros函数 //创建一个全为零元素的数组"></a>zeros函数 //创建一个全为零元素的数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、B &#x3D; zeros(n)  返回一个n x n的零矩阵.如果n不是一个标量，将抛出错误。</span><br><span class="line">2、B &#x3D; zeros(m,n) or B &#x3D; zeros([m n])  返回一个m x n的零矩阵。</span><br><span class="line">3、B &#x3D; zeros(d1,d2,d3...) or B &#x3D; zeros([d1 d2 d3...]) 返回一个d1-by-d2-by-d3-by-... .的零元素数组。</span><br><span class="line">4、B &#x3D; zeros(size(A))  返回一个和A一样大小的零数组。</span><br><span class="line">5、zeros(m, n,...,classname) or zeros([m,n,...]  返回一个类型为classname的m x n x...零数组。classname可以是下面一些值：double&#39;, &#39;single&#39;, &#39;int8&#39;, &#39;uint8&#39;, &#39;int16&#39;, &#39;uint16&#39;, &#39;int32&#39;, or &#39;uint32&#39;</span><br><span class="line">示例</span><br><span class="line">    x &#x3D; zeros(2,3,&#39;int8&#39;);</span><br></pre></td></tr></table></figure><p>备注<br>    MATLAB语言 没有一个 维度 声明 ; MATLAB 自动为矩阵分配存储空间。 然而，对于大型矩阵 ， MATLAB程序可能会执行得更快 ，如果零函数用于设置一个矩阵，其元素将产生一次 ， 或行或列的时间预留存储空间。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; zeros(1,n); </span><br><span class="line">for i &#x3D; 1:n</span><br><span class="line">x(i) &#x3D; i; </span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MATLAB软件介绍&quot;&gt;&lt;a href=&quot;#MATLAB软件介绍&quot; class=&quot;headerlink&quot; title=&quot;MATLAB软件介绍&quot;&gt;&lt;/a&gt;MATLAB软件介绍&lt;/h1&gt;&lt;h2 id=&quot;matlab的界面&quot;&gt;&lt;a href=&quot;#matlab的界面&quot; c</summary>
      
    
    
    
    <category term="MATLAB" scheme="https://matthew84.cf/categories/MATLAB/"/>
    
    <category term="基本介绍" scheme="https://matthew84.cf/categories/MATLAB/%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="基本介绍" scheme="https://matthew84.cf/tags/%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="https://matthew84.cf/archives/4ad73f8e.html"/>
    <id>https://matthew84.cf/archives/4ad73f8e.html</id>
    <published>2020-11-03T13:14:42.000Z</published>
    <updated>2020-11-04T00:36:22.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令大全"><a href="#Linux常用命令大全" class="headerlink" title="Linux常用命令大全"></a>Linux常用命令大全</h1><p>最近都在和Linux打交道，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。我将我了解到的命令列举一下，仅供大家参考：</p><h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><p>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p><h1 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h1><p>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销 </p><h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><p>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p><p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><p>#文件搜索<br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p><h1 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h1><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p><h1 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h1><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p><h1 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h1><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><h1 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h1><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p><h1 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h1><p>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p><h1 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h1><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p><h1 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h1><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><h1 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h1><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p><h1 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h1><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p><h1 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h1><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p><h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p><h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p><h1 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h1><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p><h1 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h1><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p><h1 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h1><p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统 </p><h1 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h1><p>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p><h1 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h1><p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p><h1 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h1><p>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0/0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’<br>route del 0/0 gw IP_gateway remove static route<br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database </p><h1 id="JPS工具"><a href="#JPS工具" class="headerlink" title="JPS工具"></a>JPS工具</h1><p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p><p>我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p><p>**使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</p><p>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path**.</p><p>$&gt; jps<br>23991 Jps<br>23789 BossMain<br>23651 Resin</p><p>比较常用的参数：</p><p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong><br>$&gt;  jps -q<br>28680<br>23789<br>23651</p><p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</strong></p><p>$&gt; jps -m<br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log</p><p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p><p>$&gt; jps -l<br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin</p><p><strong>-v 输出传递给JVM的参数</strong></p><p>$&gt; jps -v<br>23789 BossMain<br>28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd</p><p>k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -</p><p>Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl</p><p><strong>sudo jps看到的进程数量最全</strong></p><p><strong>jps 192.168.0.77</strong></p><p><strong>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</strong></p><p><strong>（前提是远程服务器提供jstatd服务）</strong></p><p><strong>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux常用命令大全&quot;&gt;&lt;a href=&quot;#Linux常用命令大全&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令大全&quot;&gt;&lt;/a&gt;Linux常用命令大全&lt;/h1&gt;&lt;p&gt;最近都在和Linux打交道，感觉还不错。我觉得Linux相比wind</summary>
      
    
    
    
    <category term="Linux" scheme="https://matthew84.cf/categories/Linux/"/>
    
    <category term="命令大全" scheme="https://matthew84.cf/categories/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    
    
    <category term="Linux" scheme="https://matthew84.cf/tags/Linux/"/>
    
    <category term="命令大全" scheme="https://matthew84.cf/tags/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程——进程间通信：消息队列</title>
    <link href="https://matthew84.cf/archives/edac0a42.html"/>
    <id>https://matthew84.cf/archives/edac0a42.html</id>
    <published>2020-11-03T13:14:28.000Z</published>
    <updated>2020-11-04T00:34:04.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>消息队列提供了一种在两个不相关的进程之间传递数据的简单高效的方法，其特点如下：</p><ol><li><p>消息队列可以实现消息的随机查询。消息不一定要以先进先出的次序读取，编程时可以按消息的类型读取。</p></li><li><p>消息队列允许一个或多个进程向它写入或者读取消息。</p></li><li><p>与无名管道、命名管道一样，从消息队列中读出消息，消息队列中对应的数据都会被删除。</p></li><li><p>每个消息队列都有消息队列标识符，消息队列的标识符在整个系统中是唯一的。</p></li><li><p>消息队列是消息的链表，存放在内存中，由内核维护。只有内核重启或人工删除消息队列时，该消息队列才会被删除。若不人工删除消息队列，消息队列会一直存在于系统中。</p></li></ol><p>消息队列常用操作函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line"> </span><br><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line">int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);</span><br><span class="line">int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);</span><br><span class="line">int msgctl(int msqid, int cmd, struct msqid_ds *buf);</span><br></pre></td></tr></table></figure><p><code>对于消息队列的操作，我们可以类比为这么一个过程</code>：假如 A 有个东西要给 B，因为某些原因 A 不能当面直接给 B，这时候他们需要借助第三方托管（如银行），A 找到某个具体地址的建设银行，然后把东西放到某个保险柜里（如 1 号保险柜），对于 B 而言，要想成功取出 A 的东西，必须保证去同一地址的同一间银行取东西，而且只有 1 号保险柜的东西才是 A 给自己的。</p><p>对于上面的例子，涉及到几个比较重要的信息：<code>地址、银行、保险柜号码</code>。</p><p>只有同一个地址才能保证是同一个银行，只有是同一个银行双方才能借助它来托管，只有同一个保险柜号码才能保证是对方托管给自己的东西。</p><p>而在消息队列操作中，<code>键（key）值</code>相当于地址，<code>消息队列标示符</code>相当于具体的某个<code>银行</code>，<code>消息类型</code>相当于保险柜号码。</p><p>同一个<code>键（key）值</code>可以保证是同一个消息队列，同一个<code>消息队列标示符</code>才能保证不同的进程可以相互通信，同一个<code>消息类型</code>才能保证某个进程取出是对方的信息。</p><h1 id="键（key）值"><a href="#键（key）值" class="headerlink" title="键（key）值"></a>键（key）值</h1><p>System V 提供的进程间通信机制需要一个 key 值，通过 key 值就可在系统内获得一个唯一的消息队列标识符。key 值可以是人为指定的，也可以通过 ftok() 函数获得。</p><p>需要的头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br></pre></td></tr></table></figure><h2 id="key-t-ftok-const-char-pathname-int-proj-id"><a href="#key-t-ftok-const-char-pathname-int-proj-id" class="headerlink" title="key_t ftok(const char *pathname, int proj_id);"></a>key_t ftok(const char *pathname, int proj_id);</h2><p>功能：</p><pre><code>获取键（key）值</code></pre><p>参数：</p><pre><code>pathname: 路径名proj_id: 项目ID，非 0 整数(只有低 8 位有效)</code></pre><p>返回值：</p><pre><code>成功：key 值失败：-1</code></pre><h1 id="消息队列的创建"><a href="#消息队列的创建" class="headerlink" title="消息队列的创建"></a>消息队列的创建</h1><p>所需头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br></pre></td></tr></table></figure><h2 id="int-msgget-key-t-key-int-msgflg"><a href="#int-msgget-key-t-key-int-msgflg" class="headerlink" title="int msgget(key_t key, int msgflg);"></a>int msgget(key_t key, int msgflg);</h2><p>功能：</p><pre><code>创建一个新的或打开一个已经存在的消息队列。不同的进程调用此函数，只要用相同的 key 值就能得到同一个消息队列的标识符。</code></pre><p>参数：</p><pre><code>key: ftok() 返回的 key 值msgflg: 标识函数的行为及消息队列的权限，其取值如下：IPC_CREAT：创建消息队列。IPC_EXCL： 检测消息队列是否存在。位或权限位：消息队列位或权限位后可以设置消息队列的访问权限，格式和open() 函数的 mode_t 一样（open() 的使用请点此链接），但可执行权限未使用。</code></pre><p>返回值：</p><pre><code>成功：消息队列的标识符失败：-1</code></pre><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">key_t key;</span><br><span class="line">int  msgqid;</span><br><span class="line"></span><br><span class="line">key &#x3D; ftok(&quot;.&quot;, 2012); &#x2F;&#x2F; key 值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建消息队列</span><br><span class="line">msgqid &#x3D; msgget(key, IPC_CREAT|0666);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/linuxxcxi1.webp"></p><h1 id="消息队列的读写操作"><a href="#消息队列的读写操作" class="headerlink" title="消息队列的读写操作"></a>消息队列的读写操作</h1><p>对于消息队列的读写，都是以消息类型为准。<code>消息类型相当于保险柜号码</code>，A 往 1 号保险柜放东西，对方想取出 A 的东西必须也是从 1 号保险柜里取。同理，某一进程往消息队列添加 a 类型的消息，别的进程要想取出这进程添加的信息也必须取 a 类型的消息。</p><p>在学习消息队列读写操作前，我们先学习消息队列的消息格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _msg</span><br><span class="line">&#123;</span><br><span class="line">long mtype; &#x2F;&#x2F; 消息类型</span><br><span class="line">char mtext[100]; &#x2F;&#x2F; 消息正文</span><br><span class="line">&#x2F;&#x2F;…… ……          &#x2F;&#x2F; 消息的正文可以有多个成员</span><br><span class="line">&#125;MSG;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>消息类型必须是长整型的，而且必须是结构体类型的第一个成员</code>，类型下面是消息正文，正文可以有多个成员（正文成员可以是任意数据类型的）。至于这个结构体类型叫什么名字，里面成员叫什么名字，自行定义，没有明文规定。</p><h2 id="添加信息"><a href="#添加信息" class="headerlink" title="添加信息"></a>添加信息</h2><p>所需头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br></pre></td></tr></table></figure><p><code>int msgsnd(  int msqid, const void *msgp, size_t msgsz, int msgflg)</code></p><p>功能：</p><pre><code>将新消息添加到消息队列。</code></pre><p>参数：</p><pre><code>msqid： 消息队列的标识符。msgp：  待发送消息结构体的地址。msgsz： 消息正文的字节数。msgflg：函数的控制属性，其取值如下：0：msgsnd() 调用阻塞直到条件满足为止。IPC_NOWAIT: 若消息没有立即发送则调用该函数的进程会立即返回。</code></pre><p>返回值：</p><pre><code>成功：0失败：-1</code></pre><h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><p>所需头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br></pre></td></tr></table></figure><p><code>ssize_t msgrcv( int msqid, void *msgp,  size_t msgsz, long msgtyp, int msgflg )</code></p><p>功能：</p><pre><code>从标识符为 msqid 的消息队列中接收一个消息。一旦接收消息成功，则消息在消息队列中被删除。</code></pre><p>参数：</p><pre><code>msqid：消息队列的标识符，代表要从哪个消息列中获取消息。msgp： 存放消息结构体的地址。msgsz：消息正文的字节数。msgtyp：消息的类型。可以有以下几种类型：msgtyp = 0：返回队列中的第一个消息。msgtyp &gt; 0：返回队列中消息类型为 msgtyp 的消息（常用）。msgtyp &lt; 0：返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。注意：在获取某类型消息的时候，若队列中有多条此类型的消息，则获取最先添加的消息，即先进先出原则。msgflg：函数的控制属性。其取值如下：0：msgrcv() 调用阻塞直到接收消息成功为止。MSG_NOERROR: 若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程。IPC_NOWAIT: 调用进程会立即返回。若没有收到消息则立即返回 -1。</code></pre><p>返回值：</p><pre><code>成功：读取消息的长度失败：-1</code></pre><h1 id="消息队列的控制"><a href="#消息队列的控制" class="headerlink" title="消息队列的控制"></a>消息队列的控制</h1><p>所需头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br></pre></td></tr></table></figure><p><code>int msgctl(int msqid, int cmd, struct msqid_ds *buf)</code><br>功能：</p><pre><code>对消息队列进行各种控制，如修改消息队列的属性，或删除消息消息队列。</code></pre><p>参数：</p><pre><code>msqid：消息队列的标识符。cmd：函数功能的控制。其取值如下：IPC_RMID：删除由 msqid 指示的消息队列，将它从系统中删除并破坏相关数据结构。IPC_STAT：将 msqid 相关的数据结构中各个元素的当前值存入到由 buf 指向的结构中。相当于，把消息队列的属性备份到 buf 里。IPC_SET：将 msqid 相关的数据结构中的元素设置为由 buf 指向的结构中的对应值。相当于，消息队列原来的属性值清空，再由 buf 来替换。buf：msqid_ds 数据类型的地址，用来存放或更改消息队列的属性。</code></pre><p>返回值：</p><pre><code>成功：0失败：-1</code></pre><h1 id="实践示例"><a href="#实践示例" class="headerlink" title="实践示例"></a>实践示例</h1><p>写端示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">typedef struct _msg</span><br><span class="line">&#123;</span><br><span class="line">long mtype;</span><br><span class="line">char mtext[50];</span><br><span class="line">&#125;MSG;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">key_t key;</span><br><span class="line">int  msgqid;</span><br><span class="line">MSG msg;</span><br><span class="line"></span><br><span class="line">key &#x3D; ftok(&quot;.&#x2F;&quot;, 2015); &#x2F;&#x2F; key 值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建消息队列</span><br><span class="line">msgqid &#x3D; msgget(key, IPC_CREAT|0666);</span><br><span class="line">if(msgqid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;msgget&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg.mtype &#x3D; 10;&#x2F;&#x2F; 消息类型</span><br><span class="line">strcpy(msg.mtext, &quot;hello mike&quot;); &#x2F;&#x2F; 正文内容</span><br><span class="line"></span><br><span class="line">&#x2F;* 添加消息</span><br><span class="line">msg_id:消息队列标识符</span><br><span class="line">&amp;msg：消息结构体地址</span><br><span class="line">sizeof(msg)-sizeof(long)：消息正文大小</span><br><span class="line">0：习惯用0</span><br><span class="line">*&#x2F;</span><br><span class="line">msgsnd(msgqid, &amp;msg, sizeof(msg)-sizeof(long), 0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读端示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">typedef struct _msg</span><br><span class="line">&#123;</span><br><span class="line">long mtype;</span><br><span class="line">char mtext[50];</span><br><span class="line">&#125;MSG;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">key_t key;</span><br><span class="line">int  msgqid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key &#x3D; ftok(&quot;.&#x2F;&quot;, 2015); &#x2F;&#x2F; key 值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建消息队列</span><br><span class="line">msgqid &#x3D; msgget(key, IPC_CREAT|0666);</span><br><span class="line">if(msgqid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;msgget&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MSG msg;</span><br><span class="line">memset(&amp;msg, 0, sizeof(msg));</span><br><span class="line"></span><br><span class="line">&#x2F;* 取出类型为 10 的消息</span><br><span class="line">msg_id:消息队列标识符</span><br><span class="line">&amp;msg：消息结构体地址</span><br><span class="line">sizeof(msg)-sizeof(long)：消息正文大小</span><br><span class="line">(long)10：消息的类型</span><br><span class="line">0：习惯用0</span><br><span class="line">*&#x2F;</span><br><span class="line">msgrcv(msgqid, &amp;msg, sizeof(msg)-sizeof(long), (long)10, 0);</span><br><span class="line">printf(&quot;msg.mtext&#x3D;%s\n&quot;, msg.mtext); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把消息队列删除</span><br><span class="line">&#x2F;&#x2F; IPC_RMID：删除标志位</span><br><span class="line">msgctl(msgqid, IPC_RMID, NULL);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/linuxxcxi2.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/linuxxcxi3.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;消息队列提供了一种在两个不相关的进程之间传递数据的简单高效的方法，其特点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;消息队列可以实现消息的随机查</summary>
      
    
    
    
    <category term="Linux" scheme="https://matthew84.cf/categories/Linux/"/>
    
    <category term="进程通信" scheme="https://matthew84.cf/categories/Linux/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="Linux" scheme="https://matthew84.cf/tags/Linux/"/>
    
    <category term="进程通信" scheme="https://matthew84.cf/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    <category term="消息队列" scheme="https://matthew84.cf/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux线程浅析</title>
    <link href="https://matthew84.cf/archives/e7d843e1.html"/>
    <id>https://matthew84.cf/archives/e7d843e1.html</id>
    <published>2020-11-03T13:14:09.000Z</published>
    <updated>2020-11-03T14:30:47.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程和线程的区别与联系"><a href="#进程和线程的区别与联系" class="headerlink" title="进程和线程的区别与联系"></a>进程和线程的区别与联系</h1><p>在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，它并不执行什么, 只是维护应用程序所需的各种资源，而线程则是真正的执行实体。</p><p>为了让进程完成一定的工作，进程必须至少包含一个线程。</p><p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是资源分配的最小单位。</p><p>线程存在与进程当中，是操作系统调度执行的最小单位。说通俗点，线程就是干活的。</p><p><code>如果说进程是一个资源管家，负责从主人那里要资源的话，那么线程就是干活的苦力</code>。一个管家必须完成一项工作，就需要最少一个苦力，也就是说，一个进程最少包含一个线程，也可以包含多个线程。苦力要干活，就需要依托于管家，所以说一个线程，必须属于某一个进程。进程有自己的地址空间，线程使用进程的地址空间，也就是说，进程里的资源，线程都是有权访问的，比如说堆啊，栈啊，静态存储区什么的。</p><p>线程就是个无产阶级，但无产阶级干活，总得有自己的劳动工具吧，这个劳动工具就是栈，线程有自己的栈，这个栈仍然是使用进程的地址空间，只是这块空间被线程标记为了栈。每个线程都会有自己私有的栈，这个栈是不可以被其他线程所访问的。</p><p>进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler，等；</p><p>线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集，等；</p><p>然而，一直以来，linux 内核并没有线程的概念。每一个执行实体都是一个 task_struct 结构，通常称之为进程。</p><p>进程是一个执行单元，维护着执行相关的动态资源。同时，它又引用着程序所需的静态资源。<code>通过系统调用 clone 创建子进程时，可以有选择性地让子进程共享父进程所引用的资源，这样的子进程通常称为轻量级进程</code>。</p><p>linux 上的线程就是基于轻量级进程，由用户态的 pthread 库实现的。使用 pthread 以后，在用户看来，每一个 task_struct 就对应一个线程，而一组线程以及它们所共同引用的一组资源就是一个进程。</p><p>但是，一组线程并不仅仅是引用同一组资源就够了，它们还必须被视为一个整体。</p><p>对此，POSIX 标准提出了如下要求：</p><ol><li><p>查看进程列表的时候，相关的一组 task_struct 应当被展现为列表中的一个节点；</p></li><li><p>发送给这个“进程”的信号（对应 kill 系统调用）， 将被对应的这一组 task_struct 所共享，并且被其中的任意一个“线程”处理；</p></li><li><p>发送给某个“线程”的信号（对应 pthread_kill）， 将只被对应的一个task_struct接收，并且由它自己来处理；</p></li><li><p>当“进程”被停止或继续时（对应 SIGSTOP/SIGCONT 信号）， 对应的这一组 task_struct 状态将改变；</p></li><li><p>当“进程”收到一个致命信号（比如由于段错误收到 SIGSEGV 信号）， 对应的这一组 task_struct 将全部退出；</p></li><li><p>等等（以上可能不够全）</p></li></ol><h1 id="LinuxThreads"><a href="#LinuxThreads" class="headerlink" title="LinuxThreads"></a>LinuxThreads</h1><p>在 linux 2.6 以前，pthread 线程库对应的实现是一个名叫 LinuxThreads 的 lib。</p><p>LinuxThreads 利用前面提到的轻量级进程来实现线程，但是对于 POSIX 提出的那些要求，LinuxThreads 除了第 5 点以外<code>（当“进程”收到一个致命信号（比如由于段错误收到 SIGSEGV 信号）， 对应的这一组 task_struct 将全部退出）</code>，都没有实现（实际上是无能为力）：</p><ol><li><p>如果运行了 A 程序，A 程序创建了 10 个线程，那么在 shell 下执行 ps 命令时将看到 11 个 A 进程，而不是 1 个（注意， 也不是10个，下面会解释）；</p></li><li><p>不管是 kill 还是 pthread_kill，信号只能被一个对应的线程所接收；</p></li><li><p>SIGSTOP/SIGCONT 信号只对一个线程起作用；</p></li></ol><p>还好 LinuxThreads 实现了第 5 点，我认为这一点是最重要的。如果某个线程“挂”了，整个进程还在若无其事地运行着，可能会出现很多的不一致状态。进程将不是一个整体，而线程也不能称为线程。</p><p>或许这也是为什么 LinuxThreads 虽然与 POSIX 的要求差距甚远，却能够存在，并且还被使用了好几年的原因吧~</p><p>但是，LinuxThreads 为了实现这个“第 5 点”， 还是付出了很多代价，并且创造了 LinuxThreads 本身的一大性能瓶颈。</p><p>接下来要说说，<code>为什么 A 程序创建了 10 个线程</code>，但是 ps 时却会出现 11 个 A 进程了。 因为 LinuxThreads 自动创建了一个管理线程。上面提到的“第5点”就是靠管理线程来实现的。</p><p>当程序开始运行时, 并没有管理线程存在（因为尽管程序已经链接了 pthread 库, 但是未必会使用多线程）。 程序第一次调用 pthread_create 时，LinuxThreads 发现管理线程不存在，于是创建这个管理线程。这个管理线程是进程中的第一个线程（主线程）的儿子。然后在 pthread_create 中，会通过 pipe 向管理线程发送一个命令，告诉它创建线程。即是说，除主线程外，<code>所有的线程都是由管理线程来创建的，管理线程是它们的父亲</code>。</p><p>于是，当任何一个子线程退出时，管理线程将收到 SIGUSER1 信号（这是在通过 clone 创建子线程时指定的）。管理线程在对应的 sig_handler 中会判断子线程是否正常退出，如果不是，则杀死所有线程，然后自杀。</p><p>那么，主线程怎么办呢? 主线程是管理线程的父亲，其退出时并不会给管理线程发信号。 于是，在管理线程的主循环中通过 getppid 检查父进程的 ID 号，如果 ID 号是 1，说明父亲已经退出，并把自己托管给了 init 进程（1 号进程）。这时候，管理线程也会杀掉所有子线程，然后自杀。</p><p>那么，如果主线程是调用 pthread_exit 主动退出的呢? 按照 posix 的标准，这种情况下其他子线程是应该继续运行的。于是，在 LinuxThreads 中，主线程调用 pthread_exit 以后并不会真正退出，而是会在 pthread_exit 函数中阻塞等待所有子线程都退出了， pthread_exit 才会让主线程退出。（在这个等等过程中，主线程一直处于睡眠状态。）</p><p>可见，线程的创建与销毁都是通过管理线程来完成的，于是管理线程就成了 LinuxThreads 的一个性能瓶颈。<code>线程的创建与销毁需要一次进程间通信，一次上下文切换之后才能被管理线程执行，并且多个请求会被管理线程串行地执行</code>。</p><h1 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h1><p>到了 linux 2.6，glibc 中有了一种新的 pthread 线程库 —— NPTL（Native POSIX Threading Library）。 </p><p>NPTL 实现了前面提到的 POSIX 的全部5点要求：</p><ol><li><p>查看进程列表的时候，相关的一组 task_struct 应当被展现为列表中的一个节点；</p></li><li><p>发送给这个“进程”的信号（对应 kill 系统调用）， 将被对应的这一组 task_struct 所共享，并且被其中的任意一个“线程”处理；</p></li><li><p>发送给某个“线程”的信号（对应 pthread_kill）， 将只被对应的一个task_struct接收，并且由它自己来处理；</p></li><li><p>当“进程”被停止或继续时（对应 SIGSTOP/SIGCONT 信号）， 对应的这一组 task_struct 状态将改变；</p></li><li><p>当“进程”收到一个致命信号（比如由于段错误收到 SIGSEGV 信号）， 对应的这一组 task_struct 将全部退出；</p></li></ol><p>但是，实际上，与其说是 NPTL 实现了，不如说是linux内核实现了。</p><p>在 linux 2.6 中，内核有了线程组的概念，task_struct 结构中增加了一个 tgid（thread group id）字段。 如果这个 task 是一个“主线程”， 则它的 tgid 等于 pid，否则 tgid 等于进程的 pid（即主线程的 pid）。</p><p>在 clone 系统调用中，传递 CLONE_THREAD 参数就可以把新进程的 tgid 设置为父进程的 tgid（否则新进程的 tgid 会设为其自身的 pid）。</p><p>类似的 XXid 在 task_struct 中还有两个：task-&gt;signal-&gt;pgid 保存进程组的打头进程的 pid、task-&gt;signal-&gt;session 保存会话打头进程的 pid 。通过这两个 id 来关联进程组和会话。</p><p>有了 tgid，内核或相关的 shell 程序就知道某个 tast_struct 是代表一个进程还是代表一个线程，也就知道在什么时候该展现它们，什么时候不该展现（比如在 ps 的时候，线程就不要展现了）。而 getpid（获取进程 ID）系统调用返回的也是 tast_struct 中的 tgid，而 tast_struct 中的 pid 则由 gettid 系统调用来返回。</p><p>在执行 ps 命令的时候不展现子线程，也是有一些问题的。比如程序 a.out 运行时，创建了一个线程。假设主线程的 pid 是 10001、子线程是 10002（它们的 tgid 都是10001）。这时如果你 kill 10002，是可以把 10001 和 10002 这两个线程一起杀死的，尽管执行 ps 命令的时候根本看不到 10002 这个进程。如果你不知道 linux 线程背后的故事，肯定会觉得遇到灵异事件了。</p><p>下面我们一起来验证这<code>灵异事件</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">void *fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;thread is created!\n&quot;);</span><br><span class="line">pause(); &#x2F;&#x2F;挂起线程</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">pthread_t tid;</span><br><span class="line">pthread_create(&amp;tid, NULL, fun, NULL);</span><br><span class="line">pause();&#x2F;&#x2F;主线程挂起（否则主线程终止，子线程也就挂了）</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序创建一个线程后挂起，子线程在输出 “thread is created!” 也挂起。运行结果如下图:<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/linuxxmig1.webp"><br>我们打开另外一个终端，查看后台运行的进程，发现 demo 的进程号（pid）是 2361，我们使用 kill 终止 pid 为 2362 的进程（注意 ps 中并没有这个进程），如下图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/linuxxmig2.webp"><br>结果发现，demo 进程也终止了，如下图。其原因就是 2362 就是所创建线程的线程号，线程异常终止了，其对应的进程也就终止了。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/linuxxmig3.webp"><br>为了应付“发送给进程的信号”和“发送给线程的信号”， task_struct 里面维护了两套 signal_pending，<code>一套是线程组共享的，一套是线程独有的</code>。</p><p>通过 kill 发送的信号被放在线程组共享的 signal_pending 中，可以由任意一个线程来处理；通过 pthread_kill 发送的信号（pthread_kill 是 pthread 库的接口，对应的系统调用中 tkill）被放在线程独有的 signal_pending 中， 只能由本线程来处理。</p><p>当线程停止/继续，或者是收到一个致命信号时，内核会将处理动作施加到整个线程组中。</p><h1 id="NGPT"><a href="#NGPT" class="headerlink" title="NGPT"></a>NGPT</h1><p>说到这里，也顺便提一下 NGPT（Next Generation POSIX Threads）。</p><p><code>上面提到的两种线程库使用的都是内核级线程</code>（每个线程都对应内核中的一个调度实体），这种模型称为 1:1 模型（1 个线程对应 1 个内核级线程）；</p><p>而 NGPT 则打算实现 M:N 模型（M 个线程对应 N 个内核级线程），也就是说若干个线程可能是在同一个执行实体上实现的。 线程库需要在一个内核提供的执行实体上抽象出若干个执行实体，并实现它们之间的调度。这样被抽象出来的执行实体称为用户级线程。</p><p>大体上，这可以通过为每个用户级线程分配一个栈，然后通过 longjmp 的方式进行上下文切换。（百度一下”setjmp，longjmp”， 你就知道。）</p><p>但是实际上要处理的细节问题非常之多，目前的 NGPT 好像并没有实现所有预期的功能，并且暂时也不准备去实现。</p><p><code>用户级线程的切换显然要比内核级线程的切换快一些，前者可能只是一个简单的长跳转，而后者则需要保存/装载寄存器，进入然后退出内核态。（进程切换则还需要切换地址空间等）</code></p><p>而用户级线程则不能享受多处理器，因为多个用户级线程对应到一个内核级线程上，一个内核级线程在同一时刻只能运行在一个处理器上。</p><p>不过，M:N 的线程模型毕竟提供了这样一种手段，可以让不需要并行执行的线程运行在一个内核级线程对应的若干个用户级线程上，可以节省它们的切换开销。</p><p>据说一些类 UNIX 系统（如 Solaris）已经实现了比较成熟的 M:N 线程模型，其性能比起 linux 的线程还是有着一定的优势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程和线程的区别与联系&quot;&gt;&lt;a href=&quot;#进程和线程的区别与联系&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别与联系&quot;&gt;&lt;/a&gt;进程和线程的区别与联系&lt;/h1&gt;&lt;p&gt;在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，它并不</summary>
      
    
    
    
    <category term="Linux" scheme="https://matthew84.cf/categories/Linux/"/>
    
    <category term="线程" scheme="https://matthew84.cf/categories/Linux/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://matthew84.cf/tags/Linux/"/>
    
    <category term="线程浅析" scheme="https://matthew84.cf/tags/%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>原码、反码、补码详解</title>
    <link href="https://matthew84.cf/archives/c1974a4.html"/>
    <id>https://matthew84.cf/archives/c1974a4.html</id>
    <published>2020-11-03T12:25:58.000Z</published>
    <updated>2020-11-03T12:40:23.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h1><h2 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h2><p>一个数在计算机中的<strong>二进制表示形式</strong>，叫做这个数的机器数。机器数是<strong>带符号的</strong>，在计算机用一个数的最高位存放符号，正数为 0，负数为 1。</p><p>比如，十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 00000011。如果是 -3 ，就是 10000011。这里的 00000011 和 10000011 就是机器数。</p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位 1 代表负，其真正数值是 -3 而不是形式值 131（10000011 转换成十进制等于 131）。为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><h1 id="原码、反码、补码的基础概念和计算方法"><a href="#原码、反码、补码的基础概念和计算方法" class="headerlink" title="原码、反码、补码的基础概念和计算方法"></a>原码、反码、补码的基础概念和计算方法</h1><p>原码、反码、补码是机器存储一个具体数字的编码方式。</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是 8 位二进制：</p><ul><li><code>[+1]原 = 0000 0001</code></li><li><code>-1]原 = 1000 0001</code></li></ul><p>因为第一位是符号位，所以 8 位二进制数的取值范围就是：<code>[1111 1111 , 0111 1111]</code>，即<code>[-127 , 127]</code>。</p><p>原码是人脑最容易理解和计算的表示方式。</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><ul><li>正数的反码是其本身。</li><li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</li></ul><p>下面是一个例子：</p><ul><li><code>[+1] = [00000001]原 = [00000001]反</code></li><li><code>[-1] = [10000001]原 = [11111110]反</code></li></ul><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><ul><li>正数的补码就是其本身。</li><li>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 + 1。(即在反码的基础上 + 1)</li></ul><p>下面是一个例子：</p><ul><li><code>[+1] = [00000001]原 = [00000001]反 = [00000001]补</code></li><li><code>[-1] = [10000001]原 = [11111110]反 = [11111111]补</code></li></ul><p>对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码再计算其数值。</p><h1 id="原码、反码、补码的由来"><a href="#原码、反码、补码的由来" class="headerlink" title="原码、反码、补码的由来"></a>原码、反码、补码的由来</h1><p>人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别” 符号位” 显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即:<code>1 - 1 = 1 + (-1) = 0</code>。因此，机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><p>原码：</p><table><thead><tr><th>正数</th><th>正数（原码）</th><th>负数</th><th>负数（原码）</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td>0</td><td>1000</td></tr><tr><td>1</td><td>0001</td><td>-1</td><td>1001</td></tr><tr><td>2</td><td>0010</td><td>-2</td><td>1010</td></tr><tr><td>3</td><td>0011</td><td>-3</td><td>1011</td></tr><tr><td>4</td><td>0100</td><td>-4</td><td>1100</td></tr><tr><td>5</td><td>0101</td><td>-5</td><td>1101</td></tr><tr><td>6</td><td>0110</td><td>-6</td><td>1110</td></tr><tr><td>7</td><td>0111</td><td>-7</td><td>1111</td></tr></tbody></table><p>我们希望 + 1 和 - 1 相加是 0，但计算机只能算出<code>0001+1001=1010 (-2)</code>。</p><p>为了解决 “正负相加等于 0” 的问题，在 “原码” 的基础上，人们发明了 “反码”：</p><table><thead><tr><th>正数</th><th>正数（反码）</th><th>负数</th><th>负数（反码）</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td>0</td><td>1111</td></tr><tr><td>1</td><td>0001</td><td>-1</td><td>1110</td></tr><tr><td>2</td><td>0010</td><td>-2</td><td>1101</td></tr><tr><td>3</td><td>0011</td><td>-3</td><td>1100</td></tr><tr><td>4</td><td>0100</td><td>-4</td><td>1011</td></tr><tr><td>5</td><td>0101</td><td>-5</td><td>1010</td></tr><tr><td>6</td><td>0110</td><td>-6</td><td>1001</td></tr><tr><td>7</td><td>0111</td><td>-7</td><td>1000</td></tr></tbody></table><p>“原码” 变成 “反码” 时，完美的解决了 “正负相加等于 0” 的问题，过去的 + 1 和 - 1 相加，变成了<code>0001+1101=1111</code>，刚好反码表示方式中，1111 象征 - 0。</p><p>人们总是进益求精，历史遗留下来的问题 —— 有两个零存在，+0 和 -0。我们希望只有一个 0，所以发明了” 补码”，同样是针对” 负数” 做处理的。从原来” 反码” 的基础上，补充一个新的代码，（+1）。</p><table><thead><tr><th>正数</th><th>正数（补码）</th><th>负数</th><th>负数（补码）</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td><del>0</del></td><td><del>0000</del></td></tr><tr><td>1</td><td>0001</td><td>-1</td><td>1111</td></tr><tr><td>2</td><td>0010</td><td>-2</td><td>1110</td></tr><tr><td>3</td><td>0011</td><td>-3</td><td>1101</td></tr><tr><td>4</td><td>0100</td><td>-4</td><td>1100</td></tr><tr><td>5</td><td>0101</td><td>-5</td><td>1011</td></tr><tr><td>6</td><td>0110</td><td>-6</td><td>1010</td></tr><tr><td>7</td><td>0111</td><td>-7</td><td>1001</td></tr><tr><td></td><td></td><td>-8</td><td>1000</td></tr></tbody></table>有得必有失，在补一位 1 的时候，要丢掉最高位。我们要处理” 反码” 中的”-0”，当 1111 再补上一个 1 之后，变成了 10000，丢掉最高位就是 0000，刚好和左边正数的 0 完美融合。这样就解决了 + 0 和 - 0 同时存在的问题。<p>另外” 正负数相加等于 0” 的问题，同样得到满足，举例，3 和（-3）相加，<code>0011 + 1101 =10000</code>，丢掉最高位，就是 0000（0）。</p><p>以上就是” 补码” 的存在方式。</p>]]></content>
    
    
    <summary type="html">本文简单总结了原码、反码、补码的计算以及由来。</summary>
    
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机原理" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机原理" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>P2P 技术科普</title>
    <link href="https://matthew84.cf/archives/16c5940f.html"/>
    <id>https://matthew84.cf/archives/16c5940f.html</id>
    <published>2020-11-03T11:01:42.000Z</published>
    <updated>2020-11-03T12:28:07.363Z</updated>
    
    <content type="html"><![CDATA[<p><code>迅雷，msn，skype，pplive, ppstream, BT……</code>铺天盖地的 P2P 应用已然一定程度上改变了我们上网的习惯，方式以及质量。如果你想了解 P2P 技术，又懒得找，懒得看那些繁琐，模棱两可又及其抽象的中文资料，这里应该是一个你想来的地方。 我的目的是用<strong>比较俗的语言来对 P2P 技术做一个系统的介绍</strong>。这里，我会尽量避开不必要的术语，只告诉并解释你需要知道的。当然我不是什么专家，不过请你相信我回尽量保证我所提供信息的准确性和严谨性。我们没有任何商业目的，您的每一次点击都将对我国的慈善事业做出一份贡献。在此谨代表站长 kakarott 先生向诸位表示感谢。</p><h1 id="P2P-基本原理"><a href="#P2P-基本原理" class="headerlink" title="P2P 基本原理"></a>P2P 基本原理</h1><p>在 P2P 技术之前，网络中的所有人大多都是通过一种叫做<strong>“客户端 / 服务器”</strong>的模式被组织在一起。<strong>一个服务器向很多客户提供服务</strong>。</p><div class="note simple"><p>举个例子吧： kaka 有一台机子，里面存有全套的央视春晚，他想把他的挚爱分享给所有人。于是不论是通过广告还是别的什么方式，很多人知道了 kaka 有这个资源的消息。通过网络，他们就可以向 kaka 建立连接并从他的机子上下载。这样就形成了一个以 kaka 为中心的小型网络。这当中，kaka 是服务器，其他人都是客户端。如图一：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p1.webp"></p></div><p>这样的模式中，对服务器的性能及相应带宽要求比较高，如果有成千上万的人都想下春晚，kaka 的海淀在线肯定就操蛋了。当然一般的公司不会用一个家用电脑做服务器。假设有存在一个特别强大的服务器，以及足够的带宽。我们来看看这种模式天生的一些弱点：</p><ol><li>服务器扮演的角色太重了，网络的一切都指着他。假如 kaka 不小心把电脑从 6 楼扔下去，<strong>整个网络就都瘫痪了</strong>。请注意，想要把一个服务器弄失灵的方法太多了，所以使用这中模式的风险是比较大的。</li><li>网络的资源利用率低下。所有客户都只能从服务器那获得资源，因为他们之间不认识，甚至不知道相互的存在。然而，现实中，可能每个人都有自己独门的资源，比如日天有无数游戏，威哥有无数动漫电影……. 总之，整个网络的资源可能是服务器的无数倍。但是苦无客户端之间没有交流的渠道，所以<strong>资源无法互通</strong>。</li><li>关于完美服务器的假设，基本不成立。</li></ol><p>P2P 技术就是要解决上述的问题已达到如下的效果： 所有人的资源都可以被别人找到并使用。没有哪个人特别重要，<strong>人人平等（peer-to-peer 就是这个意思）</strong>，任何一个人失灵都不会导致网络的死亡。</p><p>这里以 Gnutella 为例，对 P2P 基本原理进行介绍。 Gnutella 是一种典型的 P2P 网络，很具代表性，以其为基础的软件有 Limewire。这种网络里，没有服务器。用户之间任意连接，如图二左所示：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p2.webp"></p><p>Kaka 认识 ‘日天’‘curt’‘威’， 日天认识‘小胖’，威认识‘候泡’，Curt 认识 ‘路’。当然真正的网络有至少有成百上千个用户，这里只是展示一个小的局部。</p><p>这个网络如何工作呢？比如 kaka 想要找一首叫‘走进新时代’的歌。一个基本交易要经过如下几步：</p><ol><li>kaka 给他的邻居们每人发一个请求消息，‘你们丫谁有走进新时代？’</li><li>日天，威，curt 吐血，‘谁 tm 听这歌啊，我没有’。于是把 kaka 的消息转发给他们的邻居：日天发给小胖，威发给候泡，curt 发给路总。</li><li>当 kaka 邻居的邻居们收到这个消息后，同样，先看看自己有没有。比如，候泡有这个歌，他就可以给 kaka 发个消息：‘爷这有，来下吧’</li><li>卡卡于是可以直接去候泡那下载。</li></ol><p>很多人说在 p2p 里面，<strong>所有人即是服务器又是客户端</strong>。应该这样理解，比如，kaka 在上例中就是个客户端。 但当有人要想要春晚的时候，只要那人的请求消息能被转到 kaka 这，kaka 就可以成为一个服务器。</p><p>最后要说的是 P2P 的现状以及应用。目前 P2P 与传统的‘客户端 / 服务器’模式可以说分庭抗礼，互为补充。那么为什么没能取而代之呢？因为，P2P 也有自身的弱点，其中包括：</p><ol><li>占带宽（50% 以上的网络带宽都是 P2P 占用的，搜索方法不灵）</li><li>安全（不具体解释了，太专业了，总之和加密那些东西有关）</li><li>诚信（没有中央控制，你传个毛片也可以告诉你是新闻联播）</li><li>自私（我什么都不付出，有也说没有）</li><li>知识产权保护（在中国相当于盗版的集散地）等等。 至于这些问题的对策以及其不足，以后会做专题介绍。</li></ol><p>P2P 的应用不少但大都停留在比较低端的服务，比如文件共享，msn，在线视频这一类。实际上作为一种新的模式，其生命力应该不止如此。</p><h1 id="非结构化-P2P-及其搜索方法"><a href="#非结构化-P2P-及其搜索方法" class="headerlink" title="非结构化 P2P 及其搜索方法"></a>非结构化 P2P 及其搜索方法</h1><p>上集回顾，传统的‘客户端 / 服务器’模式有一些问题，比如，单一故障点，低资源利用率，高带宽要求。我说 P2P 客服了这些问题，因为没有中央服务器了。这里，我要强调一下，并不是说只要有中央的东西就是失败，只要这个中央的东西不是那个实际掌握资源的人就可以接受。下面，简要介绍一下 P2P 技术的发展。</p><h2 id="第一代、Napster"><a href="#第一代、Napster" class="headerlink" title="第一代、Napster"></a>第一代、Napster</h2><p>这一代的 p2p 只是<strong>把资源从服务器上拿掉了</strong>。中央服务器上只有一个目录。这个目录记录着哪个用户有哪些资源。要建立这样的一个目录，要求网络中的每个人都要告诉这个服务器：他有什么资源。</p><ol><li>Kaka 发一个资源请求向中央服务器。</li><li>这个服务器然后检索目录，并告诉 Kaka，日天有他要的东西。</li><li>Kaka 直接去找日天下东西。</li></ol><p>这样做，解决了高带宽需求（服务器只需要转发一些消息，而不用真格的提供资源），低资源利用率的问题（网络里谁都可以发挥作用了）。但是，他仍然面临严重的‘单一故障点’风险。同时，napster 的出现严重挑战了知识产权法，并最终导致其在 2001 年被勒令关闭。</p><h2 id="第二代、非结构化-P2P"><a href="#第二代、非结构化-P2P" class="headerlink" title="第二代、非结构化 P2P"></a>第二代、非结构化 P2P</h2><p>Napster 帝国的坍塌，导致了江湖上群雄并起，老的规矩也就法不责众了，其中 Gnutella 等非结构的 P2P 脱颖而出。非结构化说白了就是，用户之间瞎连，没有规定谁必须和谁有连接，基本随机。其基本搜索方法是地毯式的，如果这样的搜索能够遍及整个网络。那么，只要资源存在就一定能一网打尽。</p><p>但是上天要求每一个用户都要给自己资源请求加一个限制，于是每个资源请求都只能走几步就必须停了，即使什么都还没找到。因为地毯式的搜索要消耗大量的网络资源，比如，平均一个人有 4 个邻居，如果资源请求的限制为 5. 那么一共需要 4+42+43+44+45=<strong>1364</strong>个信息，每个信息多大呢？大概几 k 到几十 k，也就是说一个信息就<strong>至少几m</strong>。一个人一个信息就这么大了，想想一个大网络，每人十几个邻居，限制提高到 7 或 8. 这就是为什么中国很多地方，尤其是网吧限制 p2p. 因为他们可怜的带宽都被 p2p 的请求信息占用了。</p><p>当然，p2p 的设计者们都看到了问题，于是提出了很多<strong>新的搜索方法</strong>。这些方法可以分成两种：<strong>根据以前的搜索信息对以后的搜索进行预测；瞎找，碰运气</strong>。</p><ol><li>根据经验的搜索准确率可能会高一点，但是这种方法要求每个用户都要建一些表来记录以前的数据，而且每次发送或接到请求都要经过一系列的计算才能决定发给哪个邻居。而且程序上难以实现，更重要的是平均准确率并不比瞎找好很多。这里就不多做介绍了。</li><li>瞎 B 找的，还基本上以地毯式为基础。我介绍两种最常见的：<ul><li><strong>K-walkers</strong>: 第一个人先把消息发给 k 个邻居，具体多少都自己定。 然后从第一轮邻居开始都只把消息转发给他们的一个邻居。</li><li><strong>水纹式（涟漪式）</strong>：先定一个限制。第一个人先发给第一层的邻居。如果第一层不灵，他们再发给他们的邻居。一旦找到资源就不再继续了。这样的话最坏的情况就是原始的地毯式。好点的情况就是，消息没到限制就找到了相应的资源，就停了。</li></ul></li></ol><p>这种非结构的 p2p 的优点在于，操作简单，完全不需要中央控制，所以又称为‘存（纯）p2p’。其缺点同样明显，要么牺牲搜索成功率，要么牺牲带宽占有量。</p><p>于是又有人提出了<strong>结构化的P2P</strong>。数学的东西我就不说了，基本的思想就是：</p><ol><li>每个用户，资源都得有个名字。</li><li>有一种数学加密方法，对这些名字加密。且保证如果名字不同，那么得到的结果就不同。</li><li>如一资源和一用户加密后结果接近，就把该资源的地址放到相应的用户身上。</li></ol><div class="note simple"><p>举个例子：</p><p>有三个人，日天，kaka，威哥。三个资源：“一剪梅.mp3”,“八荣八耻歌歌词.txt”,“xxx.avi”，对这六个东西加密后分别得到： 100，200，3000， 3002， 233，98，‘xxx.avi’的下载地址就会被分配到‘日天’的机子上，于是当你想搜索 “xxx.avi”，你的消息就会通过某种方法被传到到日天那。</p></div><p>这样，结构化的 P2P 就可以保证，只要网络里有相应的资源，就一定能找到。但是由于其程序实现的难度，加之维护网络所需的投入太大，并不被经常使用。尽管他有很漂亮的数据。</p><p>当然还有第三代的，以后再做专题。</p><h1 id="BT-工作原理简介"><a href="#BT-工作原理简介" class="headerlink" title="BT 工作原理简介"></a>BT 工作原理简介</h1><p>2002年左右，程小胖告诉我有一种软件可以下片，人越多越快。很神奇。请注意，并不是所有的 P2P 技术都能做到这点，其他的 P2P 基本上只是<strong>提高网络资源的利用率，但是，网络中的每一单买卖都仍然采用，1 对 1 的客户端服务器模式</strong>。回顾一下之前讲过的 P2P，去掉技术细节，做一单买卖可以这样描述：</p><ol><li>有人向网络发一个资源请求（请求者）。有很多种搜索方法可供选择。</li><li>当一个有该的资源的人（提供者）收到这个的请求，他会设法通知请求者：他那有其想要的东西。</li><li>于是请求者去找提供者下载。</li></ol><p>这样做的一个<strong>缺点</strong>就是，比如，我选择了一个比较矬的提供者，而那人的带宽只有 30k，然而网络中还有很多潜在提供者，可能有的人能达到 30m。但是由于我在选择时只无法对对方的带宽做出判断而无福消受。</p><p>这样做还有一个致命的漏洞！比如，我收到一个关于 “海贼王” 的请求，而且我有全套。按理说我应该通知请求者，让他来我这下。但是，让他来我这里下东西，对我来说，除了占我带宽，增加我中毒的风险，没有任何的好处。那我凭什么主动邀请他来？？我何不装 ytd，对该请求视而不见？非常不幸的是，跟我有相同想法的孙子在一般 p2p 网络里面占了大多数，甚至绝大多数。这就是搭便车问题（free riding）。所幸还是有一些大侠的，无偿的提供着大量资源，他们的存在使得那些一般的 P2P 得以侥幸存活。</p><p>其实，如果仅仅依赖活雷锋们，P2P 就失去了其人人平等的意义。大侠们回复了网络中绝大多数的请求，于是人人都愿意与这些人建立连接，因为这样能更快的找到资源。于是这些大侠们就成了变得越来越红，网络的拓扑结构（我装 b 了，这个词没法解释，但是我实在找不出别的词了，别在意，看下图。）将会发生变化。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p3.webp"></p><p><strong>这样的变化很不好，因为 P2P 又逐渐变成了客户端 / 服务器模式了</strong>。</p><p>于是，不论是学术界还是产业界都意识到，如果没有一种鼓励机制来刺激提供者，P2P 将失去其天生的魅力。在众多解决方案中 BT 脱颖而出，迅速发展了起来。BT 是简称，在国外可能会产生歧义，如 British Telecommunications 等等。所以大家尽量还是用全称，尤其是和外国人说的时候 Bit-Torrent。有人说 BT 是第三代的 P2P，我认为这是因为他把 P2P 的理念更加深入的实现了。</p><p>在 BitTorrent 当中，所有的资源都被切成很小的等份（碎片）。这里，你不需要知道怎么切，只需要知道有一种技术可以把一个文件切成很多小等份，还能把这些等份再重新的组装。在这个技术的支持下，bittorrent 中所有有相同请求的用户可以相互传资源的碎片。而且谁传的多，谁就将获得更多。具体技术如下：</p><ul><li><p>首先，有同样资源请求的人怎么能相互认识呢？bittorrent 中每一个资源都对应有一个叫<strong>tracker</strong>的服务器。只要你对一个资源有意思，你就必须先联系这个资源相应的 tracker。或者你想要共享一个资源你也必须联系 tracker。这样的话，tracker 就掌握着整个网络中<strong>谁想要这个资源</strong>以及<strong>谁有这个资源</strong>。当然，为了节约，一个 tracker 可以负责多种资源。</p></li><li><p>那么，怎么找到 tracker 呢？大家可能听说过做种子，每个有完整资源的人都可以做种子，其实就是生成一个后缀是.torrent 的文件。每一款 bittorrent 应用软件都会自动帮你生成，所以不用担心。你只要知道这个文件中包括两部分内容：<code>1，tracker的地址。2，相关资源的一些属性，比如大小，名字等等</code>。这个 torrent 文件一般都可以发布在网上，比如某某人的博客，或者论坛上。</p></li><li><p>于是，大家可以从网上找到 torrent 文件，并从中知道 tracker 在哪。再通过联系 tracker 得到一个<strong>名单</strong>，其中包括一部分正在下载或有完整资源的用户。这时候，你就可以与这些人建立链接，并分别从他们身上要不同的碎片。当然要相同资源的人越多，你可以建立连接的人就越多，也就更可能早日得到所有碎片。</p></li><li><p>还有一点很重要就是，bittorrent 有自己的<strong>鼓励机制</strong>，就是说，你做的贡献大就会被鼓励，你不做贡献就会被惩罚。具体的操作是，每个人在下载的同时也上传。上传给谁呢？谁给我给的多，我就传给谁。而且我只传个前 4 名的（视具体软件具体分析，也可能是前 8 名或其他）。</p></li></ul><div class="note simple"><p>举个例子，比如 kaka 下载‘春晚’，先从某春晚发烧友论坛下载了一个叫<code>“春晚全集.torrent”</code>的文件。kaka 可以联系文件中的 tracker，并得知‘程胖，日天，威，候泡，鸣’有想关资源。于是 kaka 分别与这五个人建立连接。通过检测链接的流量，kaka 可知，比如从程胖那下载速度可达 200k/s, 日天 100k/s, 威 150k/s, 候泡 70k/s, 鸣 2k/s。于是 kaka 在上传的时候就不给鸣上传，而只给前 4 名传。由于鸣的上传只有 2k/s，所以不太可能有人给他传，所以时间一长他可能会意识到，可能自己给的太少了，于是把上传带宽增加到了 500k/s。kaka 突然意识到，从鸣那里可以得到很好的速度，于是停止给候泡（70k/s）传转而给鸣传。（总给那些速度最好的人上传是为了能留住他们，当然，只有你传的足够多才能留得住人家）。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p4.webp"></p></div><p>bittorrent 大概的工作原理就是这样了，还有些细节这里不多说了。我个人认为 Bittorrent 的设计还是很不错的，但是其只适用于文件共享，或视频共享。然而网络中的资源又何止电影音乐？？绝大多数的资源是不可分的，bittorrent 的局限性还是相当大！ 另一点可悲的是，大多数宽带用户是 ADSL，也就是说他们的下载上传的带宽上限差别很大，比如，下载最大 2m/s，上传却只有 100k/s。这也限制了 bittorrent 的发挥。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;迅雷，msn，skype，pplive, ppstream, BT……&lt;/code&gt;铺天盖地的 P2P 应用已然一定程度上改变了我们上网的习惯，方式以及质量。如果你想了解 P2P 技术，又懒得找，懒得看那些繁琐，模棱两可又及其抽象的中文资料，这里应该是一个你想来</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="网络" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="网络" scheme="https://matthew84.cf/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="P2P" scheme="https://matthew84.cf/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫 -（二）总体实现</title>
    <link href="https://matthew84.cf/archives/4da64f30.html"/>
    <id>https://matthew84.cf/archives/4da64f30.html</id>
    <published>2020-11-03T11:00:57.000Z</published>
    <updated>2020-11-03T11:58:00.947Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第二篇，详细分析了爬取全过程。</p><p>详细的代码开源在 GitHub 上：<a href="https://github.com/dta0502/NBSPRC-spider">NBSPRC-spider</a>。</p><h1 id="总体思路说明"><a href="#总体思路说明" class="headerlink" title="总体思路说明"></a>总体思路说明</h1><p>首先我定义了一个网页爬取函数，然后依次定义省级代码获取函数、市级代码获取函数、区级代码获取函数、街道代码获取函数、居委会代码获取函数，这些函数都会调用网页爬取函数。其中区级代码获取函数、街道代码获取函数、居委会代码获取函数这三个函数都是多线程实现爬取的。最后我将爬取得到的数据输出为 csv 格式文件。</p><h2 id="库函数导入"><a href="#库函数导入" class="headerlink" title="库函数导入"></a>库函数导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line">import csv</span><br><span class="line">import time</span><br><span class="line">import pandas as pd</span><br><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line">from fake_useragent import UserAgent</span><br></pre></td></tr></table></figure><h2 id="网页爬取函数"><a href="#网页爬取函数" class="headerlink" title="网页爬取函数"></a>网页爬取函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 下面加入了num_retries这个参数，经过测试网络正常一般最多retry一次就能获得结果</span><br><span class="line">def getUrl(url,num_retries &#x3D; 5):</span><br><span class="line">    ua &#x3D; UserAgent()</span><br><span class="line">    headers &#x3D; &#123;&#39;User-Agent&#39;:ua.random&#125;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.get(url,headers &#x3D; headers)</span><br><span class="line">        response.encoding &#x3D; response.apparent_encoding</span><br><span class="line">        data &#x3D; response.text</span><br><span class="line">        return data</span><br><span class="line">    except Exception as e:</span><br><span class="line">        if num_retries &gt; 0:</span><br><span class="line">            time.sleep(10)</span><br><span class="line">            print(url)</span><br><span class="line">            print(&quot;requests fail, retry!&quot;)</span><br><span class="line">            return getUrl(url,num_retries-1) #递归调用</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;retry fail!&quot;)</span><br><span class="line">            print(&quot;error: %s&quot; % e + &quot; &quot; + url)</span><br><span class="line">            return #返回空值，程序运行报错</span><br></pre></td></tr></table></figure><h2 id="获取省级代码函数"><a href="#获取省级代码函数" class="headerlink" title="获取省级代码函数"></a>获取省级代码函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def getProvince(url):</span><br><span class="line">    province &#x3D; []</span><br><span class="line">    data &#x3D; getUrl(url)</span><br><span class="line">    selector &#x3D; etree.HTML(data)</span><br><span class="line">    provinceList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;provincetr&quot;]&#39;)</span><br><span class="line">    for i in provinceList:</span><br><span class="line">        provinceName &#x3D; i.xpath(&#39;td&#x2F;a&#x2F;text()&#39;) #这里如果采用&#x2F;&#x2F;a&#x2F;text()路径会出现问题！！</span><br><span class="line">        provinceLink &#x3D; i.xpath(&#39;td&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">        for j in range(len(provinceLink)):</span><br><span class="line">            provinceURL &#x3D; url[:-10] + provinceLink[j] #根据获取到的每个省的链接进行补全，得到真实的URL。</span><br><span class="line">            province.append(&#123;&#39;name&#39;:provinceName[j],&#39;link&#39;:provinceURL&#125;)</span><br><span class="line">    return province</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pro &#x3D; getProvince(&quot;http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;index.html&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_province &#x3D; pd.DataFrame(pro)</span><br><span class="line">df_province[&#39;link&#39;]</span><br></pre></td></tr></table></figure><pre><code>0     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...1     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...2     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...3     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...   4     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...5     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...6     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...7     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...8     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...9     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...10    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...11    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...12    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...13    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...14    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...15    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...16    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...17    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...18    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...19    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...20    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...21    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...22    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...23    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...24    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...25    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...26    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...27    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...28    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...29    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...30    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...Name: link, dtype: object</code></pre><h2 id="信息写入-csv-文件"><a href="#信息写入-csv-文件" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_province.to_csv(&#39;province.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取市级代码函数"><a href="#获取市级代码函数" class="headerlink" title="获取市级代码函数"></a>获取市级代码函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def getCity(url_list):</span><br><span class="line">    city_all &#x3D; []</span><br><span class="line">    for url in url_list:</span><br><span class="line">        data &#x3D; getUrl(url)</span><br><span class="line">        selector &#x3D; etree.HTML(data)</span><br><span class="line">        cityList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;citytr&quot;]&#39;)</span><br><span class="line">        #下面是抓取每一个城市的代码、URL</span><br><span class="line">        city &#x3D; []</span><br><span class="line">        for i in cityList:</span><br><span class="line">            cityCode &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">            cityLink &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">            cityName &#x3D; i.xpath(&#39;td[2]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">            for j in range(len(cityLink)):</span><br><span class="line">                cityURL &#x3D; url[:-7] + cityLink[j]</span><br><span class="line">                city.append(&#123;&#39;name&#39;:cityName[j],&#39;code&#39;:cityCode[j],&#39;link&#39;:cityURL&#125;)</span><br><span class="line">        city_all.extend(city) #所有省的城市信息合并在一起</span><br><span class="line">    return city_all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">city &#x3D; getCity(df_province[&#39;link&#39;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_city &#x3D; pd.DataFrame(city)</span><br><span class="line">df_city</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th><center>code</center></th>      <th><center>link</center></th>      <th><center>name</center></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>110100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 市辖区</td>    </tr>    <tr>      <th> 1</th>      <td>120100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 市辖区</td>    </tr>    <tr>      <th> 2</th>      <td>130100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 石家庄市</td>    </tr>    <tr>      <th> 3</th>      <td>130200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 唐山市</td>    </tr>    <tr>      <th> 4</th>      <td>130300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 秦皇岛市</td>    </tr>    <tr>      <th> 5</th>      <td>130400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 邯郸市</td>    </tr>    <tr>      <th> 6</th>      <td>130500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 邢台市</td>    </tr>    <tr>      <th> 7</th>      <td>130600000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 保定市</td>    </tr>    <tr>      <th> 8</th>      <td>130700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 张家口市</td>    </tr>    <tr>      <th> 9</th>      <td>130800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 承德市</td>    </tr>    <tr>      <th> 10</th>      <td>130900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沧州市</td>    </tr>    <tr>      <th> 11</th>      <td>131000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 廊坊市</td>    </tr>    <tr>      <th> 12</th>      <td>131100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 衡水市</td>    </tr>    <tr>      <th> 13</th>      <td>139000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 省直辖县级行政区划</td>    </tr>    <tr>      <th> 14</th>      <td>140100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 太原市</td>    </tr>    <tr>      <th> 15</th>      <td>140200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 大同市</td>    </tr>    <tr>      <th> 16</th>      <td>140300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阳泉市</td>    </tr>    <tr>      <th> 17</th>      <td>140400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 长治市</td>    </tr>    <tr>      <th> 18</th>      <td>140500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 晋城市</td>    </tr>    <tr>      <th> 19</th>      <td>140600000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 朔州市</td>    </tr>    <tr>      <th> 20</th>      <td>140700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 晋中市</td>    </tr>    <tr>      <th> 21</th>      <td>140800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 运城市</td>    </tr>    <tr>      <th> 22</th>      <td>140900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 忻州市</td>    </tr>    <tr>      <th> 23</th>      <td>141000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 临汾市</td>    </tr>    <tr>      <th> 24</th>      <td>141100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吕梁市</td>    </tr>    <tr>      <th> 25</th>      <td>150100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 呼和浩特市</td>    </tr>    <tr>      <th> 26</th>      <td>150200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 包头市</td>    </tr>    <tr>      <th> 27</th>      <td>150300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌海市</td>    </tr>    <tr>      <th> 28</th>      <td>150400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 赤峰市</td>    </tr>    <tr>      <th> 29</th>      <td>150500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 通辽市</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>314</th>      <td>622900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 临夏回族自治州</td>    </tr>    <tr>      <th> 315</th>      <td>623000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 甘南藏族自治州</td>    </tr>    <tr>      <th> 316</th>      <td>630100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 西宁市</td>    </tr>    <tr>      <th> 317</th>      <td>630200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海东市</td>    </tr>    <tr>      <th> 318</th>      <td>632200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海北藏族自治州</td>    </tr>    <tr>      <th> 319</th>      <td>632300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 黄南藏族自治州</td>    </tr>    <tr>      <th> 320</th>      <td>632500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海南藏族自治州</td>    </tr>    <tr>      <th> 321</th>      <td>632600000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 果洛藏族自治州</td>    </tr>    <tr>      <th> 322</th>      <td>632700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 玉树藏族自治州</td>    </tr>    <tr>      <th> 323</th>      <td>632800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海西蒙古族藏族自治州</td>    </tr>    <tr>      <th> 324</th>      <td>640100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 银川市</td>    </tr>    <tr>      <th> 325</th>      <td>640200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 石嘴山市</td>    </tr>    <tr>      <th> 326</th>      <td>640300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吴忠市</td>    </tr>    <tr>      <th> 327</th>      <td>640400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 固原市</td>    </tr>    <tr>      <th> 328</th>      <td>640500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 中卫市</td>    </tr>    <tr>      <th> 329</th>      <td>650100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌鲁木齐市</td>    </tr>    <tr>      <th> 330</th>      <td>650200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 克拉玛依市</td>    </tr>    <tr>      <th> 331</th>      <td>650400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吐鲁番市</td>    </tr>    <tr>      <th> 332</th>      <td>650500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 哈密市</td>    </tr>    <tr>      <th> 333</th>      <td>652300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 昌吉回族自治州</td>    </tr>    <tr>      <th> 334</th>      <td>652700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 博尔塔拉蒙古自治州</td>    </tr>    <tr>      <th> 335</th>      <td>652800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 巴音郭楞蒙古自治州</td>    </tr>    <tr>      <th> 336</th>      <td>652900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿克苏地区</td>    </tr>    <tr>      <th> 337</th>      <td>653000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 克孜勒苏柯尔克孜自治州</td>    </tr>    <tr>      <th> 338</th>      <td>653100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 喀什地区</td>    </tr>    <tr>      <th> 339</th>      <td>653200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 和田地区</td>    </tr>    <tr>      <th> 340</th>      <td>654000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 伊犁哈萨克自治州</td>    </tr>    <tr>      <th> 341</th>      <td>654200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 塔城地区</td>    </tr>    <tr>      <th> 342</th>      <td>654300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿勒泰地区</td>    </tr>    <tr>      <th> 343</th>      <td>659000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 自治区直辖县级行政区划</td>    </tr>  </tbody></table><h2 id="信息写入-csv-文件-1"><a href="#信息写入-csv-文件-1" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_city.to_csv(&#39;city.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取区级代码函数-—-多线程实现"><a href="#获取区级代码函数-—-多线程实现" class="headerlink" title="获取区级代码函数 — 多线程实现"></a>获取区级代码函数 — 多线程实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def getCounty(url_list):</span><br><span class="line">    queue_county &#x3D; Queue() #队列</span><br><span class="line">    thread_num &#x3D; 10 #进程数</span><br><span class="line">    county &#x3D; [] #记录区级信息的字典（全局）</span><br><span class="line">    </span><br><span class="line">    def produce_url(url_list):</span><br><span class="line">        for url in url_list:</span><br><span class="line">            queue_county.put(url) # 生成URL存入队列，等待其他线程提取</span><br><span class="line">    </span><br><span class="line">    def getData():</span><br><span class="line">        while not queue_county.empty(): # 保证url遍历结束后能退出线程</span><br><span class="line">            url &#x3D; queue_county.get() # 从队列中获取URL</span><br><span class="line">            data &#x3D; getUrl(url)</span><br><span class="line">            selector &#x3D; etree.HTML(data)</span><br><span class="line">            countyList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;countytr&quot;]&#39;)</span><br><span class="line">            #下面是爬取每个区的代码、URL</span><br><span class="line">            for i in countyList:</span><br><span class="line">                countyCode &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                countyLink &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">                countyName &#x3D; i.xpath(&#39;td[2]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                #上面得到的是列表形式的，下面将其每一个用字典存储</span><br><span class="line">                for j in range(len(countyLink)):</span><br><span class="line">                    countyURL &#x3D; url[:-9] + countyLink[j]</span><br><span class="line">                    county.append(&#123;&#39;code&#39;:countyCode[j],&#39;link&#39;:countyURL,&#39;name&#39;:countyName[j]&#125;)</span><br><span class="line">                </span><br><span class="line">    def run(url_list):</span><br><span class="line">        produce_url(url_list)</span><br><span class="line">    </span><br><span class="line">        ths &#x3D; []</span><br><span class="line">        for _ in range(thread_num):</span><br><span class="line">            th &#x3D; Thread(target &#x3D; getData)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        for th in ths:</span><br><span class="line">            th.join()</span><br><span class="line">            </span><br><span class="line">    run(url_list)</span><br><span class="line">    return county</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">county &#x3D; getCounty(df_city[&#39;link&#39;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_county &#x3D; pd.DataFrame(county)</span><br><span class="line">df_county</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>code</th>      <th>link</th>      <th>name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>130702000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 桥东区</td>    </tr>    <tr>      <th> 1</th>      <td>130703000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 桥西区</td>    </tr>    <tr>      <th> 2</th>      <td>130705000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 宣化区</td>    </tr>    <tr>      <th> 3</th>      <td>130706000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 下花园区</td>    </tr>    <tr>      <th> 4</th>      <td>130708000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 万全区</td>    </tr>    <tr>      <th> 5</th>      <td>130709000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 崇礼区</td>    </tr>    <tr>      <th> 6</th>      <td>130722000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 张北县</td>    </tr>    <tr>      <th> 7</th>      <td>130723000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 康保县</td>    </tr>    <tr>      <th> 8</th>      <td>130724000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沽源县</td>    </tr>    <tr>      <th> 9</th>      <td>130725000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 尚义县</td>    </tr>    <tr>      <th> 10</th>      <td>130726000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 蔚县</td>    </tr>    <tr>      <th> 11</th>      <td>130727000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阳原县</td>    </tr>    <tr>      <th> 12</th>      <td>130602000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 竞秀区</td>    </tr>    <tr>      <th> 13</th>      <td>130606000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 莲池区</td>    </tr>    <tr>      <th> 14</th>      <td>130607000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 满城区</td>    </tr>    <tr>      <th> 15</th>      <td>130608000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 清苑区</td>    </tr>    <tr>      <th> 16</th>      <td>130609000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 徐水区</td>    </tr>    <tr>      <th> 17</th>      <td>130623000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 涞水县</td>    </tr>    <tr>      <th> 18</th>      <td>130624000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阜平县</td>    </tr>    <tr>      <th> 19</th>      <td>130626000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 定兴县</td>    </tr>    <tr>      <th> 20</th>      <td>130627000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 唐县</td>    </tr>    <tr>      <th> 21</th>      <td>130628000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 高阳县</td>    </tr>    <tr>      <th> 22</th>      <td>130629000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 容城县</td>    </tr>    <tr>      <th> 23</th>      <td>130630000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 涞源县</td>    </tr>    <tr>      <th> 24</th>      <td>130631000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 望都县</td>    </tr>    <tr>      <th> 25</th>      <td>130632000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 安新县</td>    </tr>    <tr>      <th> 26</th>      <td>130633000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 易县</td>    </tr>    <tr>      <th> 27</th>      <td>130634000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 曲阳县</td>    </tr>    <tr>      <th> 28</th>      <td>130635000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 蠡县</td>    </tr>    <tr>      <th> 29</th>      <td>130636000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 顺平县</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>2822</th>      <td>653128000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 岳普湖县</td>    </tr>    <tr>      <th> 2823</th>      <td>653129000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 伽师县</td>    </tr>    <tr>      <th> 2824</th>      <td>654221000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 额敏县</td>    </tr>    <tr>      <th> 2825</th>      <td>652901000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿克苏市</td>    </tr>    <tr>      <th> 2826</th>      <td>654223000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沙湾县</td>    </tr>    <tr>      <th> 2827</th>      <td>652922000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 温宿县</td>    </tr>    <tr>      <th> 2828</th>      <td>653130000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 巴楚县</td>    </tr>    <tr>      <th> 2829</th>      <td>654224000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 托里县</td>    </tr>    <tr>      <th> 2830</th>      <td>652923000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 库车县</td>    </tr>    <tr>      <th> 2831</th>      <td>654225000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 裕民县</td>    </tr>    <tr>      <th> 2832</th>      <td>653131000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 塔什库尔干塔吉克自治县</td>    </tr>    <tr>      <th> 2833</th>      <td>654226000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 和布克赛尔蒙古自治县</td>    </tr>    <tr>      <th> 2834</th>      <td>652924000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沙雅县</td>    </tr>    <tr>      <th> 2835</th>      <td>652925000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 新和县</td>    </tr>    <tr>      <th> 2836</th>      <td>652926000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 拜城县</td>    </tr>    <tr>      <th> 2837</th>      <td>652927000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌什县</td>    </tr>    <tr>      <th> 2838</th>      <td>652928000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿瓦提县</td>    </tr>    <tr>      <th> 2839</th>      <td>652929000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 柯坪县</td>    </tr>    <tr>      <th> 2840</th>      <td>659001000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 石河子市</td>    </tr>    <tr>      <th> 2841</th>      <td>659002000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿拉尔市</td>    </tr>    <tr>      <th> 2842</th>      <td>659003000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 图木舒克市</td>    </tr>    <tr>      <th> 2843</th>      <td>659004000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 五家渠市</td>    </tr>    <tr>      <th> 2844</th>      <td>659006000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 铁门关市</td>    </tr>    <tr>      <th> 2845</th>      <td>654301000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿勒泰市</td>    </tr>    <tr>      <th> 2846</th>      <td>654321000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 布尔津县</td>    </tr>    <tr>      <th> 2847</th>      <td>654322000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 富蕴县</td>    </tr>    <tr>      <th> 2848</th>      <td>654323000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 福海县</td>    </tr>    <tr>      <th> 2849</th>      <td>654324000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 哈巴河县</td>    </tr>    <tr>      <th> 2850</th>      <td>654325000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 青河县</td>    </tr>    <tr>      <th> 2851</th>      <td>654326000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吉木乃县</td>    </tr>  </tbody></table><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照区代码进行 “升序” 排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_county_sorted &#x3D; df_county.sort_values(by &#x3D; [&#39;code&#39;]) #按1列进行升序排序</span><br></pre></td></tr></table></figure><h2 id="信息写入-csv-文件-2"><a href="#信息写入-csv-文件-2" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_county_sorted.to_csv(&#39;county.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取街道代码函数-—-多线程实现"><a href="#获取街道代码函数-—-多线程实现" class="headerlink" title="获取街道代码函数 — 多线程实现"></a>获取街道代码函数 — 多线程实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def getTown(url_list):</span><br><span class="line">    queue_town &#x3D; Queue() #队列</span><br><span class="line">    thread_num &#x3D; 50 #进程数</span><br><span class="line">    town &#x3D; [] #记录街道信息的字典（全局）</span><br><span class="line">    </span><br><span class="line">    def produce_url(url_list):</span><br><span class="line">        for url in url_list:</span><br><span class="line">            queue_town.put(url) # 生成URL存入队列，等待其他线程提取</span><br><span class="line">    </span><br><span class="line">    def getData():</span><br><span class="line">        while not queue_town.empty(): # 保证url遍历结束后能退出线程</span><br><span class="line">            url &#x3D; queue_town.get() # 从队列中获取URL</span><br><span class="line">            data &#x3D; getUrl(url)</span><br><span class="line">            selector &#x3D; etree.HTML(data)</span><br><span class="line">            townList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;towntr&quot;]&#39;)</span><br><span class="line">            #下面是爬取每个区的代码、URL</span><br><span class="line">            for i in townList:</span><br><span class="line">                townCode &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                townLink &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">                townName &#x3D; i.xpath(&#39;td[2]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                #上面得到的是列表形式的，下面将其每一个用字典存储</span><br><span class="line">                for j in range(len(townLink)):</span><br><span class="line">                    townURL &#x3D; url[:-11] + townLink[j]</span><br><span class="line">                    town.append(&#123;&#39;code&#39;:townCode[j],&#39;link&#39;:townURL,&#39;name&#39;:townName[j]&#125;)</span><br><span class="line">                </span><br><span class="line">    def run(url_list):</span><br><span class="line">        produce_url(url_list)</span><br><span class="line">    </span><br><span class="line">        ths &#x3D; []</span><br><span class="line">        for _ in range(thread_num):</span><br><span class="line">            th &#x3D; Thread(target &#x3D; getData)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        for th in ths:</span><br><span class="line">            th.join()</span><br><span class="line">            </span><br><span class="line">    run(url_list)</span><br><span class="line">    return town</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">town &#x3D; getTown(df_county[&#39;link&#39;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_town &#x3D; pd.DataFrame(town)</span><br><span class="line">df_town</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>code</th>      <th>link</th>      <th>name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>130706001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 城镇街道办事处</td>    </tr>    <tr>      <th> 1</th>      <td>130706002000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 煤矿街道办事处</td>    </tr>    <tr>      <th> 2</th>      <td>130706200000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 花园乡</td>    </tr>    <tr>      <th> 3</th>      <td>130706201000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 辛庄子乡</td>    </tr>    <tr>      <th> 4</th>      <td>130706202000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 定方水乡</td>    </tr>    <tr>      <th> 5</th>      <td>130706203000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 段家堡乡</td>    </tr>    <tr>      <th> 6</th>      <td>130702001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 红旗楼街道办事处</td>    </tr>    <tr>      <th> 7</th>      <td>130702002000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 胜利北路街道办事处</td>    </tr>    <tr>      <th> 8</th>      <td>130702003000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 五一路街道办事处</td>    </tr>    <tr>      <th> 9</th>      <td>130702004000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 花园街街道办事处</td>    </tr>    <tr>      <th> 10</th>      <td>130702005000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 工业路街道办事处</td>    </tr>    <tr>      <th> 11</th>      <td>130702101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 姚家庄镇</td>    </tr>    <tr>      <th> 12</th>      <td>130623001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 城区社区管理办公室街道办事处</td>    </tr>    <tr>      <th> 13</th>      <td>130624100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阜平镇</td>    </tr>    <tr>      <th> 14</th>      <td>130624101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 龙泉关镇</td>    </tr>    <tr>      <th> 15</th>      <td>130626100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 定兴镇</td>    </tr>    <tr>      <th> 16</th>      <td>130623100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 涞水镇</td>    </tr>    <tr>      <th> 17</th>      <td>130624102000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 平阳镇</td>    </tr>    <tr>      <th> 18</th>      <td>130624103000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 城南庄镇</td>    </tr>    <tr>      <th> 19</th>      <td>130624104000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 天生桥镇</td>    </tr>    <tr>      <th> 20</th>      <td>130624105000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 王林口镇</td>    </tr>    <tr>      <th> 21</th>      <td>130624202000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 台峪乡</td>    </tr>    <tr>      <th> 22</th>      <td>130624203000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 大台乡</td>    </tr>    <tr>      <th> 23</th>      <td>130624204000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 史家寨乡</td>    </tr>    <tr>      <th> 24</th>      <td>130624205000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 砂窝乡</td>    </tr>    <tr>      <th> 25</th>      <td>130724100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 平定堡镇</td>    </tr>    <tr>      <th> 26</th>      <td>130724101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 小厂镇</td>    </tr>    <tr>      <th> 27</th>      <td>130724102000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 黄盖淖镇</td>    </tr>    <tr>      <th> 28</th>      <td>130724103000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 九连城镇</td>    </tr>    <tr>      <th> 29</th>      <td>130724200000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 高山堡乡</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>42532</th>      <td>659002509000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团十六团</td>    </tr>    <tr>      <th> 42533</th>      <td>659002511000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团第一师水利水电工程处</td>    </tr>    <tr>      <th> 42534</th>      <td>659002512000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团第一师塔里木灌区水利管理处</td>    </tr>    <tr>      <th> 42535</th>      <td>659002513000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿拉尔农场</td>    </tr>    <tr>      <th> 42536</th>      <td>659002514000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团第一师幸福农场</td>    </tr>    <tr>      <th> 42537</th>      <td>659002515000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 中心监狱</td>    </tr>    <tr>      <th> 42538</th>      <td>659002516000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团一团</td>    </tr>    <tr>      <th> 42539</th>      <td>659002517000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团农一师沙井子水利管理处</td>    </tr>    <tr>      <th> 42540</th>      <td>659002518000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 西工业园区管理委员会</td>    </tr>    <tr>      <th> 42541</th>      <td>659002519000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团二团</td>    </tr>    <tr>      <th> 42542</th>      <td>659002520000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团三团</td>    </tr>    <tr>      <th> 42543</th>      <td>522701001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 广惠街道办事处</td>    </tr>    <tr>      <th> 42544</th>      <td>522701002000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 文峰街道办事处</td>    </tr>    <tr>      <th> 42545</th>      <td>522701004000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 小围寨街道办事处</td>    </tr>    <tr>      <th> 42546</th>      <td>522701005000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沙包堡街道办事处</td>    </tr>    <tr>      <th> 42547</th>      <td>522701006000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 绿茵湖街道办事处</td>    </tr>    <tr>      <th> 42548</th>      <td>522701106000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 墨冲镇</td>    </tr>    <tr>      <th> 42549</th>      <td>522701107000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 平浪镇</td>    </tr>    <tr>      <th> 42550</th>      <td>522701110000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 毛尖镇</td>    </tr>    <tr>      <th> 42551</th>      <td>522701111000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 匀东镇</td>    </tr>    <tr>      <th> 42552</th>      <td>522701208000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 归兰水族乡</td>    </tr>    <tr>      <th> 42553</th>      <td>652928100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿瓦提镇</td>    </tr>    <tr>      <th> 42554</th>      <td>652928101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌鲁却勒镇</td>    </tr>    <tr>      <th> 42555</th>      <td>652928102000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 拜什艾日克镇</td>    </tr>    <tr>      <th> 42556</th>      <td>652928200000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿依巴格乡</td>    </tr>    <tr>      <th> 42557</th>      <td>652928201000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 塔木托格拉克乡</td>    </tr>    <tr>      <th> 42558</th>      <td>652928202000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 英艾日克乡</td>    </tr>    <tr>      <th> 42559</th>      <td>652928203000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 多浪乡</td>    </tr>    <tr>      <th> 42560</th>      <td>652928204000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 巴格托格拉克乡</td>    </tr>    <tr>      <th> 42561</th>      <td>652928405000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿克苏监狱</td>    </tr>  </tbody></table>    <h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照街道代码进行 “升序” 排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_town_sorted &#x3D; df_town.sort_values(by &#x3D; [&#39;code&#39;]) #按1列进行升序排序</span><br></pre></td></tr></table></figure><p>信息写入 csv 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_town_sorted.to_csv(&#39;town.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取居委会代码函数-—-多线程实现"><a href="#获取居委会代码函数-—-多线程实现" class="headerlink" title="获取居委会代码函数 — 多线程实现"></a>获取居委会代码函数 — 多线程实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def getVillage(url_list):</span><br><span class="line">    queue_village &#x3D; Queue() #队列</span><br><span class="line">    thread_num &#x3D; 200 #进程数</span><br><span class="line">    town &#x3D; [] #记录街道信息的字典（全局）</span><br><span class="line">    </span><br><span class="line">    def produce_url(url_list):</span><br><span class="line">        for url in url_list:</span><br><span class="line">            queue_village.put(url) # 生成URL存入队列，等待其他线程提取</span><br><span class="line">    </span><br><span class="line">    def getData():</span><br><span class="line">        while not queue_village.empty(): # 保证url遍历结束后能退出线程</span><br><span class="line">            url &#x3D; queue_village.get() # 从队列中获取URL</span><br><span class="line">            data &#x3D; getUrl(url)</span><br><span class="line">            selector &#x3D; etree.HTML(data)</span><br><span class="line">            villageList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;villagetr&quot;]&#39;)</span><br><span class="line">            #下面是爬取每个区的代码、URL</span><br><span class="line">            for i in villageList:</span><br><span class="line">                villageCode &#x3D; i.xpath(&#39;td[1]&#x2F;text()&#39;)</span><br><span class="line">                UrbanRuralCode &#x3D; i.xpath(&#39;td[2]&#x2F;text()&#39;)</span><br><span class="line">                villageName &#x3D; i.xpath(&#39;td[3]&#x2F;text()&#39;)</span><br><span class="line">                #上面得到的是列表形式的，下面将其每一个用字典存储</span><br><span class="line">                for j in range(len(villageCode)):</span><br><span class="line">                    town.append(&#123;&#39;code&#39;:villageCode[j],&#39;UrbanRuralCode&#39;:UrbanRuralCode[j],&#39;name&#39;:villageName[j]&#125;)</span><br><span class="line">                </span><br><span class="line">    def run(url_list):</span><br><span class="line">        produce_url(url_list)</span><br><span class="line">    </span><br><span class="line">        ths &#x3D; []</span><br><span class="line">        for _ in range(thread_num):</span><br><span class="line">            th &#x3D; Thread(target &#x3D; getData)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        for th in ths:</span><br><span class="line">            th.join()</span><br><span class="line">            </span><br><span class="line">    run(url_list)</span><br><span class="line">    return town</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">village &#x3D; getVillage(df_town[&#39;link&#39;])</span><br></pre></td></tr></table></figure><pre><code>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/24/140724204.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/27/140727400.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/10/29/141029204.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/04/150104008.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981102.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/02/150102001.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981210.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/21/150421202.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/25/150425100.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/22/150422401.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/02/150402402.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/30/150430207.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/21/150121105.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/07/22/150722105.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/25/26/152526103.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/21/210421209.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/22/210422108.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502002.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/06/03/210603007.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502010.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/03/210503005.htmlrequests fail, retry!</code></pre><p>由于数据量很大，所以这里我没有爬取完毕。    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第二篇，详细分析了爬取全过程。&lt;/p&gt;
&lt;p&gt;详细的代码开源在 GitHub 上：&lt;a href=&quot;https://github.com/dta0502/NBSPRC-spider&quot;&gt;NBSPRC-sp</summary>
      
    
    
    
    <category term="爬虫" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://matthew84.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫 -（一）页面分析</title>
    <link href="https://matthew84.cf/archives/d4af1e8a.html"/>
    <id>https://matthew84.cf/archives/d4af1e8a.html</id>
    <published>2020-11-03T10:59:23.000Z</published>
    <updated>2020-11-03T11:29:46.211Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第一篇，首先先分析一下页面，为后面的页面解析做准备。</p><p>详细的代码开源在 GitHub 上：<a href="https://github.com/dta0502/NBSPRC-spider">NBSPRC-spider</a>。</p><p>这里我就拿2016年的页面做下分析：<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html">2016 年统计用区划代码和城乡划分代码</a>。</p><h1 id="省级页面分析"><a href="#省级页面分析" class="headerlink" title="省级页面分析"></a>省级页面分析</h1><h2 id="省级信息提取"><a href="#省级信息提取" class="headerlink" title="省级信息提取"></a>省级信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html">2016 年统计用区划代码和城乡划分代码</a>这个页面，然后用 chrome 的 “检查” 工具看下我们要找的信息在哪。</p><p>这里我们需要爬取省级名称、省内市级信息的子链接这两个参数。</p><p>我们从图中可以发现，左边页面每一行对应的 XPath 路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;tr[@class&#x3D;&quot;provincetr&quot;]</span><br></pre></td></tr></table></figure><p>然后一行中每个省的信息在下一级的 td 标签内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">td&#x2F;a&#x2F;text()</span><br><span class="line">td&#x2F;a&#x2F;@href</span><br><span class="line">省级页面分析</span><br><span class="line">省级页面分析</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj1.webp"></p><h2 id="下级链接获取"><a href="#下级链接获取" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>省级页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;index.html</span><br></pre></td></tr></table></figure><p>下级页面的 URL（我这里以<code>浙江省</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>浙江省</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33.html</span><br></pre></td></tr></table></figure><p>所以我们可以通过如下方式获取真实的 URL 保存到一个列表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;index.html&quot;</span><br><span class="line"># provinceLink &#x3D; &quot;33.html&quot;</span><br><span class="line">provinceURL &#x3D; url[:-10] + provinceLink</span><br></pre></td></tr></table></figure><h1 id="市级页面分析"><a href="#市级页面分析" class="headerlink" title="市级页面分析"></a>市级页面分析</h1><h2 id="市级信息提取"><a href="#市级信息提取" class="headerlink" title="市级信息提取"></a>市级信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html">浙江省</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是市级页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj2.webp"></p><h2 id="下级链接获取-1"><a href="#下级链接获取-1" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>市级页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33.html</span><br></pre></td></tr></table></figure><p>下级页面的 URL（我这里以<code>杭州市</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;3301.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>杭州市</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33&#x2F;3301.html</span><br></pre></td></tr></table></figure><h1 id="区级页面分析"><a href="#区级页面分析" class="headerlink" title="区级页面分析"></a>区级页面分析</h1><h2 id="区级信息提取"><a href="#区级信息提取" class="headerlink" title="区级信息提取"></a>区级信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html">杭州市</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是区级页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj3.webp"></p><h2 id="下级链接获取-2"><a href="#下级链接获取-2" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>区级页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;3301.html</span><br></pre></td></tr></table></figure><p>下级页面的 URL（我这里以<code>上城区</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;01&#x2F;330102.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>上城区</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01&#x2F;330102.html</span><br></pre></td></tr></table></figure><h1 id="街道页面分析"><a href="#街道页面分析" class="headerlink" title="街道页面分析"></a>街道页面分析</h1><h2 id="街道信息提取"><a href="#街道信息提取" class="headerlink" title="街道信息提取"></a>街道信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html">上城区</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是街道页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj4.webp"></p><h2 id="下级链接获取-3"><a href="#下级链接获取-3" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>街道页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;01&#x2F;330102.html</span><br></pre></td></tr></table></figure><p>街道页面的 URL（我这里以<code>湖滨街道</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;01&#x2F;02&#x2F;330102003.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>湖滨街道</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02&#x2F;330102003.html</span><br></pre></td></tr></table></figure><h1 id="居委会页面分析"><a href="#居委会页面分析" class="headerlink" title="居委会页面分析"></a>居委会页面分析</h1><h2 id="居委会信息提取"><a href="#居委会信息提取" class="headerlink" title="居委会信息提取"></a>居委会信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/02/330102003.html">湖滨街道</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是居委会页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj5.webp"><br>这里已经到了最底层，没有下级链接了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第一篇，首先先分析一下页面，为后面的页面解析做准备。&lt;/p&gt;
&lt;p&gt;详细的代码开源在 GitHub 上：&lt;a href=&quot;https://github.com/dta0502/NBSPRC-spider</summary>
      
    
    
    
    <category term="爬虫" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://matthew84.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy 框架的使用之 Item Pipeline 的用法</title>
    <link href="https://matthew84.cf/archives/f3666482.html"/>
    <id>https://matthew84.cf/archives/f3666482.html</id>
    <published>2020-11-03T10:58:28.000Z</published>
    <updated>2020-11-03T11:08:08.487Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍一下 Scrapy 框架中的 Item Pipeline 的用法。</p><p>Item Pipeline 的调用发生在 Spider 产生 Item 之后。当 Spider 解析完 Response 之后，Item 就会传递到 Item Pipeline，被定义的 Item Pipeline 组件会顺次调用，完成一连串的处理过程，比如数据清洗、存储等。</p><p>Item Pipeline 的主要功能有如下 4 点。</p><ul><li>清理 HTML 数据。</li><li>验证爬取数据，检查爬取字段。</li><li>查重并丢弃重复内容。</li><li>将爬取结果保存到数据库。</li></ul><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>我们可以自定义 Item Pipeline，只需要实现指定的方法，其中必须要实现的一个方法是：<code>process_item(item, spider)</code>。</p><p>另外还有如下几个比较实用的方法。</p><ul><li><code>open_spider(spider)</code></li><li><code>close_spider(spider)</code></li><li><code>from_crawler(cls, crawler)</code></li></ul><p>下面我们详细介绍这几个方法的用法。</p><h2 id="process-item-item-spider"><a href="#process-item-item-spider" class="headerlink" title="process_item(item, spider)"></a><code>process_item(item, spider)</code></h2><p><code>process_item()</code>是必须要实现的方法，被定义的 Item Pipeline 会默认调用这个方法对 Item 进行处理。比如，我们可以进行数据处理或者将数据写入到数据库等操作。它必须返回 Item 类型的值或者抛出一个 DropItem 异常。</p><p><code>process_item()</code>方法的参数有如下两个。</p><ul><li>item，是 Item 对象，即被处理的 Item。</li><li>spider，是 Spider 对象，即生成该 Item 的 Spider。</li></ul><p><code>process_item()</code>方法的返回类型归纳如下。</p><ul><li>如果它返回的是 Item 对象，那么此 Item 会被低优先级的 Item Pipeline 的<code>process_item()</code>方法处理，直到所有的方法被调用完毕。</li><li>如果它抛出的是 DropItem 异常，那么此 Item 会被丢弃，不再进行处理。</li></ul><h2 id="open-spider-self-spider"><a href="#open-spider-self-spider" class="headerlink" title="open_spider(self, spider)"></a><code>open_spider(self, spider)</code></h2><p><code>open_spider()</code>方法是在 Spider 开启的时候被自动调用的。在这里我们可以做一些初始化操作，如开启数据库连接等。其中，参数 spider 就是被开启的 Spider 对象。</p><h2 id="close-spider-spider"><a href="#close-spider-spider" class="headerlink" title="close_spider(spider)"></a><code>close_spider(spider)</code></h2><p>close_spider() 方法是在 Spider 关闭的时候自动调用的。在这里我们可以做一些收尾工作，如关闭数据库连接等。其中，参数 spider 就是被关闭的 Spider 对象。</p><h2 id="from-crawler-cls-crawler"><a href="#from-crawler-cls-crawler" class="headerlink" title="from_crawler(cls, crawler)"></a><code>from_crawler(cls, crawler)</code></h2><p><code>from_crawler()</code>方法是一个类方法，用<code>@classmethod</code>标识，是一种依赖注入的方式。它的参数是 crawler，通过 crawler 对象，我们可以拿到 Scrapy 的所有核心组件，如全局配置的每个信息，然后创建一个 Pipeline 实例。参数 cls 就是 Class，最后返回一个 Class 实例。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="MongoDB-Pipeline"><a href="#MongoDB-Pipeline" class="headerlink" title="MongoDB Pipeline"></a>MongoDB Pipeline</h2><p>我们用一个 MongoPipeline 将信息保存到 MongoDB，在<code>pipelines.py</code>里添加如下类的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">class MongoPipeline(object):</span><br><span class="line">    def __init__(self, mongo_uri, mongo_db):</span><br><span class="line">        self.mongo_uri &#x3D; mongo_uri</span><br><span class="line">        self.mongo_db &#x3D; mongo_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(</span><br><span class="line">            mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),</span><br><span class="line">            mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DB&#39;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        self.client &#x3D; pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db &#x3D; self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.db[item.collection].insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.client.close()</span><br></pre></td></tr></table></figure><p>这里需要用到两个变量，MONGO_URI 和 MONGO_DB，即存储到 MongoDB 的链接地址和数据库名称。我们在 settings.py 里添加这两个变量，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MONGO_URI &#x3D; &#39;localhost&#39;</span><br><span class="line">MONGO_DB &#x3D; &#39;images360&#39;</span><br></pre></td></tr></table></figure><p>样一个保存到 MongoDB 的 Pipeline 的就创建好了。这里最主要的方法是<code>process_item()</code>方法，直接调用 Collection 对象的<code>insert()</code>方法即可完成数据的插入，最后返回 Item 对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文简单介绍一下 Scrapy 框架中的 Item Pipeline 的用法。&lt;/p&gt;
&lt;p&gt;Item Pipeline 的调用发生在 Spider 产生 Item 之后。当 Spider 解析完 Response 之后，Item 就会传递到 Item Pipeline，被</summary>
      
    
    
    
    <category term="爬虫" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Scrapy" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/Scrapy/"/>
    
    
    <category term="爬虫" scheme="https://matthew84.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Scrapy" scheme="https://matthew84.cf/tags/Scrapy/"/>
    
    <category term="Pipeline" scheme="https://matthew84.cf/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Python 内建容器类型</title>
    <link href="https://matthew84.cf/archives/93eb5e7e.html"/>
    <id>https://matthew84.cf/archives/93eb5e7e.html</id>
    <published>2020-11-03T09:50:39.000Z</published>
    <updated>2020-11-03T10:03:57.409Z</updated>
    
    <content type="html"><![CDATA[<p>在 Python 中，有四类最常见的内建容器类型：列表（list）、元组（tuple）、字典（dict）、集合（set）。通过单独或是组合使用它们，可以高效的完成很多事情。</p><div class="note simple"><p>Python 是一门高级编程语言，它所提供的内置容器类型，都是经过高度封装和抽象后的结果。和 “链表”、“红黑树”、“哈希表” 这些名字相比，所有 Python 内建类型的名字，都只描述了这个类型的功能特点，其他人完全没法只通过这些名字了解它们的哪怕一丁点内部细节。这是 Python 编程语言的优势之一。相比 C 语言这类更接近计算机底层的编程语言，Python 重新设计并实现了对编程者更友好的内置容器类型，屏蔽掉了内存管理等额外工作。为我们提供了更好的开发体验。</p></div><h1 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 - list"></a>列表 - list</h1><p>列表的特性：</p><ol><li>有序的集合</li><li>通过偏移来索引，从而读取数据</li><li>支持嵌套</li><li>可变的类型</li><li>查找和插入元素的时间随元素增多而变慢，时间复杂度 O (n)</li></ol><h1 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 - tuple"></a>元组 - tuple</h1><p>下面是元组和列表的几个区别。</p><h2 id="元组是不可变的"><a href="#元组是不可变的" class="headerlink" title="元组是不可变的"></a>元组是不可变的</h2><div class="note simple"><p>The key difference is that tuples are immutable. This means that you cannot change the values in a tuple once you have created it.</p></div><p><strong>最重要的区别：元组是不可变的，而列表是可变的</strong>。</p><p>下面两点是元组的优点。</p><h2 id="大小不同"><a href="#大小不同" class="headerlink" title="大小不同"></a>大小不同</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; tuple(range(1000))</span><br><span class="line">b &#x3D; list(range(1000))</span><br><span class="line"></span><br><span class="line">print(a.__sizeof__()) # 8024</span><br><span class="line">print(b.__sizeof__()) # 9088</span><br></pre></td></tr></table></figure><div class="note simple"><p>Due to the smaller size of a tuple operation, it becomes a bit faster, but not that much to mention about until you have a huge number of elements.</p></div><p>由于元组支持的操作比列表小， 所以元组会比列表稍稍快上那么一丢丢。但是除非你有巨量的数据要去处理，否者这一点不需要特别强调。</p><h2 id="元组可以作为字典的-key"><a href="#元组可以作为字典的-key" class="headerlink" title="元组可以作为字典的 key"></a>元组可以作为字典的 key</h2><div class="note simple"><p>You can’t use list as a dictionary identifier.</p></div><p>你不能将列表当作字典的 key，而元组可以（<strong>因为元组是不可变的</strong>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; (1,2)</span><br><span class="line">b &#x3D; [1,2] </span><br><span class="line"></span><br><span class="line">c &#x3D; &#123;a: 1&#125;     # OK</span><br><span class="line">c &#x3D; &#123;b: 1&#125;     # Error (TypeError: unhashable type: &#39;list&#39;)</span><br></pre></td></tr></table></figure><h1 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 - dict"></a>字典 - dict</h1><p>下面是字典的几个特点。</p><h2 id="查找速度快"><a href="#查找速度快" class="headerlink" title="查找速度快"></a>查找速度快</h2><p>无论 dict 有 10 个元素还是 10 万个元素，查找速度都一样。而 list 的查找速度随着元素增加而逐渐下降。不过 dict 的查找速度快不是没有代价的，dict 的缺点是占用内存大，还会浪费很多内容，list 正好相反，占用内存小，但是查找速度慢。由于 dict 是按 key 查找，所以，在一个 dict 中，key 不能重复。</p><h2 id="存储的-key-value-序对没有顺序"><a href="#存储的-key-value-序对没有顺序" class="headerlink" title="存储的 key-value 序对没有顺序"></a>存储的 key-value 序对没有顺序</h2><p>这一点和 list 不一样。</p><p>当我们打印下面这个 dict 会得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;</span><br><span class="line">    &#39;Adam&#39;: 95,</span><br><span class="line">    &#39;Lisa&#39;: 85,</span><br><span class="line">    &#39;Bart&#39;: 59</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;Lisa&#39;: 85, &#39;Adam&#39;: 95, &#39;Bart&#39;: 59&#125;</span><br></pre></td></tr></table></figure><p>打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明<strong>dict 内部是无序的，不能用 dict 存储有序的集合</strong>。</p><h2 id="作为-key-的元素必须不可变"><a href="#作为-key-的元素必须不可变" class="headerlink" title="作为 key 的元素必须不可变"></a>作为 key 的元素必须不可变</h2><p>Python 的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是 list 是可变的，就不能作为 key。不可变这个限制仅作用于 key，value 是否可变是无所谓的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#39;123&#39;: [1, 2, 3],  # key 是 str，value是list</span><br><span class="line">    123: &#39;123&#39;,        # key 是 int，value 是 str</span><br><span class="line">    (&#39;a&#39;, &#39;b&#39;): True   # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的 key 还是字符串，因为用起来最方便。</p><h1 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 - set"></a>集合 - set</h1><p>dict 的作用是建立一组 key 和一组 value 的映射关系，dict 的 key 是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set 就派上用场了。set 持有一系列元素，这一点和 list 很像，但是 set 的元素没有重复，而且是无序的，这点和 dict 的 key 很像。</p><p>set 的特点：</p><ol><li>set 的内部结构和 dict 很像，唯一区别是不存储 value，因此，判断一个元素是否在 set 中速度很快。</li><li>set 存储的元素和 dict 的 key 类似，必须是不变对象，因此，任何可变对象是不能放入 set 中的。</li><li>set 存储的元素也是没有顺序的。</li><li>set 不能包含重复的元素（set 会自动去掉重复的元素）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Python 中，有四类最常见的内建容器类型：列表（list）、元组（tuple）、字典（dict）、集合（set）。通过单独或是组合使用它们，可以高效的完成很多事情。&lt;/p&gt;
&lt;div class=&quot;note simple&quot;&gt;&lt;p&gt;Python 是一门高级编程语言，它</summary>
      
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="容器类型" scheme="https://matthew84.cf/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python集合用处</title>
    <link href="https://matthew84.cf/archives/56cd6720.html"/>
    <id>https://matthew84.cf/archives/56cd6720.html</id>
    <published>2020-11-03T09:50:15.000Z</published>
    <updated>2020-11-03T09:56:30.277Z</updated>
    
    <content type="html"><![CDATA[<p>集合的最大特点是：集合里边的元素是不可重复的并且集合内的元素还是无序的。</p><p>一般情况下集合常用的两个场景是：</p><ul><li>去重（如：列表去重）</li><li>关系测试（如：取交集、取并集、取差集等）</li></ul><h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="比较麻烦的方法-——-利用列表"><a href="#比较麻烦的方法-——-利用列表" class="headerlink" title="比较麻烦的方法 —— 利用列表"></a>比较麻烦的方法 —— 利用列表</h2><p>方法就是遍历一个列表，对其中的每个数据判断在不在第二个列表里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1&#x3D;[1,2,3,4]</span><br><span class="line">list2&#x3D;[3,4,5,6]</span><br><span class="line">list3&#x3D;[]</span><br><span class="line">for i in list1:</span><br><span class="line">   if i in list2:</span><br><span class="line">       list3.append(i)</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure><h2 id="运用集合来去重"><a href="#运用集合来去重" class="headerlink" title="运用集合来去重"></a>运用集合来去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set1 &#x3D; set(list1)</span><br><span class="line">print(&quot;list1去重后的set集合：&quot;,set1)</span><br><span class="line"># 再转化成一个列表</span><br><span class="line">new_list &#x3D; [i for i in set1]</span><br><span class="line">print(&quot;list1去重后的list列表：&quot;,new_list)</span><br></pre></td></tr></table></figure><h1 id="关系测试"><a href="#关系测试" class="headerlink" title="关系测试"></a>关系测试</h1><p>一些集合的最基本操作，如集合取交集、取并集、取差集、判断一个集合是不是另一个集合子集或者父集等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1 &#x3D; set([1,2,3,4,5])</span><br><span class="line">set2 &#x3D; set([3,4,5,6,7])</span><br></pre></td></tr></table></figure><h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><figure class="highlight plain"><figcaption><span>方法1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(set1.intersection(set2))</span><br><span class="line"># 方法2</span><br><span class="line">print(set1 &amp; set2)</span><br></pre></td></tr></table></figure><h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><figure class="highlight plain"><figcaption><span>方法1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(set1.union(set2))</span><br><span class="line"># 方法2</span><br><span class="line">print(set1 | set2)</span><br></pre></td></tr></table></figure><h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><p>这里需要注意顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># set1 - set2</span><br><span class="line">print(set1.difference(set2))</span><br><span class="line">print(set1 - set2)</span><br><span class="line"># set2 - set1</span><br><span class="line">print(set2.difference(set1))</span><br><span class="line">print(set2 - set1)</span><br></pre></td></tr></table></figure><h2 id="子集判断"><a href="#子集判断" class="headerlink" title="子集判断"></a>子集判断</h2><figure class="highlight plain"><figcaption><span>判断set1是否是set2的子集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(set1.issubset(set2))</span><br></pre></td></tr></table></figure><h2 id="父集判断"><a href="#父集判断" class="headerlink" title="父集判断"></a>父集判断</h2><figure class="highlight plain"><figcaption><span>判断set1是否是set2的父集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(set1.issuperset(set2))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;集合的最大特点是：集合里边的元素是不可重复的并且集合内的元素还是无序的。&lt;/p&gt;
&lt;p&gt;一般情况下集合常用的两个场景是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去重（如：列表去重）&lt;/li&gt;
&lt;li&gt;关系测试（如：取交集、取并集、取差集等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;去重&quot;</summary>
      
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="集合" scheme="https://matthew84.cf/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Python用list实现堆栈和队列</title>
    <link href="https://matthew84.cf/archives/63ac562f.html"/>
    <id>https://matthew84.cf/archives/63ac562f.html</id>
    <published>2020-11-03T09:36:40.000Z</published>
    <updated>2020-11-03T09:48:45.846Z</updated>
    
    <content type="html"><![CDATA[<p>Python中可以用list来模拟栈和队列：</p><ul><li><strong>栈（stack）</strong>: 只能在一端进行数据操作，遵循后进先出（LIFO）原则</li><li><strong>队列（queue）</strong>: 可以在两端进行数据操作，遵循先进先出（FIFO）原则，出队列的一端称为队首，入队列的一端称为队尾</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈要记录的数据"><a href="#栈要记录的数据" class="headerlink" title="栈要记录的数据"></a>栈要记录的数据</h2><ul><li>栈顶位置 top：注意这个 top 有两种理解方式，一种是表示栈的最后一个数据的位置，另一种是表示栈的最后一个数据的下一个位置，这两种理解对栈的操作代码有一定的影响</li><li>栈最大大小 size</li></ul><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><code>isEmpty()</code>：判断栈是否为空</li><li><code>isFull()</code>：判断栈是否已满</li><li><code>push(element)</code>：向栈中添加一个值，<strong>注意栈是否为满的</strong></li><li><code>pop()</code>：从栈中弹出一个值，<strong>注意栈是否为空</strong></li></ul><h2 id="Python-列表实现栈"><a href="#Python-列表实现栈" class="headerlink" title="Python 列表实现栈"></a>Python 列表实现栈</h2><figure class="highlight plain"><figcaption><span>StackException(Exception):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">class Stack(object):</span><br><span class="line">    def __init__(self,size &#x3D; 10):</span><br><span class="line">        self.S &#x3D; []</span><br><span class="line">        self.size &#x3D; size  # 栈大小</span><br><span class="line">        self.top &#x3D; -1     # 栈顶位置</span><br><span class="line"></span><br><span class="line">    def setSize(self, size):</span><br><span class="line">        # 设置栈的大小</span><br><span class="line">        self.size &#x3D; size    </span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判断栈是否为空</span><br><span class="line">        if self.top &#x3D;&#x3D; -1:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    </span><br><span class="line">    def isFull(self):</span><br><span class="line">        # 判断栈是否满</span><br><span class="line">        if self.top &#x3D;&#x3D; self.size - 1:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        # 查看栈顶的对象，但不移除</span><br><span class="line">        if self.isEmpty():</span><br><span class="line">            raise StackException(&#39;StackUnderflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.S[-1]</span><br><span class="line">            return element</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        # 移除栈顶对象，并返回该对象的值</span><br><span class="line">        if self.isEmpty():</span><br><span class="line">            raise StackException(&#39;StackUnderflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.S[-1]</span><br><span class="line">            self.top &#x3D; self.top - 1</span><br><span class="line">            del self.S[-1]</span><br><span class="line">            return element</span><br><span class="line"></span><br><span class="line">    def push(self, element):</span><br><span class="line">        # 把对象压入栈顶</span><br><span class="line">        if self.isFull():</span><br><span class="line">            raise StackException(&#39;StackOverflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            self.S.append(element)</span><br><span class="line">            self.top &#x3D; self.top + 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    s &#x3D; Stack()</span><br><span class="line">    # 压栈测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        s.push(i)</span><br><span class="line">    # 栈满测试</span><br><span class="line">    try:</span><br><span class="line">        s.push(1)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    # 出栈测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(s.pop())</span><br><span class="line">    # 栈空测试</span><br><span class="line">    try:</span><br><span class="line">        s.pop()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列要记录的数据"><a href="#队列要记录的数据" class="headerlink" title="队列要记录的数据"></a>队列要记录的数据</h2><ul><li>队头位置 end</li><li>队列的大小 size</li></ul><h2 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h2><div class="note simple"><p>利用数组 Q[1..n] 来实现含有 n-1 个元素队列（保留一位元素用来判断队列空或满）。该列有一个属性 Q.head 指向队头元素，属性 Q.tail 指向下一个新元素将要插入的位置，列中的元素存放在位置 Q.head, Q.head+1, …, Q.tail-1 上。</p><ul><li>初始时，Q.head = Q.tail = 1</li><li>当 Q.head = Q.tail 时， 队列为空</li><li>当 Q.head = Q.tail + 1 时，队列为满</li></ul></div><h2 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h2><ul><li>isEmpty()：判断队列是否为空</li><li>isFull()：判断队列是否已满</li><li>inQueue(element)：入队</li><li>outQueue()：出队</li></ul><h2 id="Python-列表实现队列"><a href="#Python-列表实现队列" class="headerlink" title="Python 列表实现队列"></a>Python 列表实现队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class QueueException(Exception):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">class Queue(object):</span><br><span class="line">    def __init__(self, size&#x3D;10):</span><br><span class="line">        self.Q &#x3D; []</span><br><span class="line">        self.size &#x3D; size  # 队列大小</span><br><span class="line">        self.end &#x3D; -1     # 队头位置</span><br><span class="line">    </span><br><span class="line">    def setSize(self, size):</span><br><span class="line">        # 设置队列的大小</span><br><span class="line">        self.size &#x3D; size</span><br><span class="line">    </span><br><span class="line">    def inQueue(self, element):</span><br><span class="line">        # 对象入队</span><br><span class="line">        if self.end &lt; self.size - 1:</span><br><span class="line">            self.Q.append(element)</span><br><span class="line">            self.end +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            raise QueueException(&#39;QueueFull&#39;)</span><br><span class="line">    </span><br><span class="line">    def outQueue(self):</span><br><span class="line">        # 对象出队</span><br><span class="line">        if self.end &#x3D;&#x3D; -1:</span><br><span class="line">            raise QueueException(&#39;QueueEmpty&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.Q[0]</span><br><span class="line">            self.Q &#x3D; self.Q[1:]</span><br><span class="line">            self.end -&#x3D; 1</span><br><span class="line">            return element</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    q &#x3D; Queue()</span><br><span class="line">    # 入队测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        q.inQueue(i)</span><br><span class="line">    # 队列满测试</span><br><span class="line">    try:</span><br><span class="line">        q.inQueue(1)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    # 出队测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(q.outQueue())</span><br><span class="line">    # 队列空测试</span><br><span class="line">    try:</span><br><span class="line">        q.outQueue()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Python中用list来模拟栈和队列</summary>
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="list" scheme="https://matthew84.cf/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的选择字体 (font-family)</title>
    <link href="https://matthew84.cf/archives/75cb947d.html"/>
    <id>https://matthew84.cf/archives/75cb947d.html</id>
    <published>2020-11-03T09:04:40.000Z</published>
    <updated>2020-11-03T09:35:05.163Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道，在不同操作系统、不同游览器里面默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同，那么如何设置字体显示效果会比较好呢？下面我们逐步的分析一下：</p><h1 id="首先我们看看各平台的默认字体情况"><a href="#首先我们看看各平台的默认字体情况" class="headerlink" title="首先我们看看各平台的默认字体情况"></a>首先我们看看各平台的默认字体情况</h1><h2 id="Window-下："><a href="#Window-下：" class="headerlink" title="Window 下："></a>Window 下：</h2><ul><li><p><strong>宋体（SimSun）</strong>：Win 下大部分游览器的默认字体，宋体在小字号下（如 12px、14px）的显示效果还可以接受，但是字号一大就非常糟糕了，所以使用的时候要注意。</p></li><li><p><strong>微软雅黑（”Microsoft Yahei”）</strong>：从 Vista 开始，微软提供了这款新的字体，一款无衬线的黑体类字体，并且拥有<code>Regular</code>、<code>Bold</code>两种粗细的字重，显著提高了字体的显示效果。现在这款字体已经成为 Windows 游览器中最值得使用的中文字体。从 Win8 开始，微软雅黑又加入了<code>Light</code>这款更细的字重，对于喜欢细字体的设计、开发人员又多了一个新的选择。</p></li><li><p><strong>Arial</strong>：Win 平台上默认的无衬线西文字体（为什么要说英文字体后面会解释），有多种变体，显示效果一般。</p></li><li><p><strong>Tahoma</strong>：十分常见的无衬线字体，被采用为 Windows 2000、Windows XP、Windows Server 2003 及 Sega 游戏主机 Dreamcast 等系统的预设字型，显示效果比 Arial 要好。</p></li><li><p><strong>Verdana</strong>：无衬线字体，优点在于它在小字上仍结构清晰端整、阅读辨识容易。</p></li></ul><p>其他：Windows 下默认字体列表：微软官网、维基百科、Office 字体</p><p>结论：微软雅黑为 Win 平台上最值得选择的中文字体，但非游览器默认，需要设置；西文字体的选择以<code>Arial</code>、<code>Tahoma</code>等无衬线字体为主。</p><h2 id="Mac-OS-下："><a href="#Mac-OS-下：" class="headerlink" title="Mac OS 下："></a>Mac OS 下：</h2><ul><li><p><strong>华文黑体（STHeiti）、华文细黑（STXihei）</strong>：属于同一字体家族系列，OS X 10.6 之前的简体中文系统界面默认字体，也是目前 Chrome 游览器下的默认字体，有<code>Regular</code>和<code>Bold</code>两个字重，显示效果可以接受，华文细黑也曾是我最喜欢的字体之一。</p></li><li><p><strong>黑体 - 简（Heiti SC）</strong>：从 10.6 开始，黑体 - 简代替华文黑体用作简体中文系统界面默认字体，苹果生态最常用的字体之一，包括 iPhone、iPad 等设备用的也是这款字体，显示效果不错，但是喇叭口设计遭人诟病。</p></li><li><p><strong>冬青黑体（ Hiragino Sans GB ）</strong>：听说又叫苹果丽黑，日文字体<code>Hiragino KakuGothic</code>的简体中文版，简体中文有<code>常规体</code>和<code>粗体</code>两种，冬青黑体是一款清新的专业印刷字体，小字号时足够清晰，拥有很多人的追捧。</p></li><li><p><strong>Times New Roman</strong>：Mac 平台 Safari 下默认的字体，是最常见且广为人知的西文衬线字体之一，众多网页浏览器和文字处理软件都是用它作为默认字体。</p></li><li><p><strong>Helvetica、Helvetica Neue</strong>：一种被广泛使用的传奇般的西文字体（这货还有专门的记录片呢），在微软使用山寨货的<code>Arial</code>时，乔布斯却花费重金获得了<code>Helvetica</code>苹果系统上的使用权，因此该字体也一直伴随着苹果用户，是苹果生态中最常用的西文字体。<code>Helvetica Neue</code>为<code>Helvetica</code>的改善版本，且增加了更多不同粗细与宽度的字形，共拥有 51 种字体版本，极大的满足了日常的使用。</p></li><li><p><strong>苹方（PingFang SC）</strong>：在 Mac OS X EL Capitan 上，苹果为中国用户打造了一款全新中文字体–<code>苹方</code>，去掉了为人诟病的喇叭口，整体造型看上去更加简洁，字族共六枚字体：<code>极细体</code>、<code>纤细体</code>、<code>细体</code>、<code>常规体</code>、<code>中黑体</code>、<code>中粗体</code>。</p></li><li><p><strong>San Francisco</strong>：同样是 Mac OS X EL Capitan 上最新发布的西文字体，感觉和<code>Helvetica</code>看上去差别不大，目前已经应用在 Mac OS 10.11+、iOS 9.0+、watch OS 等最新系统上。</p></li></ul><p>其他：Mac 下默认字体列表：苹果官网、维基百科</p><p>结论：目前苹方和 San Francisco 为苹果推出的最新字体，显示效果也最为优雅，但只有最新系统才能支持，而黑体 - 简和 Helvetica 可以获得更多系统版本支持，显示效果也相差无几，可以接受。</p><h2 id="Android-系统："><a href="#Android-系统：" class="headerlink" title="Android 系统："></a>Android 系统：</h2><ul><li><strong>Droid Sans、Droid Sans Fallback</strong>：<code>Droid Sans</code>为安卓系统中默认的西文字体，是一款人文主义无衬线字体，而<code>Droid Sans Fallback</code>则是包含汉字、日文假名、韩文的文字扩展支持。<br>结论：<code>Droid Sans</code>为默认的字体，并结合了中英文，无需单独设置。</li></ul><h2 id="iOS-系统："><a href="#iOS-系统：" class="headerlink" title="iOS 系统："></a>iOS 系统：</h2><p>iOS 系统的字体和 Mac OS 系统的字体相同，保证了 Mac 上的字体效果，iOS 设备就没有太大问题。</p><h2 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h2><ul><li><p><strong>文泉驿点阵宋体</strong>：类似宋体的衬线字体，一般不推荐使用。</p></li><li><p><strong>文泉驿微米黑</strong>：几乎是 Linux 社区现有的最佳简体中文字体。</p></li></ul><h1 id="选择字体需要注意的问题"><a href="#选择字体需要注意的问题" class="headerlink" title="选择字体需要注意的问题"></a>选择字体需要注意的问题</h1><h2 id="字体的中英文写法："><a href="#字体的中英文写法：" class="headerlink" title="字体的中英文写法："></a>字体的中英文写法：</h2><p>我们在操作系统中常常看到宋体、微软雅黑这样的字体名称，但实际上这只是字体的显示名称，而不是字体文件的名称，一般字体文件都是用英文命名的，如<code>SimSun</code>、<code>Microsoft Yahei</code>。在大多数情况下直接使用显示名称也能正确的显示，但是有一些用户的特殊设置会导致中文声明无效。</p><p>因此，<strong>保守的做法是使用字体的字体名称（英文）或者两者兼写</strong>。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-family: STXihei, &quot;Microsoft YaHei&quot;;</span><br><span class="line">font-family: STXihei, &quot;华文细黑&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;;</span><br></pre></td></tr></table></figure><h2 id="声明英文字体："><a href="#声明英文字体：" class="headerlink" title="声明英文字体："></a>声明英文字体：</h2><p>绝大部分中文字体里都包含英文字母和数字，不进行英文字体声明是没有问题的，但是大多数中文字体中的英文和数字的部分都不是特别漂亮，所以建议也对英文字体进行声明。<br><strong>由于英文字体中大多不包含中文，我们可以先进行英文字体的声明，这样不会影响到中文字体的选择，因此优先使用最优秀的英文字体，中文字体声明则紧随其次</strong>。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Arial, &quot;Microsoft YaHei&quot;;</span><br></pre></td></tr></table></figure><h2 id="照顾不同的操作系统："><a href="#照顾不同的操作系统：" class="headerlink" title="照顾不同的操作系统："></a>照顾不同的操作系统：</h2><ul><li><strong>英文、数字部分</strong>：在默认的操作系统中，Mac 和 Win 都会带有<code>Arial</code>、<code>Verdana</code>、<code>Tahoma</code>等几个预装字体，从显示效果来看，<code>Tahoma</code>要比<code>Arial</code>更加清晰一些，因此字体设置<code>Tahoma</code>最好放到前面，当找不到<code>Tahoma</code>时再使用<code>Arial</code>；而在 Mac 中，还拥有一款更加漂亮的<code>Helvetica</code>字体，所以为了照顾 Mac 用户有更好的体验，应该更优先设置<code>Helvetica</code>字体；Android 系统下默认的无衬线字体就可以接受，因此无需单独设置。最后，英文、数字字体的最佳写法如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial;</span><br></pre></td></tr></table></figure><ul><li><strong>中文部分</strong>：在 Win 下，微软雅黑为大部分人最常使用的中文字体，由于很多人安装 Office 的缘故，Mac 电脑中也会出现微软雅黑字体，因此把显示效果不错的微软雅黑加入到字体列表是个不错的选择；同样，为了保证 Mac 中更为优雅字体苹方（<code>PingFang SC</code>）、黑体 - 简（<code>Heiti SC</code>）、冬青黑体（<code>Hiragino Sans GB</code>）的优先显示，需要把这些字体放到中文字体列表的最前面；同时为了照顾到 Linux 操作系统的体验，还需要添加<code>文泉驿微米黑</code>字体。最后，中文字体部分最佳写法如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><p>中英文整合写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><h2 id="注意向下兼容"><a href="#注意向下兼容" class="headerlink" title="注意向下兼容"></a>注意向下兼容</h2><p>如果还需要考虑旧版本操作系统用户的话，不得不加上一些旧版操作系统存在的字体：Mac 中的<code>华文黑体</code>、<code>冬青黑体</code>，Win 中的<code>黑体</code>等。同样按照显示效果排列在列表后面，写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, STXihei, &quot;Microsoft YaHei&quot;, SimHei, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><p>加入了<code>STXihei</code>（<code>华文细黑</code>）和<code>SimHei</code>（<code>黑体</code>）。</p><h2 id="补充字体族名称"><a href="#补充字体族名称" class="headerlink" title="补充字体族名称"></a>补充字体族名称</h2><p>字体族大体上分为两类：<code>sans-serif</code>（无衬线体）和 <code>serif</code>（衬线体），<strong>当所有的字体都找不到时，我们可以使用字体族名称作为操作系统最后选择字体的方向</strong>。一般非衬线字体在显示器中的显示效果会比较好，因此我们需要在最后添加<code>sans-serif</code>，写法如下：。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><h1 id="我们看一下大公司的常见写法（2016-07-查看）"><a href="#我们看一下大公司的常见写法（2016-07-查看）" class="headerlink" title="我们看一下大公司的常见写法（2016.07 查看）"></a>我们看一下大公司的常见写法（2016.07 查看）</h1><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 14px&#x2F;1.5 &quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Heiti SC&quot;,&quot;WenQuanYi Micro Hei&quot;,sans-serif;</span><br></pre></td></tr></table></figure><p>小米公司优先使用<code>Helvetica Neue</code>这款字体以保证最新版本 Mac 用户的最佳体验，选择了 Arial 作为 Win 下默认英文字体及 Mac 的替代英文字体；中文字体方面首选了微软雅黑，然后选择了冬青黑体及黑体-简作为 Mac 上的替代方案；最后使用文泉驿微米黑兼顾了 Linux 系统。</p><h2 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h2><p>鉴于淘宝网改版频率较频繁，这里截图保存了一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 12px&#x2F;1.5 tahoma,arial,&#39;Hiragino Sans GB&#39;,&#39;\5b8b\4f53&#39;,sans-serif;</span><br></pre></td></tr></table></figure><p>其实从图中明显看出淘宝网的导航及内容有着大量的衬线字体，鉴于淘宝网站大部分字号比较小，显示效果也还可以接受。代码中可以看出淘宝使用了<code>Tahoma</code>、<code>Arial</code>作为首选英文字体，中文字体首选了<code>冬青黑体</code>，由于 Win 下没有预装该款字体，所以显示出了后面的<code>宋体</code>（<code>5b8b4f53</code>）为汉字宋体用 unicode 表示的写法，不用<code>SimSun</code>是因为 Firefox 的某些版本和 Opera 不支持<code>SimSun</code>的写法）</p><h2 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;lucida grande&quot;, &quot;lucida sans unicode&quot;, lucida, helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>自认为简书的阅读体验很棒，我们看看简书所用的字体，简书优先选择了<code>lucida</code>家族的系列字体作为英文字体，该系列字体在 Mac 和 Win 上都是预装的，并且有着不俗的表现；中文字体方面将<code>冬青黑体</code>作为最优先使用的字体，同样考虑了 Linux 系统。</p><p>各大公司的字体设置大同小异，这里不再一一举例查看，有兴趣的可以自己多多查看。</p><h1 id="其他的一些注意点"><a href="#其他的一些注意点" class="headerlink" title="其他的一些注意点"></a>其他的一些注意点</h1><h2 id="字体何时需要添加引号"><a href="#字体何时需要添加引号" class="headerlink" title="字体何时需要添加引号"></a>字体何时需要添加引号</h2><p>当字体具体某个取值中若有一种样式名称包含空格，则需要用双引号或单引号表示，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Microsoft YaHei&quot;, &quot;Arial Narrow&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>如果书写中文字体名称为了保证兼容性也会添加引号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;黑体-简&quot;, &quot;微软雅黑&quot;, &quot;文泉驿微米黑&quot;;</span><br></pre></td></tr></table></figure><h2 id="引用外部字体"><a href="#引用外部字体" class="headerlink" title="引用外部字体"></a>引用外部字体</h2><p>大多数的中文字体由于版权原因不能随意使用，这里推荐一个免版权而且漂亮的中文字体<code>思源黑体</code>，该字体为 Adobe 与 Google 推出的一款开源字体， 有七种字体粗细（<code>ExtraLight</code>、<code>Light</code>、<code>Normal</code>、<code>Regular</code>、<code>Medium</code>、<code>Bold</code>和<code>Heavy</code>），完全支持日文、韩文、繁体中文和简体中文，字形优美，依稀记得小米公司好像有使用过。</p><p>鉴于中文字体的体积比较大（一般字库全一点的中文字体动辄几 Mb），所以较少人会使用外部字体，如果真的需要引入，也可以考虑通过工具根据页面文字的使用多少单独生成中文字体，以减小文件大小。</p><h1 id="最后，推荐写法"><a href="#最后，推荐写法" class="headerlink" title="最后，推荐写法"></a>最后，推荐写法</h1><p>由于每个人的审美不一样，钟爱的字体也会有所有不同，这里给出我个人的常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>另外推荐两个 github 上的关于中文字体和排版的项目：</p><ul><li><a href="https://github.com/zenozeng/fonts.css">Fonts.css – 跨平台中文字体解决方案</a></li><li><a href="https://github.com/sofish/typo.css">typo.css – 中文网页重设与排版：一致化浏览器排版效果</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家都知道，在不同操作系统、不同游览器里面默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同，那么如何设置字体显示效果会比较好呢？下面我们逐步的分析一下：&lt;/p&gt;
&lt;h1 id=&quot;首先我们看看各平台的默认字体情况&quot;&gt;&lt;a href=&quot;#首先我们看看</summary>
      
    
    
    
    <category term="前端" scheme="https://matthew84.cf/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://matthew84.cf/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
    <category term="前端" scheme="https://matthew84.cf/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://matthew84.cf/tags/CSS/"/>
    
    <category term="选择字体" scheme="https://matthew84.cf/tags/%E9%80%89%E6%8B%A9%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>不蒜子(busuanzi)不显示统计量</title>
    <link href="https://matthew84.cf/archives/fd317c05.html"/>
    <id>https://matthew84.cf/archives/fd317c05.html</id>
    <published>2020-11-03T07:09:26.000Z</published>
    <updated>2020-11-03T13:12:25.833Z</updated>
    
    <content type="html"><![CDATA[<p>部分live2d可能与不蒜子统计有冲突，出现此问题时，请查看网页源码引用统计id处是否被隐藏，一般网页上会自动加上display: none;自行选择性的使用。网友的解决方法，修改源码为以下，并引用修改后的js文件。不蒜子源码文件：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/live2d.webp"><br>修改为如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bszCaller, bszTag;</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e, a = !<span class="number">1</span>, b = [];</span><br><span class="line">    ready = <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a || <span class="string">&quot;interactive&quot;</span> === <span class="built_in">document</span>.readyState || <span class="string">&quot;complete&quot;</span> === <span class="built_in">document</span>.readyState ? c.call(<span class="built_in">document</span>) : b.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c.call(<span class="built_in">this</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> a = <span class="number">0</span>, c = b.length; c &gt; a; a++)</span><br><span class="line">            b[a].apply(<span class="built_in">document</span>);</span><br><span class="line">        b = []</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    e = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a || (a = !<span class="number">0</span>,</span><br><span class="line">        d.call(<span class="built_in">window</span>),</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener ? <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, e, !<span class="number">1</span>) : <span class="built_in">document</span>.attachEvent &amp;&amp; (<span class="built_in">document</span>.detachEvent(<span class="string">&quot;onreadystatechange&quot;</span>, e),</span><br><span class="line">        <span class="built_in">window</span> == <span class="built_in">window</span>.top &amp;&amp; (<span class="built_in">clearInterval</span>(c),</span><br><span class="line">        c = <span class="literal">null</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    <span class="built_in">document</span>.addEventListener ? <span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, e, !<span class="number">1</span>) : <span class="built_in">document</span>.attachEvent &amp;&amp; (<span class="built_in">document</span>.attachEvent(<span class="string">&quot;onreadystatechange&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        /loaded|complete/.test(<span class="built_in">document</span>.readyState) &amp;&amp; e()</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="built_in">window</span> == <span class="built_in">window</span>.top &amp;&amp; (c = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a || <span class="built_in">document</span>.documentElement.doScroll(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (b) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        e()</span><br><span class="line">    &#125;, <span class="number">5</span>)))</span><br><span class="line">&#125;(),</span><br><span class="line">bszCaller = &#123;</span><br><span class="line">    fetch: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="string">&quot;BusuanziCallback_&quot;</span> + <span class="built_in">Math</span>.floor(<span class="number">1099511627776</span> * <span class="built_in">Math</span>.random());</span><br><span class="line">        <span class="built_in">window</span>[c] = <span class="built_in">this</span>.evalCall(b),</span><br><span class="line">        a = a.replace(<span class="string">&quot;=BusuanziCallback&quot;</span>, <span class="string">&quot;=&quot;</span> + c),</span><br><span class="line">        scriptTag = <span class="built_in">document</span>.createElement(<span class="string">&quot;SCRIPT&quot;</span>),</span><br><span class="line">        scriptTag.type = <span class="string">&quot;text/javascript&quot;</span>,</span><br><span class="line">        scriptTag.defer = !<span class="number">0</span>,</span><br><span class="line">        scriptTag.src = a,</span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;HEAD&quot;</span>)[<span class="number">0</span>].appendChild(scriptTag)</span><br><span class="line">    &#125;,</span><br><span class="line">    evalCall: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">            ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    a(b), </span><br><span class="line">-                      <span class="comment">// 此处为修改的逻辑</span></span><br><span class="line">-                      scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">+                      <span class="keyword">if</span>(scriptTag != <span class="literal">null</span> &amp;&amp; scriptTag.parentElement != <span class="literal">null</span>)&#123;</span><br><span class="line">+                       scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">+                      &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (c) &#123;</span><br><span class="line">                    bszTag.hides()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">bszCaller.fetch(<span class="string">&quot;//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    bszTag.texts(a),</span><br><span class="line">    bszTag.shows()</span><br><span class="line">&#125;),</span><br><span class="line">bszTag = &#123;</span><br><span class="line">    bszs: [<span class="string">&quot;site_pv&quot;</span>, <span class="string">&quot;page_pv&quot;</span>, <span class="string">&quot;site_uv&quot;</span>],</span><br><span class="line">    texts: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&quot;busuanzi_value_&quot;</span> + b);</span><br><span class="line">            c &amp;&amp; (c.innerHTML = a[b])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    hides: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&quot;busuanzi_container_&quot;</span> + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = <span class="string">&quot;none&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    shows: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&quot;busuanzi_container_&quot;</span> + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = <span class="string">&quot;inline&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note warning flat"><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这是原帖<br><a href="https://removeif.github.io/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html">https://removeif.github.io/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</a><br>按照他的方法，并没有解决我的问题，也不知道为什么，然后我直接把出问题的代码删了，这是我更改后的<br><a href="https://cdn.jsdelivr.net/gh/long-zhi/static@master/js/busuanzi.pure.mini.js">https://cdn.jsdelivr.net/gh/long-zhi/static@master/js/busuanzi.pure.mini.js</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;部分live2d可能与不蒜子统计有冲突，出现此问题时，请查看网页源码引用统计id处是否被隐藏，一般网页上会自动加上display: none;自行选择性的使用。网友的解决方法，修改源码为以下，并引用修改后的js文件。不蒜子源码文件：&lt;br&gt;&lt;img src= &quot;/img/l</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="教程" scheme="https://matthew84.cf/categories/article/tutorial/"/>
    
    
    <category term="live2d" scheme="https://matthew84.cf/tags/live2d/"/>
    
    <category term="busuanzi" scheme="https://matthew84.cf/tags/busuanzi/"/>
    
    <category term="不蒜子" scheme="https://matthew84.cf/tags/%E4%B8%8D%E8%92%9C%E5%AD%90/"/>
    
    <category term="统计量" scheme="https://matthew84.cf/tags/%E7%BB%9F%E8%AE%A1%E9%87%8F/"/>
    
    <category term="常见问题" scheme="https://matthew84.cf/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>排序算法的 Python 实现以及时间复杂度分析</title>
    <link href="https://matthew84.cf/archives/42010ce.html"/>
    <id>https://matthew84.cf/archives/42010ce.html</id>
    <published>2020-11-03T06:43:00.000Z</published>
    <updated>2020-11-03T09:03:38.912Z</updated>
    
    <content type="html"><![CDATA[<p>我用 Python 实现了冒泡排序、选择排序、插入排序、归并排序、快速排序。然后简单讲了讲快速排序的优化，我们可以通过<strong>小数组采用插入排序</strong>来减少递归的开销；对于有一定顺序的数组，我采用<strong>三数取中</strong>来提高性能；对于包含大量重复数的数组，我用了<strong>三路快速排序</strong>来提高性能。<br>最后，我把这些排序算法应用在随机数组、升序数组、降序数组、包含大量重复数的数组上，比较了一下它们的耗时。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def BubbleSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        for j in range(len(nums)-i-1):</span><br><span class="line">            if nums[j] &gt; nums[j+1]:</span><br><span class="line">                exchange(nums,j,j+1)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>首先，找到数组中最小的那个元素，然后将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。然后在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在<strong>不断地选择剩余元素之中的最小者</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序体现的是一种分治思想（Divide and conquer），下面是其排序的步骤：</p><ol><li>将数组一分为二（Divide array into two halves）</li><li>对每部分进行递归式地排序（Recursively sort each half）</li><li>合并两个部分（Merge two halves）</li></ol><h2 id="merge-函数"><a href="#merge-函数" class="headerlink" title="merge () 函数"></a>merge () 函数</h2><p>具体步骤如下：</p><ol><li>给出原数组 a []，该数组的 low 到 mid，mid+1 到 high 的子数组是各自有序的。</li><li>将数组复制到辅助数组（auxiliary array）中，两部分数组的首元素分别以 i 和 j 为下标，给原数组首元素以 k 为下标。</li><li>比较 i 下标和 j 下标的元素，将较小值赋到 k 下标位置的元素内，然后对 k 和赋值的下标进行递增。</li><li>重复上述过程，直到比较完全部元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def merge(a,aux,low,mid,high):</span><br><span class="line">    i &#x3D; low</span><br><span class="line">    j &#x3D; mid+1</span><br><span class="line">    k &#x3D; 0</span><br><span class="line">    for k in range(low,high+1):</span><br><span class="line">        if i &gt; mid:</span><br><span class="line">            a[k] &#x3D; aux[j]</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        elif j &gt; high:</span><br><span class="line">            a[k] &#x3D; aux[i]</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            if aux[i] &gt; aux[j]:</span><br><span class="line">                a[k] &#x3D; aux[j]</span><br><span class="line">                j +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                a[k] &#x3D; aux[i]</span><br><span class="line">                i +&#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort () 函数"></a>sort () 函数</h2><p>我们要对数组<code>a[low..high]</code> 进行排序，先将它分为<code>a[low..mid]</code> 和<code>a[mid+1..high]</code>两部分，分别<strong>递归调用</strong>将它们单独排序，最后将有序的子数组归并为最终的排序结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,aux,low,high):</span><br><span class="line">    # 退出条件</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line">    sort(a,aux,low,mid)</span><br><span class="line">    sort(a,aux,mid+1,high)</span><br><span class="line">    merge(a,aux,low,mid,high)      </span><br></pre></td></tr></table></figure><h2 id="MergeSort-函数"><a href="#MergeSort-函数" class="headerlink" title="MergeSort () 函数"></a>MergeSort () 函数</h2><p>为了保证归并排序函数 MergeSort () 输入只有未排序的数组，这里调用前面的辅助函数 sort ()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def MergeSort(nums):</span><br><span class="line">    aux &#x3D; nums.copy()</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,aux,low,high)</span><br><span class="line">    return nums      </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O (nlogn)</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。</p><div class="note icon simple"><i class="note-icon fas fa-bullhorn"></i><p>分治策略指的是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p></div><p>下面是一个示例：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/plxupython1.webp"></p><div class="note simple"><p>来源：<a href="https://www.cnblogs.com/sfencs-hcy/p/10602598.html">快速排序 python 实现</a></p></div><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>下面的代码短小利于理解，但是空间复杂度大，使用了三个列表解析式，而且每次选取进行比较时需要遍历整个序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def QuickSort(a):</span><br><span class="line">    if len(a) &lt; 2:</span><br><span class="line">        return a</span><br><span class="line">    else:</span><br><span class="line">        pivot &#x3D; a[0]</span><br><span class="line">        less_than_pivot &#x3D; [x for x in a if x &lt; pivot]</span><br><span class="line">        more_than_pivot &#x3D; [x for x in a if x &gt; pivot]</span><br><span class="line">        pivot_list &#x3D; [x for x in a if x &#x3D;&#x3D; pivot]</span><br><span class="line">        return QuickSort(less_than_pivot) + pivot_list + QuickSort(more_than_pivot)      </span><br></pre></td></tr></table></figure><h2 id="原地排序实现"><a href="#原地排序实现" class="headerlink" title="原地排序实现"></a>原地排序实现</h2><pre><code>1. 切分 ——partition ()</code></pre><p>切分方法：先随意地取<code>a[low]</code>作为切分元素（即那个将会被排定的元素），然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素是没有排定的，因此我们交换它们的位置。如此继续，当两个指针相遇时，我们只需要将切分元素<code>a[low]</code>和左子元素最右侧的元素<code>a[j]</code>交换然后返回 j 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">    i &#x3D; low       # 循环内i&#x3D;i+1</span><br><span class="line">    j &#x3D; high + 1  # 循环内j&#x3D;j-1</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        i +&#x3D; 1   # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[i] &lt; a[low] and i &lt; high:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        j -&#x3D; 1   # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[j] &gt; a[low] and j &gt; low:</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 指针相遇后，j所在的元素小于low，进行互换</span><br><span class="line">    exchange(a,low,j)</span><br><span class="line">    </span><br><span class="line">    return j      </span><br></pre></td></tr></table></figure><p>这里有个细节需要注意下，这个代码相比我最初的代码改变了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">-   i &#x3D; low + 1</span><br><span class="line">+   i &#x3D; low       # 循环内i&#x3D;i+1</span><br><span class="line">-   j &#x3D; high</span><br><span class="line">+   j &#x3D; high + 1  # 循环内j&#x3D;j-1</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">+       i +&#x3D; 1   # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[i] &lt; a[low] and i &lt; high:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">+       j -&#x3D; 1   # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[j] &gt; a[low] and j &gt; low:</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 指针相遇后，j所在的元素小于low，进行互换</span><br><span class="line">    exchange(a,low,j)</span><br><span class="line">    </span><br><span class="line">    return j     </span><br></pre></td></tr></table></figure><p>如果没有这些代码，当碰到<code>[2,2,2]</code>这样的情况时，i 和 j 一直不会改变，永远无法满足<code>if i &gt;= j</code>，然后函数就一直在<code>while True</code>里边死循环。</p><pre><code>2. sort()函数</code></pre><p>快速排序递归地将子数组<code>a[low..high]</code>排序，先用<code>partition()</code>方法将<code>a[j]</code>放到一个合适位置，然后再用递归调用将其他位置的元素排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)     </span><br></pre></td></tr></table></figure><pre><code>3. QuickSort () 函数</code></pre><p>为了保证快速排序函数 QuickSort () 输入只有未排序的数组，这里调用前面的辅助函数 sort ()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def QuickSort(nums):</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,low,high)</span><br><span class="line">    return nums      </span><br></pre></td></tr></table></figure><h2 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h2><ul><li>最优情况：每一次的基准值都正好为序列的中位数，时间复杂度为 nlogn</li><li>最坏情况：<strong>每一次的基准值都恰好是序列的最大值或最小值，时间复杂度为 n^2</strong>。有意思的是如果每次选第一个数做基准值，但每次这个数又是最小值，那么序列本身就是有序的，但时间复杂度也是最高的<br>因此，要想优化时间复杂度，<strong>关键在于基准值的选择</strong>。</li></ul><h2 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h2><pre><code>1. 优化小数组效率</code></pre><p><strong>对于规模很小的情况，快速排序的优势并不明显（可能没有优势），而递归型的算法还会带来额外的开销</strong>。于是对于这类情况可以选择非递归型的算法来替代。</p><p>那就有两个问题：多小的数组算小数组？替换的算法是什么？</p><p>通常这个阈值设定为 10，替换的算法一般是插入排序。</p><p>下面是 Python 实现，这里只需要在 sort () 函数中加一个数组大小判断即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)      </span><br></pre></td></tr></table></figure><pre><code>2. 合理选择 pivot</code></pre><p>前面也讨论过，直接选择分区的第一个或最后一个元素做 pivot 是不合适的。对于已经排好序，或者接近排好序的情况，会进入最差情况，时间复杂度退化到 n^2。</p><p>pivot 选取的理想情况是：让分区中比 pivot 小的元素数量和比 pivot 大的元素数量差不多。较常用的做法是三数取中（ median of three ），即从第一项、最后一项、中间一项中取中位数作为 pivot。当然这并不能完全避免最差情况的发生。所以很多时候会采取更小心、更严谨的 pivot 选择方案（对于大数组特别重要）。比如先把大数组平均切分成左中右三个部分，每个部分用三数取中得到一个中位数，再从得到的三个中位数中找出中位数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def get_median(nums,low,high):</span><br><span class="line">    # 计算数组中间的元素的下标</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    # 目标: arr[mid] &lt;&#x3D; arr[high] </span><br><span class="line">    if nums[mid] &gt; nums[high]:</span><br><span class="line">        exchange(nums,mid,high)</span><br><span class="line">    # 目标: arr[low] &lt;&#x3D; arr[high]</span><br><span class="line">    if nums[low] &gt; nums[high]:</span><br><span class="line">        exchange(nums,low,high)</span><br><span class="line">    # 目标: arr[low] &gt;&#x3D; arr[mid]</span><br><span class="line">    if nums[low] &lt; nums[mid]:</span><br><span class="line">        exchange(nums,low,mid)</span><br><span class="line">    </span><br><span class="line">    # 此时，arr[mid] &lt;&#x3D; arr[low] &lt;&#x3D; arr[high]，low的位置上保存这三个位置中间的值</span><br><span class="line">    return nums[low]</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # 三数取中(median of three)，low的位置上保存这三个位置中间的值</span><br><span class="line">    _ &#x3D; get_median(a,low,high)</span><br><span class="line"></span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)      </span><br></pre></td></tr></table></figure><pre><code>3. 处理重复元素问题</code></pre><p>当一个数组里的元素全部一样大（或者存在大量相同元素）会令快速排序进入最差情况，因为不管怎么选 pivot，都会使分区结果一边很大一边很小。</p><p>为了解决这个问题，我们需要修改分区过程，思路跟上面说的两路分区（基本的快排）类似，只是现在我们需要小于 pivot、等于 pivot、大于 pivot 三个分区。</p><p>举个例子，待分割序列：<code>6 4 6 7 1 6 7 6 8 6</code>，其中<code>pivot=6</code>：</p><ul><li>未对与 key 元素相等处理的划分结果：<code>1 4 6 6 7 6 7 6 8 6</code><ul><li>下次的两个子序列为：<code>1 4 6</code> 和 <code>7 6 7 6 8 6</code></li></ul></li><li>对与 key 元素相等处理的划分结果：<code>1 4 6 6 6 6 6 7 8 7</code><ul><li>下次的两个子序列为：<code>1 4</code> 和 <code>7 8 7</code></li></ul></li></ul><p>经过对比，我们可以看出，<strong>在一次划分后，把与 key 相等的元素聚在一起，能减少迭代次数，效率会提高不少</strong>。</p><p>具体过程：</p><p>如下图，我们可以设置四个游标，左端 p、i，右端 j、q。i、j 的作用跟之前两路划分时候的左右游标相同，就是从两端向中间遍历序列，并将遍历到的元素与 pivot 比较，如果等于 pivot，则移到两端（i 对应的元素移到左端，j 对应的元素移到右端。移动的方式就是拿此元素和 a 或 d 对应的元素进行交换，所以 p 和 q 的作用就是记录等于 pivot 的元素移动过后的边界），反之，如果大于或小于 pivot，还按照之前两路划分的方式进行移动。这样一来，中间部分就和两路划分相同，两头是等于 pivot 的部分，我们只需要将这两部分移动到中间即可。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/plxupython2.webp"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">    p &#x3D; low + 1</span><br><span class="line">    i &#x3D; low + 1</span><br><span class="line">    j &#x3D; high</span><br><span class="line">    q &#x3D; high</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        while a[i] &lt;&#x3D; a[low] and i &lt; high:</span><br><span class="line">            # 与pivot相等的元素将其交换到p所在的位置</span><br><span class="line">            if a[i] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,p,i)</span><br><span class="line">                p +&#x3D; 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        while a[j] &gt;&#x3D; a[low] and j &gt; low:</span><br><span class="line">            # 与pivot相等的元素将其交换到q所在的位置</span><br><span class="line">            if a[j] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,j,q)</span><br><span class="line">                q -&#x3D; 1</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    i -&#x3D; 1</span><br><span class="line">    p -&#x3D; 1</span><br><span class="line">    while p &gt;&#x3D; low:</span><br><span class="line">        exchange(a, i, p)</span><br><span class="line">        i -&#x3D; 1</span><br><span class="line">        p -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    j +&#x3D; 1</span><br><span class="line">    q +&#x3D; 1</span><br><span class="line">    while q &lt;&#x3D; high:</span><br><span class="line">        exchange(a, q, j)</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        q +&#x3D; 1</span><br><span class="line">    </span><br><span class="line">    return i,j      </span><br></pre></td></tr></table></figure><p>下面是 sort () 函数，这里我只写了修改的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,low,high):</span><br><span class="line">    </span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    i,j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,i)</span><br><span class="line">    sort(a,j,high)      </span><br></pre></td></tr></table></figure><h2 id="整体代码实现"><a href="#整体代码实现" class="headerlink" title="整体代码实现"></a>整体代码实现</h2><p>下面是经过优化的快速排序代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br><span class="line"></span><br><span class="line">def partition(a,low,high):</span><br><span class="line">    p &#x3D; low + 1</span><br><span class="line">    i &#x3D; low + 1</span><br><span class="line">    j &#x3D; high</span><br><span class="line">    q &#x3D; high</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        while a[i] &lt;&#x3D; a[low] and i &lt; high:</span><br><span class="line">            # 与pivot相等的元素将其交换到p所在的位置</span><br><span class="line">            if a[i] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,p,i)</span><br><span class="line">                p +&#x3D; 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        while a[j] &gt;&#x3D; a[low] and j &gt; low:</span><br><span class="line">            # 与pivot相等的元素将其交换到q所在的位置</span><br><span class="line">            if a[j] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,j,q)</span><br><span class="line">                q -&#x3D; 1</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    i -&#x3D; 1</span><br><span class="line">    p -&#x3D; 1</span><br><span class="line">    while p &gt;&#x3D; low:</span><br><span class="line">        exchange(a, i, p)</span><br><span class="line">        i -&#x3D; 1</span><br><span class="line">        p -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    j +&#x3D; 1</span><br><span class="line">    q +&#x3D; 1</span><br><span class="line">    while q &lt;&#x3D; high:</span><br><span class="line">        exchange(a, q, j)</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        q +&#x3D; 1</span><br><span class="line">    </span><br><span class="line">    return i,j</span><br><span class="line"></span><br><span class="line">def get_median(nums,low,high):</span><br><span class="line">    # 计算数组中间的元素的下标</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    # 目标: arr[mid] &lt;&#x3D; arr[high] </span><br><span class="line">    if nums[mid] &gt; nums[high]:</span><br><span class="line">        exchange(nums,mid,high)</span><br><span class="line">    # 目标: arr[low] &lt;&#x3D; arr[high]</span><br><span class="line">    if nums[low] &gt; nums[high]:</span><br><span class="line">        exchange(nums,low,high)</span><br><span class="line">    # 目标: arr[low] &gt;&#x3D; arr[mid]</span><br><span class="line">    if nums[low] &lt; nums[mid]:</span><br><span class="line">        exchange(nums,low,mid)</span><br><span class="line">    </span><br><span class="line">    # 此时，arr[mid] &lt;&#x3D; arr[low] &lt;&#x3D; arr[high]，low的位置上保存这三个位置中间的值</span><br><span class="line">    return nums[low]</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # 三数取中(median of three)，low的位置上保存这三个位置中间的值</span><br><span class="line">    _ &#x3D; get_median(a,low,high)</span><br><span class="line"></span><br><span class="line">    i,j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,i)</span><br><span class="line">    sort(a,j,high)</span><br><span class="line"></span><br><span class="line">def QuickSort3Ways(nums):</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,low,high)</span><br><span class="line">    return nums</span><br><span class="line"></span><br><span class="line">nums &#x3D; [4,5,6,1,2,3,3,3,1,2]</span><br><span class="line">print(QuickSort(nums))     </span><br></pre></td></tr></table></figure><h1 id="快速排序和归并排序对比"><a href="#快速排序和归并排序对比" class="headerlink" title="快速排序和归并排序对比"></a>快速排序和归并排序对比</h1><p>快速排序和归并排序是互补的：</p><ul><li>归并排序：<ol><li>将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；</li><li>递归调用发生在处理整个数组之前；</li><li>一个数组被等分为两半。</li></ol></li><li>快速排序：<ol><li>当两个子数组都有序时，整个数组也就自然有序了；</li><li>递归调用发生在处理整个数组之后；</li><li>切分（partition）的位置取决于数组的内容。</li></ol></li></ul><h1 id="各大排序算法测试"><a href="#各大排序算法测试" class="headerlink" title="各大排序算法测试"></a>各大排序算法测试</h1><h2 id="计时函数"><a href="#计时函数" class="headerlink" title="计时函数"></a>计时函数</h2><p>不同数据集可以用同一个计时函数，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 计时函数</span><br><span class="line">def count_time(a,sortname):</span><br><span class="line">    time_start &#x3D; time.time()</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;BubbleSort&#39;:</span><br><span class="line">        BubbleSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;SelectSort&#39;:</span><br><span class="line">        SelectSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;InsertSort&#39;:</span><br><span class="line">        InsertSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;MergeSort&#39;:</span><br><span class="line">        MergeSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;QuickSort&#39;:</span><br><span class="line">        QuickSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;QuickSort3Ways&#39;:</span><br><span class="line">        QuickSort3Ways(a)</span><br><span class="line">    time_end &#x3D; time.time()</span><br><span class="line">    return (time_end - time_start)      </span><br></pre></td></tr></table></figure><h2 id="随机数据集"><a href="#随机数据集" class="headerlink" title="随机数据集"></a>随机数据集</h2><p>随机数据生成器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime      </span><br></pre></td></tr></table></figure><p>这里我们生成一个长度为 5000 的数组，然后重复测试 10 次，最后计算各个排序算法用时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">length &#x3D; 5000</span><br><span class="line">numberOfArrays &#x3D; 10</span><br><span class="line"></span><br><span class="line">print(&quot;BubbleSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;BubbleSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;SelectSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;SelectSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;InsertSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;InsertSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;MergeSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;MergeSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;QuickSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;QuickSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;QuickSort3Ways&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;QuickSort3Ways&#39;,length,numberOfArrays))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">30.023681640625</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.03202223777771</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">24.185371160507202</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.1900651454925537</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">0.1554875373840332</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.19011521339416504</span><br></pre></td></tr></table></figure><h2 id="降序数据集"><a href="#降序数据集" class="headerlink" title="降序数据集"></a>降序数据集</h2><p>这里我们看下这些排序算法在降序数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+       a.sort(reverse &#x3D; True)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>这里如果生成一个长度为 10000 的数组，快速排序会出现<code>RecursionError: maximum recursion depth exceeded in comparison</code>错误。这个因为 Python 中默认的最大递归深度是 989。解决方案：<strong>手动设置递归调用深度</strong>，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">+import sys</span><br><span class="line"></span><br><span class="line">+sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">        a.sort(reverse &#x3D; True)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>数组大小改变为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">45.00776267051697</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.393858909606934</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">48.275355100631714</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.18087530136108398</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">14.895536661148071</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.10853052139282227</span><br></pre></td></tr></table></figure><h2 id="升序数据集"><a href="#升序数据集" class="headerlink" title="升序数据集"></a>升序数据集</h2><p>这里我们看下这些排序算法在升序数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+       a.sort(reverse &#x3D; False)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>同样的，这里数组大小为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">14.935291051864624</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.371372699737549</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">0.008459329605102539</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.15901756286621094</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">16.011647939682007</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.10053849220275879</span><br></pre></td></tr></table></figure><h2 id="含有大量重复数的数组"><a href="#含有大量重复数的数组" class="headerlink" title="含有大量重复数的数组"></a>含有大量重复数的数组</h2><p>这里我们看下这些排序算法在含有大量重复数的数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">-           a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+           a.append(random.randint(999990, 1000000))  # 测试数据范围            </span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>同样的，这里数组大小为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">28.813392877578735</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.362754821777344</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">22.454782247543335</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.1563563346862793</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">0.15424251556396484</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.08862972259521484</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center"></th><th align="center">BubbleSort</th><th>SelectSort</th><th>InsertSort</th><th>MergeSort</th><th>QuickSort</th><th>QuickSort3Ways</th></tr></thead><tbody><tr><td align="center"> 随机数据集</td><td align="center"> 30.023</td><td>11.032</td><td>24.185</td><td>0.190</td><td>0.155</td><td>0.190</td></tr><tr><td align="center"> 升序数据集</td><td align="center"> 14.935</td><td>11.371</td><td><strong>0.008</strong></td><td>0.159</td><td><strong>16.011</strong></td><td>0.100</td></tr><tr><td align="center"> 降序数据集</td><td align="center"> 45.007</td><td>11.393</td><td>48.275</td><td>0.180</td><td><strong>14.895</strong></td><td>0.108</td></tr><tr><td align="center"> 大量重复数的数据集</td><td align="center"> 28.813</td><td>11.362</td><td>22.454</td><td>0.156</td><td>0.154</td><td><strong>0.088</strong></td></tr></tbody></table>经过优化后的三路快速排序在升序、降序、包含大量重复数的情况下表现均非常优异。]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我用 Python 实现了冒泡排序、选择排序、插入排序、归并排序、快速排序。然后简单讲了讲快速排序的优化，我们可以通过&lt;strong&gt;小数组采用插入排序&lt;/strong&gt;来减少递归的开销；对于有一定顺序的数组，我采用&lt;strong&gt;三数取中&lt;/strong&gt;来提高性能；对于</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="算法" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="计算机基础" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="算法" scheme="https://matthew84.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>jsDelivr为静态文件加速</title>
    <link href="https://matthew84.cf/archives/c57ab7e7.html"/>
    <id>https://matthew84.cf/archives/c57ab7e7.html</id>
    <published>2020-11-03T06:28:36.000Z</published>
    <updated>2020-11-03T13:09:19.776Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Github是目前最大的项目的托管平台！19年年初的时候被微软收购了。免费套餐还支持私有仓库了！还真不错哇！可惜国内访问比较慢！！<br>jsDelivr是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。<br>针对Github提供免费的CDN加速，在国内使用的是网宿的CDN加速！访问速度一点儿都不慢！<br>那么我们就可以好好利用一下！下面博主就分享下使用过程把！</p></div><a id="more"></a><div class="note warning flat"><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li><strong>目前GITHUB仓库容量是没有上限的！不过官方推荐在1G以内！</strong></li><li><strong>仓库单个文件50M会收到警告，大于100M会被拒绝！</strong>   </li><li><strong>jsDelivr仅能针对50M以下的文件CDN加速！</strong><br>这样看来我们完全可以利用它来存一些静态文件了，如JS,CSS,图片等等！   </li></ul></div><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1）当然你得先有一个GITHUB账号！<br>2）新建一个仓库！名称随便即可！<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/jsdelivr01.webp"><br>3）我们新建一个js文件，然后提交！你也可以利用git本地推送！<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/jsdelivr02.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/jsdelivr03.webp"><br>4）然后访问：<a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D@latest/">https://cdn.jsdelivr.net/gh/用户名/仓库名@latest/</a> 即可访问你的内容了！<br>如本文示例：<a href="https://cdn.jsdelivr.net/gh/long-zhi/static@latest/">https://cdn.jsdelivr.net/gh/long-zhi/static@latest/</a><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/jsdelivr04.webp"></p><div class="note warning flat"><h2 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h2><ul><li>链接最后的/斜杠不能少</li><li>可以不用commit release，直接访问链接</li><li>仓库名@latest（或者master）都是可以的，由于有缓存，所以我建议是latest，这样提交更改后可以访问到最新的文件 </li></ul></div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Github是目前最大的项目的托管平台！19年年初的时候被微软收购了。免费套餐还支持私有仓库了！还真不错哇！可惜国内访问比较慢！！&lt;br&gt;jsDelivr是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。&lt;br&gt;针对Github提供免费的CDN加速，在国内使用的是网宿的CDN加速！访问速度一点儿都不慢！&lt;br&gt;那么我们就可以好好利用一下！下面博主就分享下使用过程把！&lt;/p&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="教程" scheme="https://matthew84.cf/categories/article/tutorial/"/>
    
    
    <category term="github" scheme="https://matthew84.cf/tags/github/"/>
    
    <category term="jsdelivr" scheme="https://matthew84.cf/tags/jsdelivr/"/>
    
    <category term="静态资源" scheme="https://matthew84.cf/tags/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"/>
    
    <category term="CDN" scheme="https://matthew84.cf/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>css实现鼠标悬停图片放大</title>
    <link href="https://matthew84.cf/archives/a595705d.html"/>
    <id>https://matthew84.cf/archives/a595705d.html</id>
    <published>2020-11-03T03:45:09.000Z</published>
    <updated>2020-11-03T13:07:02.252Z</updated>
    
    <content type="html"><![CDATA[<p>代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;  </span><br><span class="line">* &#123;  </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;  </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;  </span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;微软雅黑&quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.avatar</span>&#123;  </span><br><span class="line"><span class="attribute">display</span>: block;  </span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;  </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;  </span><br><span class="line"><span class="attribute">overflow</span>: hidden;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.avatar</span> <span class="selector-tag">img</span>&#123;  </span><br><span class="line"><span class="attribute">display</span>: block;  </span><br><span class="line"><span class="attribute">border</span>: <span class="number">0</span>;  </span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;  </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);  </span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;  </span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);  </span><br><span class="line"><span class="attribute">-webkit-transform</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="selector-class">.avatar</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span>&#123;  </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.3</span>);  </span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;  </span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">1.3</span>);  </span><br><span class="line"><span class="attribute">-webkit-transform</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;/style&gt;  </span><br></pre></td></tr></table></figure><a id="more"></a><p>解析：<br>transform:scale()可以实现按比例放大或者缩小功能。<br>transition允许CSS的属性值在一定的时间区间内平滑过渡。<br>可以调节放大倍数以及放大过程所用时间。<br>效果：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/test01.webp"></p>]]></content>
    
    
    <summary type="html">css实现鼠标悬停图片放大</summary>
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="教程" scheme="https://matthew84.cf/categories/article/tutorial/"/>
    
    
    <category term="css" scheme="https://matthew84.cf/tags/css/"/>
    
    <category term="悬停" scheme="https://matthew84.cf/tags/%E6%82%AC%E5%81%9C/"/>
    
    <category term="图片" scheme="https://matthew84.cf/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>deepin装回windows系统</title>
    <link href="https://matthew84.cf/archives/aacea3b.html"/>
    <id>https://matthew84.cf/archives/aacea3b.html</id>
    <published>2020-11-03T00:44:10.000Z</published>
    <updated>2020-11-03T13:08:58.585Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前网上无意间看到deepin这个国产pc操作系统，初见deepin时给人一种初恋般的怦然心动的感觉。正好这时家里有一台5年前的笔记本电脑，安装windows已经能感到明显的卡顿，所以我在笔记本上安装上了deepin。安装完后，界面颜值真是秒杀windows，而流畅度相比之前安装的windows7也有肉眼可见的提升。有人要问了，这个系统这么好，那你为啥还要装回windows了？说到这里就要说到国产操作系统的通病了：生态。由于一些工作软件在deepin上的匮乏，用wine安装windows程序体验不好，所以索性直接安装回windows了。</p></div><a id="more"></a><div class="note default flat"><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>请参考别处或者我的上一篇博客</p></div><div class="note primary flat"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>完成以上步骤之后，从U盘启动windows7引导程序，继续将系统安装在C盘的时候报错：无法在驱动器0的分区安装windows。<br>原因分析：<br>deepin本质上是linux系统，安装deepin时默认都是UEFI引导和GPT硬盘，传统的引导方式为Legacy引导和MBR硬盘，UEFI必须跟GPT对应，同理Legacy必须跟MBR对应。如果BIOS开启UEFI，而硬盘分区表格式为MBR则无法安装；BIOS关闭UEFI而硬盘分区表格式为GPT也是无法安装Windows。总而言之，言而总之就是一句话：由于linux和windows差异，安装的硬盘格式不同，导致原来安装linux的硬盘格式无法安装windows系统，所以我们需要更改硬盘格式为MBR。</p></div><div class="note warning flat"><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li><strong>分区表转换是针对整块硬盘，一块硬盘包含C、D、E盘等若干分区；</strong></li><li><strong>GPT与MBR之间的转换会清空硬盘所有数据，需转移硬盘数据；</strong>   </li></ul></div><div class="note success flat"><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ul><li><strong>在安装系统界面或提示无法安装界面，按下Shift+F10打开命令提示符(如果是笔记本电脑，可能需要加上Fn)</strong></li><li><strong>输入diskpart，按回车执行</strong><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/001.png"></li><li><strong>进入DISKPART命令模式，输入list disk回车，列出当前磁盘信息</strong></li><li><strong>要转换磁盘0格式，则输入select disk 0回车，再输入clean，删除磁盘分区</strong><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/002.png"></li><li><strong>输入convert mbr，回车，将磁盘转换为MBR</strong><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/003.png"></li><li><strong>输入create partition primary size = 102400，创建100G的主分区，1G=1024M；这里的主分区相当于我们的C盘，大小可以随意指定，剩下的硬盘空间在安装完系统之后，进入系统在磁盘管理中可以自行分配</strong><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/004.png"></li><li><strong>输入format fs=ntfs quick回车，格式化主分区；windows磁盘的文件系统一般都是NTFS格式，所以这里我们要格式化为NTFS格式</strong><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/005.png"></li><li><strong>看到命令提示符中显示【成功格式化该卷】的时候说明就成功了</strong></li><li><strong>最后输入exit回车退出命令提示符，可以愉快的继续安装windows系统了</strong></li></ul></div><div class="note danger flat"><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>其实从系统美观性和流畅性来说，deepin都不比windows差。奈何windows系统经过多年的沉淀，在生态上可谓秒杀一切的存在，基本所以常用的不常用的或者是些稀奇古怪的应用都能在windows平台找到。反观deepin在这方面则弱势很多，这也是我换回windows的主要原因。但是从deepin的身上我看到国产操作系统的坚持和努力，真心希望能有一天我们的操作系统生态能日益成熟，到时候我们将不再受制于人。</p></div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前网上无意间看到deepin这个国产pc操作系统，初见deepin时给人一种初恋般的怦然心动的感觉。正好这时家里有一台5年前的笔记本电脑，安装windows已经能感到明显的卡顿，所以我在笔记本上安装上了deepin。安装完后，界面颜值真是秒杀windows，而流畅度相比之前安装的windows7也有肉眼可见的提升。有人要问了，这个系统这么好，那你为啥还要装回windows了？说到这里就要说到国产操作系统的通病了：生态。由于一些工作软件在deepin上的匮乏，用wine安装windows程序体验不好，所以索性直接安装回windows了。&lt;/p&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="教程" scheme="https://matthew84.cf/categories/article/tutorial/"/>
    
    
    <category term="win10" scheme="https://matthew84.cf/tags/win10/"/>
    
    <category term="deepin" scheme="https://matthew84.cf/tags/deepin/"/>
    
    <category term="重装系统" scheme="https://matthew84.cf/tags/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
