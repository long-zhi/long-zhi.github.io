<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longzhiの个人博客</title>
  
  
  <link href="https://matthew84.cf/atom.xml" rel="self"/>
  
  <link href="https://matthew84.cf/"/>
  <updated>2020-11-03T12:40:23.909Z</updated>
  <id>https://matthew84.cf/</id>
  
  <author>
    <name>longzhi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原码、反码、补码详解</title>
    <link href="https://matthew84.cf/archives/c1974a4.html"/>
    <id>https://matthew84.cf/archives/c1974a4.html</id>
    <published>2020-11-03T12:25:58.000Z</published>
    <updated>2020-11-03T12:40:23.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h1><h2 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h2><p>一个数在计算机中的<strong>二进制表示形式</strong>，叫做这个数的机器数。机器数是<strong>带符号的</strong>，在计算机用一个数的最高位存放符号，正数为 0，负数为 1。</p><p>比如，十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 00000011。如果是 -3 ，就是 10000011。这里的 00000011 和 10000011 就是机器数。</p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位 1 代表负，其真正数值是 -3 而不是形式值 131（10000011 转换成十进制等于 131）。为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><h1 id="原码、反码、补码的基础概念和计算方法"><a href="#原码、反码、补码的基础概念和计算方法" class="headerlink" title="原码、反码、补码的基础概念和计算方法"></a>原码、反码、补码的基础概念和计算方法</h1><p>原码、反码、补码是机器存储一个具体数字的编码方式。</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是 8 位二进制：</p><ul><li><code>[+1]原 = 0000 0001</code></li><li><code>-1]原 = 1000 0001</code></li></ul><p>因为第一位是符号位，所以 8 位二进制数的取值范围就是：<code>[1111 1111 , 0111 1111]</code>，即<code>[-127 , 127]</code>。</p><p>原码是人脑最容易理解和计算的表示方式。</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><ul><li>正数的反码是其本身。</li><li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</li></ul><p>下面是一个例子：</p><ul><li><code>[+1] = [00000001]原 = [00000001]反</code></li><li><code>[-1] = [10000001]原 = [11111110]反</code></li></ul><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><ul><li>正数的补码就是其本身。</li><li>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 + 1。(即在反码的基础上 + 1)</li></ul><p>下面是一个例子：</p><ul><li><code>[+1] = [00000001]原 = [00000001]反 = [00000001]补</code></li><li><code>[-1] = [10000001]原 = [11111110]反 = [11111111]补</code></li></ul><p>对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码再计算其数值。</p><h1 id="原码、反码、补码的由来"><a href="#原码、反码、补码的由来" class="headerlink" title="原码、反码、补码的由来"></a>原码、反码、补码的由来</h1><p>人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别” 符号位” 显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即:<code>1 - 1 = 1 + (-1) = 0</code>。因此，机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><p>原码：</p><table><thead><tr><th>正数</th><th>正数（原码）</th><th>负数</th><th>负数（原码）</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td>0</td><td>1000</td></tr><tr><td>1</td><td>0001</td><td>-1</td><td>1001</td></tr><tr><td>2</td><td>0010</td><td>-2</td><td>1010</td></tr><tr><td>3</td><td>0011</td><td>-3</td><td>1011</td></tr><tr><td>4</td><td>0100</td><td>-4</td><td>1100</td></tr><tr><td>5</td><td>0101</td><td>-5</td><td>1101</td></tr><tr><td>6</td><td>0110</td><td>-6</td><td>1110</td></tr><tr><td>7</td><td>0111</td><td>-7</td><td>1111</td></tr></tbody></table><p>我们希望 + 1 和 - 1 相加是 0，但计算机只能算出<code>0001+1001=1010 (-2)</code>。</p><p>为了解决 “正负相加等于 0” 的问题，在 “原码” 的基础上，人们发明了 “反码”：</p><table><thead><tr><th>正数</th><th>正数（反码）</th><th>负数</th><th>负数（反码）</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td>0</td><td>1111</td></tr><tr><td>1</td><td>0001</td><td>-1</td><td>1110</td></tr><tr><td>2</td><td>0010</td><td>-2</td><td>1101</td></tr><tr><td>3</td><td>0011</td><td>-3</td><td>1100</td></tr><tr><td>4</td><td>0100</td><td>-4</td><td>1011</td></tr><tr><td>5</td><td>0101</td><td>-5</td><td>1010</td></tr><tr><td>6</td><td>0110</td><td>-6</td><td>1001</td></tr><tr><td>7</td><td>0111</td><td>-7</td><td>1000</td></tr></tbody></table><p>“原码” 变成 “反码” 时，完美的解决了 “正负相加等于 0” 的问题，过去的 + 1 和 - 1 相加，变成了<code>0001+1101=1111</code>，刚好反码表示方式中，1111 象征 - 0。</p><p>人们总是进益求精，历史遗留下来的问题 —— 有两个零存在，+0 和 -0。我们希望只有一个 0，所以发明了” 补码”，同样是针对” 负数” 做处理的。从原来” 反码” 的基础上，补充一个新的代码，（+1）。</p><table><thead><tr><th>正数</th><th>正数（补码）</th><th>负数</th><th>负数（补码）</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td><del>0</del></td><td><del>0000</del></td></tr><tr><td>1</td><td>0001</td><td>-1</td><td>1111</td></tr><tr><td>2</td><td>0010</td><td>-2</td><td>1110</td></tr><tr><td>3</td><td>0011</td><td>-3</td><td>1101</td></tr><tr><td>4</td><td>0100</td><td>-4</td><td>1100</td></tr><tr><td>5</td><td>0101</td><td>-5</td><td>1011</td></tr><tr><td>6</td><td>0110</td><td>-6</td><td>1010</td></tr><tr><td>7</td><td>0111</td><td>-7</td><td>1001</td></tr><tr><td></td><td></td><td>-8</td><td>1000</td></tr></tbody></table>有得必有失，在补一位 1 的时候，要丢掉最高位。我们要处理” 反码” 中的”-0”，当 1111 再补上一个 1 之后，变成了 10000，丢掉最高位就是 0000，刚好和左边正数的 0 完美融合。这样就解决了 + 0 和 - 0 同时存在的问题。<p>另外” 正负数相加等于 0” 的问题，同样得到满足，举例，3 和（-3）相加，<code>0011 + 1101 =10000</code>，丢掉最高位，就是 0000（0）。</p><p>以上就是” 补码” 的存在方式。</p>]]></content>
    
    
    <summary type="html">本文简单总结了原码、反码、补码的计算以及由来。</summary>
    
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机原理" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机原理" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>P2P 技术科普</title>
    <link href="https://matthew84.cf/archives/16c5940f.html"/>
    <id>https://matthew84.cf/archives/16c5940f.html</id>
    <published>2020-11-03T11:01:42.000Z</published>
    <updated>2020-11-03T12:28:07.363Z</updated>
    
    <content type="html"><![CDATA[<p><code>迅雷，msn，skype，pplive, ppstream, BT……</code>铺天盖地的 P2P 应用已然一定程度上改变了我们上网的习惯，方式以及质量。如果你想了解 P2P 技术，又懒得找，懒得看那些繁琐，模棱两可又及其抽象的中文资料，这里应该是一个你想来的地方。 我的目的是用<strong>比较俗的语言来对 P2P 技术做一个系统的介绍</strong>。这里，我会尽量避开不必要的术语，只告诉并解释你需要知道的。当然我不是什么专家，不过请你相信我回尽量保证我所提供信息的准确性和严谨性。我们没有任何商业目的，您的每一次点击都将对我国的慈善事业做出一份贡献。在此谨代表站长 kakarott 先生向诸位表示感谢。</p><h1 id="P2P-基本原理"><a href="#P2P-基本原理" class="headerlink" title="P2P 基本原理"></a>P2P 基本原理</h1><p>在 P2P 技术之前，网络中的所有人大多都是通过一种叫做<strong>“客户端 / 服务器”</strong>的模式被组织在一起。<strong>一个服务器向很多客户提供服务</strong>。</p><div class="note simple"><p>举个例子吧： kaka 有一台机子，里面存有全套的央视春晚，他想把他的挚爱分享给所有人。于是不论是通过广告还是别的什么方式，很多人知道了 kaka 有这个资源的消息。通过网络，他们就可以向 kaka 建立连接并从他的机子上下载。这样就形成了一个以 kaka 为中心的小型网络。这当中，kaka 是服务器，其他人都是客户端。如图一：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p1.webp"></p></div><p>这样的模式中，对服务器的性能及相应带宽要求比较高，如果有成千上万的人都想下春晚，kaka 的海淀在线肯定就操蛋了。当然一般的公司不会用一个家用电脑做服务器。假设有存在一个特别强大的服务器，以及足够的带宽。我们来看看这种模式天生的一些弱点：</p><ol><li>服务器扮演的角色太重了，网络的一切都指着他。假如 kaka 不小心把电脑从 6 楼扔下去，<strong>整个网络就都瘫痪了</strong>。请注意，想要把一个服务器弄失灵的方法太多了，所以使用这中模式的风险是比较大的。</li><li>网络的资源利用率低下。所有客户都只能从服务器那获得资源，因为他们之间不认识，甚至不知道相互的存在。然而，现实中，可能每个人都有自己独门的资源，比如日天有无数游戏，威哥有无数动漫电影……. 总之，整个网络的资源可能是服务器的无数倍。但是苦无客户端之间没有交流的渠道，所以<strong>资源无法互通</strong>。</li><li>关于完美服务器的假设，基本不成立。</li></ol><p>P2P 技术就是要解决上述的问题已达到如下的效果： 所有人的资源都可以被别人找到并使用。没有哪个人特别重要，<strong>人人平等（peer-to-peer 就是这个意思）</strong>，任何一个人失灵都不会导致网络的死亡。</p><p>这里以 Gnutella 为例，对 P2P 基本原理进行介绍。 Gnutella 是一种典型的 P2P 网络，很具代表性，以其为基础的软件有 Limewire。这种网络里，没有服务器。用户之间任意连接，如图二左所示：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p2.webp"></p><p>Kaka 认识 ‘日天’‘curt’‘威’， 日天认识‘小胖’，威认识‘候泡’，Curt 认识 ‘路’。当然真正的网络有至少有成百上千个用户，这里只是展示一个小的局部。</p><p>这个网络如何工作呢？比如 kaka 想要找一首叫‘走进新时代’的歌。一个基本交易要经过如下几步：</p><ol><li>kaka 给他的邻居们每人发一个请求消息，‘你们丫谁有走进新时代？’</li><li>日天，威，curt 吐血，‘谁 tm 听这歌啊，我没有’。于是把 kaka 的消息转发给他们的邻居：日天发给小胖，威发给候泡，curt 发给路总。</li><li>当 kaka 邻居的邻居们收到这个消息后，同样，先看看自己有没有。比如，候泡有这个歌，他就可以给 kaka 发个消息：‘爷这有，来下吧’</li><li>卡卡于是可以直接去候泡那下载。</li></ol><p>很多人说在 p2p 里面，<strong>所有人即是服务器又是客户端</strong>。应该这样理解，比如，kaka 在上例中就是个客户端。 但当有人要想要春晚的时候，只要那人的请求消息能被转到 kaka 这，kaka 就可以成为一个服务器。</p><p>最后要说的是 P2P 的现状以及应用。目前 P2P 与传统的‘客户端 / 服务器’模式可以说分庭抗礼，互为补充。那么为什么没能取而代之呢？因为，P2P 也有自身的弱点，其中包括：</p><ol><li>占带宽（50% 以上的网络带宽都是 P2P 占用的，搜索方法不灵）</li><li>安全（不具体解释了，太专业了，总之和加密那些东西有关）</li><li>诚信（没有中央控制，你传个毛片也可以告诉你是新闻联播）</li><li>自私（我什么都不付出，有也说没有）</li><li>知识产权保护（在中国相当于盗版的集散地）等等。 至于这些问题的对策以及其不足，以后会做专题介绍。</li></ol><p>P2P 的应用不少但大都停留在比较低端的服务，比如文件共享，msn，在线视频这一类。实际上作为一种新的模式，其生命力应该不止如此。</p><h1 id="非结构化-P2P-及其搜索方法"><a href="#非结构化-P2P-及其搜索方法" class="headerlink" title="非结构化 P2P 及其搜索方法"></a>非结构化 P2P 及其搜索方法</h1><p>上集回顾，传统的‘客户端 / 服务器’模式有一些问题，比如，单一故障点，低资源利用率，高带宽要求。我说 P2P 客服了这些问题，因为没有中央服务器了。这里，我要强调一下，并不是说只要有中央的东西就是失败，只要这个中央的东西不是那个实际掌握资源的人就可以接受。下面，简要介绍一下 P2P 技术的发展。</p><h2 id="第一代、Napster"><a href="#第一代、Napster" class="headerlink" title="第一代、Napster"></a>第一代、Napster</h2><p>这一代的 p2p 只是<strong>把资源从服务器上拿掉了</strong>。中央服务器上只有一个目录。这个目录记录着哪个用户有哪些资源。要建立这样的一个目录，要求网络中的每个人都要告诉这个服务器：他有什么资源。</p><ol><li>Kaka 发一个资源请求向中央服务器。</li><li>这个服务器然后检索目录，并告诉 Kaka，日天有他要的东西。</li><li>Kaka 直接去找日天下东西。</li></ol><p>这样做，解决了高带宽需求（服务器只需要转发一些消息，而不用真格的提供资源），低资源利用率的问题（网络里谁都可以发挥作用了）。但是，他仍然面临严重的‘单一故障点’风险。同时，napster 的出现严重挑战了知识产权法，并最终导致其在 2001 年被勒令关闭。</p><h2 id="第二代、非结构化-P2P"><a href="#第二代、非结构化-P2P" class="headerlink" title="第二代、非结构化 P2P"></a>第二代、非结构化 P2P</h2><p>Napster 帝国的坍塌，导致了江湖上群雄并起，老的规矩也就法不责众了，其中 Gnutella 等非结构的 P2P 脱颖而出。非结构化说白了就是，用户之间瞎连，没有规定谁必须和谁有连接，基本随机。其基本搜索方法是地毯式的，如果这样的搜索能够遍及整个网络。那么，只要资源存在就一定能一网打尽。</p><p>但是上天要求每一个用户都要给自己资源请求加一个限制，于是每个资源请求都只能走几步就必须停了，即使什么都还没找到。因为地毯式的搜索要消耗大量的网络资源，比如，平均一个人有 4 个邻居，如果资源请求的限制为 5. 那么一共需要 4+42+43+44+45=<strong>1364</strong>个信息，每个信息多大呢？大概几 k 到几十 k，也就是说一个信息就<strong>至少几m</strong>。一个人一个信息就这么大了，想想一个大网络，每人十几个邻居，限制提高到 7 或 8. 这就是为什么中国很多地方，尤其是网吧限制 p2p. 因为他们可怜的带宽都被 p2p 的请求信息占用了。</p><p>当然，p2p 的设计者们都看到了问题，于是提出了很多<strong>新的搜索方法</strong>。这些方法可以分成两种：<strong>根据以前的搜索信息对以后的搜索进行预测；瞎找，碰运气</strong>。</p><ol><li>根据经验的搜索准确率可能会高一点，但是这种方法要求每个用户都要建一些表来记录以前的数据，而且每次发送或接到请求都要经过一系列的计算才能决定发给哪个邻居。而且程序上难以实现，更重要的是平均准确率并不比瞎找好很多。这里就不多做介绍了。</li><li>瞎 B 找的，还基本上以地毯式为基础。我介绍两种最常见的：<ul><li><strong>K-walkers</strong>: 第一个人先把消息发给 k 个邻居，具体多少都自己定。 然后从第一轮邻居开始都只把消息转发给他们的一个邻居。</li><li><strong>水纹式（涟漪式）</strong>：先定一个限制。第一个人先发给第一层的邻居。如果第一层不灵，他们再发给他们的邻居。一旦找到资源就不再继续了。这样的话最坏的情况就是原始的地毯式。好点的情况就是，消息没到限制就找到了相应的资源，就停了。</li></ul></li></ol><p>这种非结构的 p2p 的优点在于，操作简单，完全不需要中央控制，所以又称为‘存（纯）p2p’。其缺点同样明显，要么牺牲搜索成功率，要么牺牲带宽占有量。</p><p>于是又有人提出了<strong>结构化的P2P</strong>。数学的东西我就不说了，基本的思想就是：</p><ol><li>每个用户，资源都得有个名字。</li><li>有一种数学加密方法，对这些名字加密。且保证如果名字不同，那么得到的结果就不同。</li><li>如一资源和一用户加密后结果接近，就把该资源的地址放到相应的用户身上。</li></ol><div class="note simple"><p>举个例子：</p><p>有三个人，日天，kaka，威哥。三个资源：“一剪梅.mp3”,“八荣八耻歌歌词.txt”,“xxx.avi”，对这六个东西加密后分别得到： 100，200，3000， 3002， 233，98，‘xxx.avi’的下载地址就会被分配到‘日天’的机子上，于是当你想搜索 “xxx.avi”，你的消息就会通过某种方法被传到到日天那。</p></div><p>这样，结构化的 P2P 就可以保证，只要网络里有相应的资源，就一定能找到。但是由于其程序实现的难度，加之维护网络所需的投入太大，并不被经常使用。尽管他有很漂亮的数据。</p><p>当然还有第三代的，以后再做专题。</p><h1 id="BT-工作原理简介"><a href="#BT-工作原理简介" class="headerlink" title="BT 工作原理简介"></a>BT 工作原理简介</h1><p>2002年左右，程小胖告诉我有一种软件可以下片，人越多越快。很神奇。请注意，并不是所有的 P2P 技术都能做到这点，其他的 P2P 基本上只是<strong>提高网络资源的利用率，但是，网络中的每一单买卖都仍然采用，1 对 1 的客户端服务器模式</strong>。回顾一下之前讲过的 P2P，去掉技术细节，做一单买卖可以这样描述：</p><ol><li>有人向网络发一个资源请求（请求者）。有很多种搜索方法可供选择。</li><li>当一个有该的资源的人（提供者）收到这个的请求，他会设法通知请求者：他那有其想要的东西。</li><li>于是请求者去找提供者下载。</li></ol><p>这样做的一个<strong>缺点</strong>就是，比如，我选择了一个比较矬的提供者，而那人的带宽只有 30k，然而网络中还有很多潜在提供者，可能有的人能达到 30m。但是由于我在选择时只无法对对方的带宽做出判断而无福消受。</p><p>这样做还有一个致命的漏洞！比如，我收到一个关于 “海贼王” 的请求，而且我有全套。按理说我应该通知请求者，让他来我这下。但是，让他来我这里下东西，对我来说，除了占我带宽，增加我中毒的风险，没有任何的好处。那我凭什么主动邀请他来？？我何不装 ytd，对该请求视而不见？非常不幸的是，跟我有相同想法的孙子在一般 p2p 网络里面占了大多数，甚至绝大多数。这就是搭便车问题（free riding）。所幸还是有一些大侠的，无偿的提供着大量资源，他们的存在使得那些一般的 P2P 得以侥幸存活。</p><p>其实，如果仅仅依赖活雷锋们，P2P 就失去了其人人平等的意义。大侠们回复了网络中绝大多数的请求，于是人人都愿意与这些人建立连接，因为这样能更快的找到资源。于是这些大侠们就成了变得越来越红，网络的拓扑结构（我装 b 了，这个词没法解释，但是我实在找不出别的词了，别在意，看下图。）将会发生变化。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p3.webp"></p><p><strong>这样的变化很不好，因为 P2P 又逐渐变成了客户端 / 服务器模式了</strong>。</p><p>于是，不论是学术界还是产业界都意识到，如果没有一种鼓励机制来刺激提供者，P2P 将失去其天生的魅力。在众多解决方案中 BT 脱颖而出，迅速发展了起来。BT 是简称，在国外可能会产生歧义，如 British Telecommunications 等等。所以大家尽量还是用全称，尤其是和外国人说的时候 Bit-Torrent。有人说 BT 是第三代的 P2P，我认为这是因为他把 P2P 的理念更加深入的实现了。</p><p>在 BitTorrent 当中，所有的资源都被切成很小的等份（碎片）。这里，你不需要知道怎么切，只需要知道有一种技术可以把一个文件切成很多小等份，还能把这些等份再重新的组装。在这个技术的支持下，bittorrent 中所有有相同请求的用户可以相互传资源的碎片。而且谁传的多，谁就将获得更多。具体技术如下：</p><ul><li><p>首先，有同样资源请求的人怎么能相互认识呢？bittorrent 中每一个资源都对应有一个叫<strong>tracker</strong>的服务器。只要你对一个资源有意思，你就必须先联系这个资源相应的 tracker。或者你想要共享一个资源你也必须联系 tracker。这样的话，tracker 就掌握着整个网络中<strong>谁想要这个资源</strong>以及<strong>谁有这个资源</strong>。当然，为了节约，一个 tracker 可以负责多种资源。</p></li><li><p>那么，怎么找到 tracker 呢？大家可能听说过做种子，每个有完整资源的人都可以做种子，其实就是生成一个后缀是.torrent 的文件。每一款 bittorrent 应用软件都会自动帮你生成，所以不用担心。你只要知道这个文件中包括两部分内容：<code>1，tracker的地址。2，相关资源的一些属性，比如大小，名字等等</code>。这个 torrent 文件一般都可以发布在网上，比如某某人的博客，或者论坛上。</p></li><li><p>于是，大家可以从网上找到 torrent 文件，并从中知道 tracker 在哪。再通过联系 tracker 得到一个<strong>名单</strong>，其中包括一部分正在下载或有完整资源的用户。这时候，你就可以与这些人建立链接，并分别从他们身上要不同的碎片。当然要相同资源的人越多，你可以建立连接的人就越多，也就更可能早日得到所有碎片。</p></li><li><p>还有一点很重要就是，bittorrent 有自己的<strong>鼓励机制</strong>，就是说，你做的贡献大就会被鼓励，你不做贡献就会被惩罚。具体的操作是，每个人在下载的同时也上传。上传给谁呢？谁给我给的多，我就传给谁。而且我只传个前 4 名的（视具体软件具体分析，也可能是前 8 名或其他）。</p></li></ul><div class="note simple"><p>举个例子，比如 kaka 下载‘春晚’，先从某春晚发烧友论坛下载了一个叫<code>“春晚全集.torrent”</code>的文件。kaka 可以联系文件中的 tracker，并得知‘程胖，日天，威，候泡，鸣’有想关资源。于是 kaka 分别与这五个人建立连接。通过检测链接的流量，kaka 可知，比如从程胖那下载速度可达 200k/s, 日天 100k/s, 威 150k/s, 候泡 70k/s, 鸣 2k/s。于是 kaka 在上传的时候就不给鸣上传，而只给前 4 名传。由于鸣的上传只有 2k/s，所以不太可能有人给他传，所以时间一长他可能会意识到，可能自己给的太少了，于是把上传带宽增加到了 500k/s。kaka 突然意识到，从鸣那里可以得到很好的速度，于是停止给候泡（70k/s）传转而给鸣传。（总给那些速度最好的人上传是为了能留住他们，当然，只有你传的足够多才能留得住人家）。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/p2p4.webp"></p></div><p>bittorrent 大概的工作原理就是这样了，还有些细节这里不多说了。我个人认为 Bittorrent 的设计还是很不错的，但是其只适用于文件共享，或视频共享。然而网络中的资源又何止电影音乐？？绝大多数的资源是不可分的，bittorrent 的局限性还是相当大！ 另一点可悲的是，大多数宽带用户是 ADSL，也就是说他们的下载上传的带宽上限差别很大，比如，下载最大 2m/s，上传却只有 100k/s。这也限制了 bittorrent 的发挥。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;迅雷，msn，skype，pplive, ppstream, BT……&lt;/code&gt;铺天盖地的 P2P 应用已然一定程度上改变了我们上网的习惯，方式以及质量。如果你想了解 P2P 技术，又懒得找，懒得看那些繁琐，模棱两可又及其抽象的中文资料，这里应该是一个你想来</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="网络" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="网络" scheme="https://matthew84.cf/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="P2P" scheme="https://matthew84.cf/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫 -（二）总体实现</title>
    <link href="https://matthew84.cf/archives/4da64f30.html"/>
    <id>https://matthew84.cf/archives/4da64f30.html</id>
    <published>2020-11-03T11:00:57.000Z</published>
    <updated>2020-11-03T11:58:00.947Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第二篇，详细分析了爬取全过程。</p><p>详细的代码开源在 GitHub 上：<a href="https://github.com/dta0502/NBSPRC-spider">NBSPRC-spider</a>。</p><h1 id="总体思路说明"><a href="#总体思路说明" class="headerlink" title="总体思路说明"></a>总体思路说明</h1><p>首先我定义了一个网页爬取函数，然后依次定义省级代码获取函数、市级代码获取函数、区级代码获取函数、街道代码获取函数、居委会代码获取函数，这些函数都会调用网页爬取函数。其中区级代码获取函数、街道代码获取函数、居委会代码获取函数这三个函数都是多线程实现爬取的。最后我将爬取得到的数据输出为 csv 格式文件。</p><h2 id="库函数导入"><a href="#库函数导入" class="headerlink" title="库函数导入"></a>库函数导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line">import csv</span><br><span class="line">import time</span><br><span class="line">import pandas as pd</span><br><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line">from fake_useragent import UserAgent</span><br></pre></td></tr></table></figure><h2 id="网页爬取函数"><a href="#网页爬取函数" class="headerlink" title="网页爬取函数"></a>网页爬取函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 下面加入了num_retries这个参数，经过测试网络正常一般最多retry一次就能获得结果</span><br><span class="line">def getUrl(url,num_retries &#x3D; 5):</span><br><span class="line">    ua &#x3D; UserAgent()</span><br><span class="line">    headers &#x3D; &#123;&#39;User-Agent&#39;:ua.random&#125;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.get(url,headers &#x3D; headers)</span><br><span class="line">        response.encoding &#x3D; response.apparent_encoding</span><br><span class="line">        data &#x3D; response.text</span><br><span class="line">        return data</span><br><span class="line">    except Exception as e:</span><br><span class="line">        if num_retries &gt; 0:</span><br><span class="line">            time.sleep(10)</span><br><span class="line">            print(url)</span><br><span class="line">            print(&quot;requests fail, retry!&quot;)</span><br><span class="line">            return getUrl(url,num_retries-1) #递归调用</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;retry fail!&quot;)</span><br><span class="line">            print(&quot;error: %s&quot; % e + &quot; &quot; + url)</span><br><span class="line">            return #返回空值，程序运行报错</span><br></pre></td></tr></table></figure><h2 id="获取省级代码函数"><a href="#获取省级代码函数" class="headerlink" title="获取省级代码函数"></a>获取省级代码函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def getProvince(url):</span><br><span class="line">    province &#x3D; []</span><br><span class="line">    data &#x3D; getUrl(url)</span><br><span class="line">    selector &#x3D; etree.HTML(data)</span><br><span class="line">    provinceList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;provincetr&quot;]&#39;)</span><br><span class="line">    for i in provinceList:</span><br><span class="line">        provinceName &#x3D; i.xpath(&#39;td&#x2F;a&#x2F;text()&#39;) #这里如果采用&#x2F;&#x2F;a&#x2F;text()路径会出现问题！！</span><br><span class="line">        provinceLink &#x3D; i.xpath(&#39;td&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">        for j in range(len(provinceLink)):</span><br><span class="line">            provinceURL &#x3D; url[:-10] + provinceLink[j] #根据获取到的每个省的链接进行补全，得到真实的URL。</span><br><span class="line">            province.append(&#123;&#39;name&#39;:provinceName[j],&#39;link&#39;:provinceURL&#125;)</span><br><span class="line">    return province</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pro &#x3D; getProvince(&quot;http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;index.html&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_province &#x3D; pd.DataFrame(pro)</span><br><span class="line">df_province[&#39;link&#39;]</span><br></pre></td></tr></table></figure><pre><code>0     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...1     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...2     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...3     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...   4     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...5     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...6     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...7     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...8     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...9     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...10    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...11    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...12    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...13    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...14    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...15    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...16    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...17    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...18    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...19    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...20    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...21    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...22    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...23    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...24    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...25    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...26    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...27    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...28    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...29    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...30    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...Name: link, dtype: object</code></pre><h2 id="信息写入-csv-文件"><a href="#信息写入-csv-文件" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_province.to_csv(&#39;province.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取市级代码函数"><a href="#获取市级代码函数" class="headerlink" title="获取市级代码函数"></a>获取市级代码函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def getCity(url_list):</span><br><span class="line">    city_all &#x3D; []</span><br><span class="line">    for url in url_list:</span><br><span class="line">        data &#x3D; getUrl(url)</span><br><span class="line">        selector &#x3D; etree.HTML(data)</span><br><span class="line">        cityList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;citytr&quot;]&#39;)</span><br><span class="line">        #下面是抓取每一个城市的代码、URL</span><br><span class="line">        city &#x3D; []</span><br><span class="line">        for i in cityList:</span><br><span class="line">            cityCode &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">            cityLink &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">            cityName &#x3D; i.xpath(&#39;td[2]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">            for j in range(len(cityLink)):</span><br><span class="line">                cityURL &#x3D; url[:-7] + cityLink[j]</span><br><span class="line">                city.append(&#123;&#39;name&#39;:cityName[j],&#39;code&#39;:cityCode[j],&#39;link&#39;:cityURL&#125;)</span><br><span class="line">        city_all.extend(city) #所有省的城市信息合并在一起</span><br><span class="line">    return city_all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">city &#x3D; getCity(df_province[&#39;link&#39;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_city &#x3D; pd.DataFrame(city)</span><br><span class="line">df_city</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th><center>code</center></th>      <th><center>link</center></th>      <th><center>name</center></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>110100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 市辖区</td>    </tr>    <tr>      <th> 1</th>      <td>120100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 市辖区</td>    </tr>    <tr>      <th> 2</th>      <td>130100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 石家庄市</td>    </tr>    <tr>      <th> 3</th>      <td>130200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 唐山市</td>    </tr>    <tr>      <th> 4</th>      <td>130300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 秦皇岛市</td>    </tr>    <tr>      <th> 5</th>      <td>130400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 邯郸市</td>    </tr>    <tr>      <th> 6</th>      <td>130500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 邢台市</td>    </tr>    <tr>      <th> 7</th>      <td>130600000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 保定市</td>    </tr>    <tr>      <th> 8</th>      <td>130700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 张家口市</td>    </tr>    <tr>      <th> 9</th>      <td>130800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 承德市</td>    </tr>    <tr>      <th> 10</th>      <td>130900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沧州市</td>    </tr>    <tr>      <th> 11</th>      <td>131000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 廊坊市</td>    </tr>    <tr>      <th> 12</th>      <td>131100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 衡水市</td>    </tr>    <tr>      <th> 13</th>      <td>139000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 省直辖县级行政区划</td>    </tr>    <tr>      <th> 14</th>      <td>140100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 太原市</td>    </tr>    <tr>      <th> 15</th>      <td>140200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 大同市</td>    </tr>    <tr>      <th> 16</th>      <td>140300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阳泉市</td>    </tr>    <tr>      <th> 17</th>      <td>140400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 长治市</td>    </tr>    <tr>      <th> 18</th>      <td>140500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 晋城市</td>    </tr>    <tr>      <th> 19</th>      <td>140600000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 朔州市</td>    </tr>    <tr>      <th> 20</th>      <td>140700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 晋中市</td>    </tr>    <tr>      <th> 21</th>      <td>140800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 运城市</td>    </tr>    <tr>      <th> 22</th>      <td>140900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 忻州市</td>    </tr>    <tr>      <th> 23</th>      <td>141000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 临汾市</td>    </tr>    <tr>      <th> 24</th>      <td>141100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吕梁市</td>    </tr>    <tr>      <th> 25</th>      <td>150100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 呼和浩特市</td>    </tr>    <tr>      <th> 26</th>      <td>150200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 包头市</td>    </tr>    <tr>      <th> 27</th>      <td>150300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌海市</td>    </tr>    <tr>      <th> 28</th>      <td>150400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 赤峰市</td>    </tr>    <tr>      <th> 29</th>      <td>150500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 通辽市</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>314</th>      <td>622900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 临夏回族自治州</td>    </tr>    <tr>      <th> 315</th>      <td>623000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 甘南藏族自治州</td>    </tr>    <tr>      <th> 316</th>      <td>630100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 西宁市</td>    </tr>    <tr>      <th> 317</th>      <td>630200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海东市</td>    </tr>    <tr>      <th> 318</th>      <td>632200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海北藏族自治州</td>    </tr>    <tr>      <th> 319</th>      <td>632300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 黄南藏族自治州</td>    </tr>    <tr>      <th> 320</th>      <td>632500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海南藏族自治州</td>    </tr>    <tr>      <th> 321</th>      <td>632600000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 果洛藏族自治州</td>    </tr>    <tr>      <th> 322</th>      <td>632700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 玉树藏族自治州</td>    </tr>    <tr>      <th> 323</th>      <td>632800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 海西蒙古族藏族自治州</td>    </tr>    <tr>      <th> 324</th>      <td>640100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 银川市</td>    </tr>    <tr>      <th> 325</th>      <td>640200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 石嘴山市</td>    </tr>    <tr>      <th> 326</th>      <td>640300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吴忠市</td>    </tr>    <tr>      <th> 327</th>      <td>640400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 固原市</td>    </tr>    <tr>      <th> 328</th>      <td>640500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 中卫市</td>    </tr>    <tr>      <th> 329</th>      <td>650100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌鲁木齐市</td>    </tr>    <tr>      <th> 330</th>      <td>650200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 克拉玛依市</td>    </tr>    <tr>      <th> 331</th>      <td>650400000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吐鲁番市</td>    </tr>    <tr>      <th> 332</th>      <td>650500000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 哈密市</td>    </tr>    <tr>      <th> 333</th>      <td>652300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 昌吉回族自治州</td>    </tr>    <tr>      <th> 334</th>      <td>652700000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 博尔塔拉蒙古自治州</td>    </tr>    <tr>      <th> 335</th>      <td>652800000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 巴音郭楞蒙古自治州</td>    </tr>    <tr>      <th> 336</th>      <td>652900000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿克苏地区</td>    </tr>    <tr>      <th> 337</th>      <td>653000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 克孜勒苏柯尔克孜自治州</td>    </tr>    <tr>      <th> 338</th>      <td>653100000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 喀什地区</td>    </tr>    <tr>      <th> 339</th>      <td>653200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 和田地区</td>    </tr>    <tr>      <th> 340</th>      <td>654000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 伊犁哈萨克自治州</td>    </tr>    <tr>      <th> 341</th>      <td>654200000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 塔城地区</td>    </tr>    <tr>      <th> 342</th>      <td>654300000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿勒泰地区</td>    </tr>    <tr>      <th> 343</th>      <td>659000000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 自治区直辖县级行政区划</td>    </tr>  </tbody></table><h2 id="信息写入-csv-文件-1"><a href="#信息写入-csv-文件-1" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_city.to_csv(&#39;city.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取区级代码函数-—-多线程实现"><a href="#获取区级代码函数-—-多线程实现" class="headerlink" title="获取区级代码函数 — 多线程实现"></a>获取区级代码函数 — 多线程实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def getCounty(url_list):</span><br><span class="line">    queue_county &#x3D; Queue() #队列</span><br><span class="line">    thread_num &#x3D; 10 #进程数</span><br><span class="line">    county &#x3D; [] #记录区级信息的字典（全局）</span><br><span class="line">    </span><br><span class="line">    def produce_url(url_list):</span><br><span class="line">        for url in url_list:</span><br><span class="line">            queue_county.put(url) # 生成URL存入队列，等待其他线程提取</span><br><span class="line">    </span><br><span class="line">    def getData():</span><br><span class="line">        while not queue_county.empty(): # 保证url遍历结束后能退出线程</span><br><span class="line">            url &#x3D; queue_county.get() # 从队列中获取URL</span><br><span class="line">            data &#x3D; getUrl(url)</span><br><span class="line">            selector &#x3D; etree.HTML(data)</span><br><span class="line">            countyList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;countytr&quot;]&#39;)</span><br><span class="line">            #下面是爬取每个区的代码、URL</span><br><span class="line">            for i in countyList:</span><br><span class="line">                countyCode &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                countyLink &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">                countyName &#x3D; i.xpath(&#39;td[2]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                #上面得到的是列表形式的，下面将其每一个用字典存储</span><br><span class="line">                for j in range(len(countyLink)):</span><br><span class="line">                    countyURL &#x3D; url[:-9] + countyLink[j]</span><br><span class="line">                    county.append(&#123;&#39;code&#39;:countyCode[j],&#39;link&#39;:countyURL,&#39;name&#39;:countyName[j]&#125;)</span><br><span class="line">                </span><br><span class="line">    def run(url_list):</span><br><span class="line">        produce_url(url_list)</span><br><span class="line">    </span><br><span class="line">        ths &#x3D; []</span><br><span class="line">        for _ in range(thread_num):</span><br><span class="line">            th &#x3D; Thread(target &#x3D; getData)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        for th in ths:</span><br><span class="line">            th.join()</span><br><span class="line">            </span><br><span class="line">    run(url_list)</span><br><span class="line">    return county</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">county &#x3D; getCounty(df_city[&#39;link&#39;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_county &#x3D; pd.DataFrame(county)</span><br><span class="line">df_county</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>code</th>      <th>link</th>      <th>name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>130702000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 桥东区</td>    </tr>    <tr>      <th> 1</th>      <td>130703000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 桥西区</td>    </tr>    <tr>      <th> 2</th>      <td>130705000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 宣化区</td>    </tr>    <tr>      <th> 3</th>      <td>130706000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 下花园区</td>    </tr>    <tr>      <th> 4</th>      <td>130708000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 万全区</td>    </tr>    <tr>      <th> 5</th>      <td>130709000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 崇礼区</td>    </tr>    <tr>      <th> 6</th>      <td>130722000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 张北县</td>    </tr>    <tr>      <th> 7</th>      <td>130723000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 康保县</td>    </tr>    <tr>      <th> 8</th>      <td>130724000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沽源县</td>    </tr>    <tr>      <th> 9</th>      <td>130725000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 尚义县</td>    </tr>    <tr>      <th> 10</th>      <td>130726000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 蔚县</td>    </tr>    <tr>      <th> 11</th>      <td>130727000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阳原县</td>    </tr>    <tr>      <th> 12</th>      <td>130602000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 竞秀区</td>    </tr>    <tr>      <th> 13</th>      <td>130606000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 莲池区</td>    </tr>    <tr>      <th> 14</th>      <td>130607000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 满城区</td>    </tr>    <tr>      <th> 15</th>      <td>130608000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 清苑区</td>    </tr>    <tr>      <th> 16</th>      <td>130609000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 徐水区</td>    </tr>    <tr>      <th> 17</th>      <td>130623000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 涞水县</td>    </tr>    <tr>      <th> 18</th>      <td>130624000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阜平县</td>    </tr>    <tr>      <th> 19</th>      <td>130626000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 定兴县</td>    </tr>    <tr>      <th> 20</th>      <td>130627000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 唐县</td>    </tr>    <tr>      <th> 21</th>      <td>130628000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 高阳县</td>    </tr>    <tr>      <th> 22</th>      <td>130629000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 容城县</td>    </tr>    <tr>      <th> 23</th>      <td>130630000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 涞源县</td>    </tr>    <tr>      <th> 24</th>      <td>130631000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 望都县</td>    </tr>    <tr>      <th> 25</th>      <td>130632000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 安新县</td>    </tr>    <tr>      <th> 26</th>      <td>130633000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 易县</td>    </tr>    <tr>      <th> 27</th>      <td>130634000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 曲阳县</td>    </tr>    <tr>      <th> 28</th>      <td>130635000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 蠡县</td>    </tr>    <tr>      <th> 29</th>      <td>130636000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 顺平县</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>2822</th>      <td>653128000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 岳普湖县</td>    </tr>    <tr>      <th> 2823</th>      <td>653129000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 伽师县</td>    </tr>    <tr>      <th> 2824</th>      <td>654221000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 额敏县</td>    </tr>    <tr>      <th> 2825</th>      <td>652901000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿克苏市</td>    </tr>    <tr>      <th> 2826</th>      <td>654223000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沙湾县</td>    </tr>    <tr>      <th> 2827</th>      <td>652922000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 温宿县</td>    </tr>    <tr>      <th> 2828</th>      <td>653130000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 巴楚县</td>    </tr>    <tr>      <th> 2829</th>      <td>654224000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 托里县</td>    </tr>    <tr>      <th> 2830</th>      <td>652923000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 库车县</td>    </tr>    <tr>      <th> 2831</th>      <td>654225000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 裕民县</td>    </tr>    <tr>      <th> 2832</th>      <td>653131000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 塔什库尔干塔吉克自治县</td>    </tr>    <tr>      <th> 2833</th>      <td>654226000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 和布克赛尔蒙古自治县</td>    </tr>    <tr>      <th> 2834</th>      <td>652924000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沙雅县</td>    </tr>    <tr>      <th> 2835</th>      <td>652925000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 新和县</td>    </tr>    <tr>      <th> 2836</th>      <td>652926000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 拜城县</td>    </tr>    <tr>      <th> 2837</th>      <td>652927000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌什县</td>    </tr>    <tr>      <th> 2838</th>      <td>652928000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿瓦提县</td>    </tr>    <tr>      <th> 2839</th>      <td>652929000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 柯坪县</td>    </tr>    <tr>      <th> 2840</th>      <td>659001000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 石河子市</td>    </tr>    <tr>      <th> 2841</th>      <td>659002000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿拉尔市</td>    </tr>    <tr>      <th> 2842</th>      <td>659003000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 图木舒克市</td>    </tr>    <tr>      <th> 2843</th>      <td>659004000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 五家渠市</td>    </tr>    <tr>      <th> 2844</th>      <td>659006000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 铁门关市</td>    </tr>    <tr>      <th> 2845</th>      <td>654301000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿勒泰市</td>    </tr>    <tr>      <th> 2846</th>      <td>654321000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 布尔津县</td>    </tr>    <tr>      <th> 2847</th>      <td>654322000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 富蕴县</td>    </tr>    <tr>      <th> 2848</th>      <td>654323000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 福海县</td>    </tr>    <tr>      <th> 2849</th>      <td>654324000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 哈巴河县</td>    </tr>    <tr>      <th> 2850</th>      <td>654325000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 青河县</td>    </tr>    <tr>      <th> 2851</th>      <td>654326000000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 吉木乃县</td>    </tr>  </tbody></table><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照区代码进行 “升序” 排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_county_sorted &#x3D; df_county.sort_values(by &#x3D; [&#39;code&#39;]) #按1列进行升序排序</span><br></pre></td></tr></table></figure><h2 id="信息写入-csv-文件-2"><a href="#信息写入-csv-文件-2" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_county_sorted.to_csv(&#39;county.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取街道代码函数-—-多线程实现"><a href="#获取街道代码函数-—-多线程实现" class="headerlink" title="获取街道代码函数 — 多线程实现"></a>获取街道代码函数 — 多线程实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def getTown(url_list):</span><br><span class="line">    queue_town &#x3D; Queue() #队列</span><br><span class="line">    thread_num &#x3D; 50 #进程数</span><br><span class="line">    town &#x3D; [] #记录街道信息的字典（全局）</span><br><span class="line">    </span><br><span class="line">    def produce_url(url_list):</span><br><span class="line">        for url in url_list:</span><br><span class="line">            queue_town.put(url) # 生成URL存入队列，等待其他线程提取</span><br><span class="line">    </span><br><span class="line">    def getData():</span><br><span class="line">        while not queue_town.empty(): # 保证url遍历结束后能退出线程</span><br><span class="line">            url &#x3D; queue_town.get() # 从队列中获取URL</span><br><span class="line">            data &#x3D; getUrl(url)</span><br><span class="line">            selector &#x3D; etree.HTML(data)</span><br><span class="line">            townList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;towntr&quot;]&#39;)</span><br><span class="line">            #下面是爬取每个区的代码、URL</span><br><span class="line">            for i in townList:</span><br><span class="line">                townCode &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                townLink &#x3D; i.xpath(&#39;td[1]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">                townName &#x3D; i.xpath(&#39;td[2]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">                #上面得到的是列表形式的，下面将其每一个用字典存储</span><br><span class="line">                for j in range(len(townLink)):</span><br><span class="line">                    townURL &#x3D; url[:-11] + townLink[j]</span><br><span class="line">                    town.append(&#123;&#39;code&#39;:townCode[j],&#39;link&#39;:townURL,&#39;name&#39;:townName[j]&#125;)</span><br><span class="line">                </span><br><span class="line">    def run(url_list):</span><br><span class="line">        produce_url(url_list)</span><br><span class="line">    </span><br><span class="line">        ths &#x3D; []</span><br><span class="line">        for _ in range(thread_num):</span><br><span class="line">            th &#x3D; Thread(target &#x3D; getData)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        for th in ths:</span><br><span class="line">            th.join()</span><br><span class="line">            </span><br><span class="line">    run(url_list)</span><br><span class="line">    return town</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">town &#x3D; getTown(df_county[&#39;link&#39;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_town &#x3D; pd.DataFrame(town)</span><br><span class="line">df_town</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>code</th>      <th>link</th>      <th>name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>130706001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 城镇街道办事处</td>    </tr>    <tr>      <th> 1</th>      <td>130706002000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 煤矿街道办事处</td>    </tr>    <tr>      <th> 2</th>      <td>130706200000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 花园乡</td>    </tr>    <tr>      <th> 3</th>      <td>130706201000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 辛庄子乡</td>    </tr>    <tr>      <th> 4</th>      <td>130706202000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 定方水乡</td>    </tr>    <tr>      <th> 5</th>      <td>130706203000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 段家堡乡</td>    </tr>    <tr>      <th> 6</th>      <td>130702001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 红旗楼街道办事处</td>    </tr>    <tr>      <th> 7</th>      <td>130702002000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 胜利北路街道办事处</td>    </tr>    <tr>      <th> 8</th>      <td>130702003000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 五一路街道办事处</td>    </tr>    <tr>      <th> 9</th>      <td>130702004000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 花园街街道办事处</td>    </tr>    <tr>      <th> 10</th>      <td>130702005000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 工业路街道办事处</td>    </tr>    <tr>      <th> 11</th>      <td>130702101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 姚家庄镇</td>    </tr>    <tr>      <th> 12</th>      <td>130623001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 城区社区管理办公室街道办事处</td>    </tr>    <tr>      <th> 13</th>      <td>130624100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阜平镇</td>    </tr>    <tr>      <th> 14</th>      <td>130624101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 龙泉关镇</td>    </tr>    <tr>      <th> 15</th>      <td>130626100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 定兴镇</td>    </tr>    <tr>      <th> 16</th>      <td>130623100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 涞水镇</td>    </tr>    <tr>      <th> 17</th>      <td>130624102000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 平阳镇</td>    </tr>    <tr>      <th> 18</th>      <td>130624103000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 城南庄镇</td>    </tr>    <tr>      <th> 19</th>      <td>130624104000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 天生桥镇</td>    </tr>    <tr>      <th> 20</th>      <td>130624105000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 王林口镇</td>    </tr>    <tr>      <th> 21</th>      <td>130624202000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 台峪乡</td>    </tr>    <tr>      <th> 22</th>      <td>130624203000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 大台乡</td>    </tr>    <tr>      <th> 23</th>      <td>130624204000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 史家寨乡</td>    </tr>    <tr>      <th> 24</th>      <td>130624205000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 砂窝乡</td>    </tr>    <tr>      <th> 25</th>      <td>130724100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 平定堡镇</td>    </tr>    <tr>      <th> 26</th>      <td>130724101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 小厂镇</td>    </tr>    <tr>      <th> 27</th>      <td>130724102000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 黄盖淖镇</td>    </tr>    <tr>      <th> 28</th>      <td>130724103000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 九连城镇</td>    </tr>    <tr>      <th> 29</th>      <td>130724200000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 高山堡乡</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>42532</th>      <td>659002509000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团十六团</td>    </tr>    <tr>      <th> 42533</th>      <td>659002511000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团第一师水利水电工程处</td>    </tr>    <tr>      <th> 42534</th>      <td>659002512000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团第一师塔里木灌区水利管理处</td>    </tr>    <tr>      <th> 42535</th>      <td>659002513000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿拉尔农场</td>    </tr>    <tr>      <th> 42536</th>      <td>659002514000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团第一师幸福农场</td>    </tr>    <tr>      <th> 42537</th>      <td>659002515000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 中心监狱</td>    </tr>    <tr>      <th> 42538</th>      <td>659002516000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团一团</td>    </tr>    <tr>      <th> 42539</th>      <td>659002517000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团农一师沙井子水利管理处</td>    </tr>    <tr>      <th> 42540</th>      <td>659002518000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 西工业园区管理委员会</td>    </tr>    <tr>      <th> 42541</th>      <td>659002519000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团二团</td>    </tr>    <tr>      <th> 42542</th>      <td>659002520000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 兵团三团</td>    </tr>    <tr>      <th> 42543</th>      <td>522701001000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 广惠街道办事处</td>    </tr>    <tr>      <th> 42544</th>      <td>522701002000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 文峰街道办事处</td>    </tr>    <tr>      <th> 42545</th>      <td>522701004000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 小围寨街道办事处</td>    </tr>    <tr>      <th> 42546</th>      <td>522701005000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 沙包堡街道办事处</td>    </tr>    <tr>      <th> 42547</th>      <td>522701006000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 绿茵湖街道办事处</td>    </tr>    <tr>      <th> 42548</th>      <td>522701106000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 墨冲镇</td>    </tr>    <tr>      <th> 42549</th>      <td>522701107000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 平浪镇</td>    </tr>    <tr>      <th> 42550</th>      <td>522701110000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 毛尖镇</td>    </tr>    <tr>      <th> 42551</th>      <td>522701111000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 匀东镇</td>    </tr>    <tr>      <th> 42552</th>      <td>522701208000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 归兰水族乡</td>    </tr>    <tr>      <th> 42553</th>      <td>652928100000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿瓦提镇</td>    </tr>    <tr>      <th> 42554</th>      <td>652928101000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 乌鲁却勒镇</td>    </tr>    <tr>      <th> 42555</th>      <td>652928102000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 拜什艾日克镇</td>    </tr>    <tr>      <th> 42556</th>      <td>652928200000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿依巴格乡</td>    </tr>    <tr>      <th> 42557</th>      <td>652928201000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 塔木托格拉克乡</td>    </tr>    <tr>      <th> 42558</th>      <td>652928202000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 英艾日克乡</td>    </tr>    <tr>      <th> 42559</th>      <td>652928203000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 多浪乡</td>    </tr>    <tr>      <th> 42560</th>      <td>652928204000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 巴格托格拉克乡</td>    </tr>    <tr>      <th> 42561</th>      <td>652928405000</td>      <td>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...</td>      <td> 阿克苏监狱</td>    </tr>  </tbody></table>    <h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照街道代码进行 “升序” 排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_town_sorted &#x3D; df_town.sort_values(by &#x3D; [&#39;code&#39;]) #按1列进行升序排序</span><br></pre></td></tr></table></figure><p>信息写入 csv 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_town_sorted.to_csv(&#39;town.csv&#39;, sep&#x3D;&#39;,&#39;, header&#x3D;True, index&#x3D;False)</span><br></pre></td></tr></table></figure><h2 id="获取居委会代码函数-—-多线程实现"><a href="#获取居委会代码函数-—-多线程实现" class="headerlink" title="获取居委会代码函数 — 多线程实现"></a>获取居委会代码函数 — 多线程实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def getVillage(url_list):</span><br><span class="line">    queue_village &#x3D; Queue() #队列</span><br><span class="line">    thread_num &#x3D; 200 #进程数</span><br><span class="line">    town &#x3D; [] #记录街道信息的字典（全局）</span><br><span class="line">    </span><br><span class="line">    def produce_url(url_list):</span><br><span class="line">        for url in url_list:</span><br><span class="line">            queue_village.put(url) # 生成URL存入队列，等待其他线程提取</span><br><span class="line">    </span><br><span class="line">    def getData():</span><br><span class="line">        while not queue_village.empty(): # 保证url遍历结束后能退出线程</span><br><span class="line">            url &#x3D; queue_village.get() # 从队列中获取URL</span><br><span class="line">            data &#x3D; getUrl(url)</span><br><span class="line">            selector &#x3D; etree.HTML(data)</span><br><span class="line">            villageList &#x3D; selector.xpath(&#39;&#x2F;&#x2F;tr[@class&#x3D;&quot;villagetr&quot;]&#39;)</span><br><span class="line">            #下面是爬取每个区的代码、URL</span><br><span class="line">            for i in villageList:</span><br><span class="line">                villageCode &#x3D; i.xpath(&#39;td[1]&#x2F;text()&#39;)</span><br><span class="line">                UrbanRuralCode &#x3D; i.xpath(&#39;td[2]&#x2F;text()&#39;)</span><br><span class="line">                villageName &#x3D; i.xpath(&#39;td[3]&#x2F;text()&#39;)</span><br><span class="line">                #上面得到的是列表形式的，下面将其每一个用字典存储</span><br><span class="line">                for j in range(len(villageCode)):</span><br><span class="line">                    town.append(&#123;&#39;code&#39;:villageCode[j],&#39;UrbanRuralCode&#39;:UrbanRuralCode[j],&#39;name&#39;:villageName[j]&#125;)</span><br><span class="line">                </span><br><span class="line">    def run(url_list):</span><br><span class="line">        produce_url(url_list)</span><br><span class="line">    </span><br><span class="line">        ths &#x3D; []</span><br><span class="line">        for _ in range(thread_num):</span><br><span class="line">            th &#x3D; Thread(target &#x3D; getData)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        for th in ths:</span><br><span class="line">            th.join()</span><br><span class="line">            </span><br><span class="line">    run(url_list)</span><br><span class="line">    return town</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">village &#x3D; getVillage(df_town[&#39;link&#39;])</span><br></pre></td></tr></table></figure><pre><code>http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/24/140724204.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/27/140727400.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/10/29/141029204.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/04/150104008.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981102.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/02/150102001.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981210.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/21/150421202.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/25/150425100.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/22/150422401.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/02/150402402.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/30/150430207.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/21/150121105.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/07/22/150722105.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/25/26/152526103.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/21/210421209.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/22/210422108.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502002.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/06/03/210603007.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502010.htmlrequests fail, retry!http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/03/210503005.htmlrequests fail, retry!</code></pre><p>由于数据量很大，所以这里我没有爬取完毕。    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第二篇，详细分析了爬取全过程。&lt;/p&gt;
&lt;p&gt;详细的代码开源在 GitHub 上：&lt;a href=&quot;https://github.com/dta0502/NBSPRC-spider&quot;&gt;NBSPRC-sp</summary>
      
    
    
    
    <category term="爬虫" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://matthew84.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫 -（一）页面分析</title>
    <link href="https://matthew84.cf/archives/d4af1e8a.html"/>
    <id>https://matthew84.cf/archives/d4af1e8a.html</id>
    <published>2020-11-03T10:59:23.000Z</published>
    <updated>2020-11-03T11:29:46.211Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第一篇，首先先分析一下页面，为后面的页面解析做准备。</p><p>详细的代码开源在 GitHub 上：<a href="https://github.com/dta0502/NBSPRC-spider">NBSPRC-spider</a>。</p><p>这里我就拿2016年的页面做下分析：<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html">2016 年统计用区划代码和城乡划分代码</a>。</p><h1 id="省级页面分析"><a href="#省级页面分析" class="headerlink" title="省级页面分析"></a>省级页面分析</h1><h2 id="省级信息提取"><a href="#省级信息提取" class="headerlink" title="省级信息提取"></a>省级信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html">2016 年统计用区划代码和城乡划分代码</a>这个页面，然后用 chrome 的 “检查” 工具看下我们要找的信息在哪。</p><p>这里我们需要爬取省级名称、省内市级信息的子链接这两个参数。</p><p>我们从图中可以发现，左边页面每一行对应的 XPath 路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;tr[@class&#x3D;&quot;provincetr&quot;]</span><br></pre></td></tr></table></figure><p>然后一行中每个省的信息在下一级的 td 标签内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">td&#x2F;a&#x2F;text()</span><br><span class="line">td&#x2F;a&#x2F;@href</span><br><span class="line">省级页面分析</span><br><span class="line">省级页面分析</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj1.webp"></p><h2 id="下级链接获取"><a href="#下级链接获取" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>省级页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;index.html</span><br></pre></td></tr></table></figure><p>下级页面的 URL（我这里以<code>浙江省</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>浙江省</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33.html</span><br></pre></td></tr></table></figure><p>所以我们可以通过如下方式获取真实的 URL 保存到一个列表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;index.html&quot;</span><br><span class="line"># provinceLink &#x3D; &quot;33.html&quot;</span><br><span class="line">provinceURL &#x3D; url[:-10] + provinceLink</span><br></pre></td></tr></table></figure><h1 id="市级页面分析"><a href="#市级页面分析" class="headerlink" title="市级页面分析"></a>市级页面分析</h1><h2 id="市级信息提取"><a href="#市级信息提取" class="headerlink" title="市级信息提取"></a>市级信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html">浙江省</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是市级页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj2.webp"></p><h2 id="下级链接获取-1"><a href="#下级链接获取-1" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>市级页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33.html</span><br></pre></td></tr></table></figure><p>下级页面的 URL（我这里以<code>杭州市</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;3301.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>杭州市</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33&#x2F;3301.html</span><br></pre></td></tr></table></figure><h1 id="区级页面分析"><a href="#区级页面分析" class="headerlink" title="区级页面分析"></a>区级页面分析</h1><h2 id="区级信息提取"><a href="#区级信息提取" class="headerlink" title="区级信息提取"></a>区级信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html">杭州市</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是区级页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj3.webp"></p><h2 id="下级链接获取-2"><a href="#下级链接获取-2" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>区级页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;3301.html</span><br></pre></td></tr></table></figure><p>下级页面的 URL（我这里以<code>上城区</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;01&#x2F;330102.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>上城区</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01&#x2F;330102.html</span><br></pre></td></tr></table></figure><h1 id="街道页面分析"><a href="#街道页面分析" class="headerlink" title="街道页面分析"></a>街道页面分析</h1><h2 id="街道信息提取"><a href="#街道信息提取" class="headerlink" title="街道信息提取"></a>街道信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html">上城区</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是街道页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj4.webp"></p><h2 id="下级链接获取-3"><a href="#下级链接获取-3" class="headerlink" title="下级链接获取"></a>下级链接获取</h2><p>街道页面的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;01&#x2F;330102.html</span><br></pre></td></tr></table></figure><p>街道页面的 URL（我这里以<code>湖滨街道</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.stats.gov.cn&#x2F;tjsj&#x2F;tjbz&#x2F;tjyqhdmhcxhfdm&#x2F;2016&#x2F;33&#x2F;01&#x2F;02&#x2F;330102003.html</span><br></pre></td></tr></table></figure><p>页面中提取到的信息（我这里以<code>湖滨街道</code>为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02&#x2F;330102003.html</span><br></pre></td></tr></table></figure><h1 id="居委会页面分析"><a href="#居委会页面分析" class="headerlink" title="居委会页面分析"></a>居委会页面分析</h1><h2 id="居委会信息提取"><a href="#居委会信息提取" class="headerlink" title="居委会信息提取"></a>居委会信息提取</h2><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/02/330102003.html">湖滨街道</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是居委会页面分析图：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/pacsuivj5.webp"><br>这里已经到了最底层，没有下级链接了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第一篇，首先先分析一下页面，为后面的页面解析做准备。&lt;/p&gt;
&lt;p&gt;详细的代码开源在 GitHub 上：&lt;a href=&quot;https://github.com/dta0502/NBSPRC-spider</summary>
      
    
    
    
    <category term="爬虫" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://matthew84.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="实战" scheme="https://matthew84.cf/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy 框架的使用之 Item Pipeline 的用法</title>
    <link href="https://matthew84.cf/archives/f3666482.html"/>
    <id>https://matthew84.cf/archives/f3666482.html</id>
    <published>2020-11-03T10:58:28.000Z</published>
    <updated>2020-11-03T11:08:08.487Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍一下 Scrapy 框架中的 Item Pipeline 的用法。</p><p>Item Pipeline 的调用发生在 Spider 产生 Item 之后。当 Spider 解析完 Response 之后，Item 就会传递到 Item Pipeline，被定义的 Item Pipeline 组件会顺次调用，完成一连串的处理过程，比如数据清洗、存储等。</p><p>Item Pipeline 的主要功能有如下 4 点。</p><ul><li>清理 HTML 数据。</li><li>验证爬取数据，检查爬取字段。</li><li>查重并丢弃重复内容。</li><li>将爬取结果保存到数据库。</li></ul><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>我们可以自定义 Item Pipeline，只需要实现指定的方法，其中必须要实现的一个方法是：<code>process_item(item, spider)</code>。</p><p>另外还有如下几个比较实用的方法。</p><ul><li><code>open_spider(spider)</code></li><li><code>close_spider(spider)</code></li><li><code>from_crawler(cls, crawler)</code></li></ul><p>下面我们详细介绍这几个方法的用法。</p><h2 id="process-item-item-spider"><a href="#process-item-item-spider" class="headerlink" title="process_item(item, spider)"></a><code>process_item(item, spider)</code></h2><p><code>process_item()</code>是必须要实现的方法，被定义的 Item Pipeline 会默认调用这个方法对 Item 进行处理。比如，我们可以进行数据处理或者将数据写入到数据库等操作。它必须返回 Item 类型的值或者抛出一个 DropItem 异常。</p><p><code>process_item()</code>方法的参数有如下两个。</p><ul><li>item，是 Item 对象，即被处理的 Item。</li><li>spider，是 Spider 对象，即生成该 Item 的 Spider。</li></ul><p><code>process_item()</code>方法的返回类型归纳如下。</p><ul><li>如果它返回的是 Item 对象，那么此 Item 会被低优先级的 Item Pipeline 的<code>process_item()</code>方法处理，直到所有的方法被调用完毕。</li><li>如果它抛出的是 DropItem 异常，那么此 Item 会被丢弃，不再进行处理。</li></ul><h2 id="open-spider-self-spider"><a href="#open-spider-self-spider" class="headerlink" title="open_spider(self, spider)"></a><code>open_spider(self, spider)</code></h2><p><code>open_spider()</code>方法是在 Spider 开启的时候被自动调用的。在这里我们可以做一些初始化操作，如开启数据库连接等。其中，参数 spider 就是被开启的 Spider 对象。</p><h2 id="close-spider-spider"><a href="#close-spider-spider" class="headerlink" title="close_spider(spider)"></a><code>close_spider(spider)</code></h2><p>close_spider() 方法是在 Spider 关闭的时候自动调用的。在这里我们可以做一些收尾工作，如关闭数据库连接等。其中，参数 spider 就是被关闭的 Spider 对象。</p><h2 id="from-crawler-cls-crawler"><a href="#from-crawler-cls-crawler" class="headerlink" title="from_crawler(cls, crawler)"></a><code>from_crawler(cls, crawler)</code></h2><p><code>from_crawler()</code>方法是一个类方法，用<code>@classmethod</code>标识，是一种依赖注入的方式。它的参数是 crawler，通过 crawler 对象，我们可以拿到 Scrapy 的所有核心组件，如全局配置的每个信息，然后创建一个 Pipeline 实例。参数 cls 就是 Class，最后返回一个 Class 实例。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="MongoDB-Pipeline"><a href="#MongoDB-Pipeline" class="headerlink" title="MongoDB Pipeline"></a>MongoDB Pipeline</h2><p>我们用一个 MongoPipeline 将信息保存到 MongoDB，在<code>pipelines.py</code>里添加如下类的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">class MongoPipeline(object):</span><br><span class="line">    def __init__(self, mongo_uri, mongo_db):</span><br><span class="line">        self.mongo_uri &#x3D; mongo_uri</span><br><span class="line">        self.mongo_db &#x3D; mongo_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(</span><br><span class="line">            mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),</span><br><span class="line">            mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DB&#39;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        self.client &#x3D; pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db &#x3D; self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.db[item.collection].insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.client.close()</span><br></pre></td></tr></table></figure><p>这里需要用到两个变量，MONGO_URI 和 MONGO_DB，即存储到 MongoDB 的链接地址和数据库名称。我们在 settings.py 里添加这两个变量，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MONGO_URI &#x3D; &#39;localhost&#39;</span><br><span class="line">MONGO_DB &#x3D; &#39;images360&#39;</span><br></pre></td></tr></table></figure><p>样一个保存到 MongoDB 的 Pipeline 的就创建好了。这里最主要的方法是<code>process_item()</code>方法，直接调用 Collection 对象的<code>insert()</code>方法即可完成数据的插入，最后返回 Item 对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文简单介绍一下 Scrapy 框架中的 Item Pipeline 的用法。&lt;/p&gt;
&lt;p&gt;Item Pipeline 的调用发生在 Spider 产生 Item 之后。当 Spider 解析完 Response 之后，Item 就会传递到 Item Pipeline，被</summary>
      
    
    
    
    <category term="爬虫" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Scrapy" scheme="https://matthew84.cf/categories/%E7%88%AC%E8%99%AB/Scrapy/"/>
    
    
    <category term="爬虫" scheme="https://matthew84.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Scrapy" scheme="https://matthew84.cf/tags/Scrapy/"/>
    
    <category term="Pipeline" scheme="https://matthew84.cf/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Python 内建容器类型</title>
    <link href="https://matthew84.cf/archives/93eb5e7e.html"/>
    <id>https://matthew84.cf/archives/93eb5e7e.html</id>
    <published>2020-11-03T09:50:39.000Z</published>
    <updated>2020-11-03T10:03:57.409Z</updated>
    
    <content type="html"><![CDATA[<p>在 Python 中，有四类最常见的内建容器类型：列表（list）、元组（tuple）、字典（dict）、集合（set）。通过单独或是组合使用它们，可以高效的完成很多事情。</p><div class="note simple"><p>Python 是一门高级编程语言，它所提供的内置容器类型，都是经过高度封装和抽象后的结果。和 “链表”、“红黑树”、“哈希表” 这些名字相比，所有 Python 内建类型的名字，都只描述了这个类型的功能特点，其他人完全没法只通过这些名字了解它们的哪怕一丁点内部细节。这是 Python 编程语言的优势之一。相比 C 语言这类更接近计算机底层的编程语言，Python 重新设计并实现了对编程者更友好的内置容器类型，屏蔽掉了内存管理等额外工作。为我们提供了更好的开发体验。</p></div><h1 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 - list"></a>列表 - list</h1><p>列表的特性：</p><ol><li>有序的集合</li><li>通过偏移来索引，从而读取数据</li><li>支持嵌套</li><li>可变的类型</li><li>查找和插入元素的时间随元素增多而变慢，时间复杂度 O (n)</li></ol><h1 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 - tuple"></a>元组 - tuple</h1><p>下面是元组和列表的几个区别。</p><h2 id="元组是不可变的"><a href="#元组是不可变的" class="headerlink" title="元组是不可变的"></a>元组是不可变的</h2><div class="note simple"><p>The key difference is that tuples are immutable. This means that you cannot change the values in a tuple once you have created it.</p></div><p><strong>最重要的区别：元组是不可变的，而列表是可变的</strong>。</p><p>下面两点是元组的优点。</p><h2 id="大小不同"><a href="#大小不同" class="headerlink" title="大小不同"></a>大小不同</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; tuple(range(1000))</span><br><span class="line">b &#x3D; list(range(1000))</span><br><span class="line"></span><br><span class="line">print(a.__sizeof__()) # 8024</span><br><span class="line">print(b.__sizeof__()) # 9088</span><br></pre></td></tr></table></figure><div class="note simple"><p>Due to the smaller size of a tuple operation, it becomes a bit faster, but not that much to mention about until you have a huge number of elements.</p></div><p>由于元组支持的操作比列表小， 所以元组会比列表稍稍快上那么一丢丢。但是除非你有巨量的数据要去处理，否者这一点不需要特别强调。</p><h2 id="元组可以作为字典的-key"><a href="#元组可以作为字典的-key" class="headerlink" title="元组可以作为字典的 key"></a>元组可以作为字典的 key</h2><div class="note simple"><p>You can’t use list as a dictionary identifier.</p></div><p>你不能将列表当作字典的 key，而元组可以（<strong>因为元组是不可变的</strong>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; (1,2)</span><br><span class="line">b &#x3D; [1,2] </span><br><span class="line"></span><br><span class="line">c &#x3D; &#123;a: 1&#125;     # OK</span><br><span class="line">c &#x3D; &#123;b: 1&#125;     # Error (TypeError: unhashable type: &#39;list&#39;)</span><br></pre></td></tr></table></figure><h1 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 - dict"></a>字典 - dict</h1><p>下面是字典的几个特点。</p><h2 id="查找速度快"><a href="#查找速度快" class="headerlink" title="查找速度快"></a>查找速度快</h2><p>无论 dict 有 10 个元素还是 10 万个元素，查找速度都一样。而 list 的查找速度随着元素增加而逐渐下降。不过 dict 的查找速度快不是没有代价的，dict 的缺点是占用内存大，还会浪费很多内容，list 正好相反，占用内存小，但是查找速度慢。由于 dict 是按 key 查找，所以，在一个 dict 中，key 不能重复。</p><h2 id="存储的-key-value-序对没有顺序"><a href="#存储的-key-value-序对没有顺序" class="headerlink" title="存储的 key-value 序对没有顺序"></a>存储的 key-value 序对没有顺序</h2><p>这一点和 list 不一样。</p><p>当我们打印下面这个 dict 会得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;</span><br><span class="line">    &#39;Adam&#39;: 95,</span><br><span class="line">    &#39;Lisa&#39;: 85,</span><br><span class="line">    &#39;Bart&#39;: 59</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;Lisa&#39;: 85, &#39;Adam&#39;: 95, &#39;Bart&#39;: 59&#125;</span><br></pre></td></tr></table></figure><p>打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明<strong>dict 内部是无序的，不能用 dict 存储有序的集合</strong>。</p><h2 id="作为-key-的元素必须不可变"><a href="#作为-key-的元素必须不可变" class="headerlink" title="作为 key 的元素必须不可变"></a>作为 key 的元素必须不可变</h2><p>Python 的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是 list 是可变的，就不能作为 key。不可变这个限制仅作用于 key，value 是否可变是无所谓的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#39;123&#39;: [1, 2, 3],  # key 是 str，value是list</span><br><span class="line">    123: &#39;123&#39;,        # key 是 int，value 是 str</span><br><span class="line">    (&#39;a&#39;, &#39;b&#39;): True   # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的 key 还是字符串，因为用起来最方便。</p><h1 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 - set"></a>集合 - set</h1><p>dict 的作用是建立一组 key 和一组 value 的映射关系，dict 的 key 是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set 就派上用场了。set 持有一系列元素，这一点和 list 很像，但是 set 的元素没有重复，而且是无序的，这点和 dict 的 key 很像。</p><p>set 的特点：</p><ol><li>set 的内部结构和 dict 很像，唯一区别是不存储 value，因此，判断一个元素是否在 set 中速度很快。</li><li>set 存储的元素和 dict 的 key 类似，必须是不变对象，因此，任何可变对象是不能放入 set 中的。</li><li>set 存储的元素也是没有顺序的。</li><li>set 不能包含重复的元素（set 会自动去掉重复的元素）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Python 中，有四类最常见的内建容器类型：列表（list）、元组（tuple）、字典（dict）、集合（set）。通过单独或是组合使用它们，可以高效的完成很多事情。&lt;/p&gt;
&lt;div class=&quot;note simple&quot;&gt;&lt;p&gt;Python 是一门高级编程语言，它</summary>
      
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="容器类型" scheme="https://matthew84.cf/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python集合用处</title>
    <link href="https://matthew84.cf/archives/56cd6720.html"/>
    <id>https://matthew84.cf/archives/56cd6720.html</id>
    <published>2020-11-03T09:50:15.000Z</published>
    <updated>2020-11-03T09:56:30.277Z</updated>
    
    <content type="html"><![CDATA[<p>集合的最大特点是：集合里边的元素是不可重复的并且集合内的元素还是无序的。</p><p>一般情况下集合常用的两个场景是：</p><ul><li>去重（如：列表去重）</li><li>关系测试（如：取交集、取并集、取差集等）</li></ul><h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="比较麻烦的方法-——-利用列表"><a href="#比较麻烦的方法-——-利用列表" class="headerlink" title="比较麻烦的方法 —— 利用列表"></a>比较麻烦的方法 —— 利用列表</h2><p>方法就是遍历一个列表，对其中的每个数据判断在不在第二个列表里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1&#x3D;[1,2,3,4]</span><br><span class="line">list2&#x3D;[3,4,5,6]</span><br><span class="line">list3&#x3D;[]</span><br><span class="line">for i in list1:</span><br><span class="line">   if i in list2:</span><br><span class="line">       list3.append(i)</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure><h2 id="运用集合来去重"><a href="#运用集合来去重" class="headerlink" title="运用集合来去重"></a>运用集合来去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set1 &#x3D; set(list1)</span><br><span class="line">print(&quot;list1去重后的set集合：&quot;,set1)</span><br><span class="line"># 再转化成一个列表</span><br><span class="line">new_list &#x3D; [i for i in set1]</span><br><span class="line">print(&quot;list1去重后的list列表：&quot;,new_list)</span><br></pre></td></tr></table></figure><h1 id="关系测试"><a href="#关系测试" class="headerlink" title="关系测试"></a>关系测试</h1><p>一些集合的最基本操作，如集合取交集、取并集、取差集、判断一个集合是不是另一个集合子集或者父集等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1 &#x3D; set([1,2,3,4,5])</span><br><span class="line">set2 &#x3D; set([3,4,5,6,7])</span><br></pre></td></tr></table></figure><h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><figure class="highlight plain"><figcaption><span>方法1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(set1.intersection(set2))</span><br><span class="line"># 方法2</span><br><span class="line">print(set1 &amp; set2)</span><br></pre></td></tr></table></figure><h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><figure class="highlight plain"><figcaption><span>方法1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(set1.union(set2))</span><br><span class="line"># 方法2</span><br><span class="line">print(set1 | set2)</span><br></pre></td></tr></table></figure><h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><p>这里需要注意顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># set1 - set2</span><br><span class="line">print(set1.difference(set2))</span><br><span class="line">print(set1 - set2)</span><br><span class="line"># set2 - set1</span><br><span class="line">print(set2.difference(set1))</span><br><span class="line">print(set2 - set1)</span><br></pre></td></tr></table></figure><h2 id="子集判断"><a href="#子集判断" class="headerlink" title="子集判断"></a>子集判断</h2><figure class="highlight plain"><figcaption><span>判断set1是否是set2的子集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(set1.issubset(set2))</span><br></pre></td></tr></table></figure><h2 id="父集判断"><a href="#父集判断" class="headerlink" title="父集判断"></a>父集判断</h2><figure class="highlight plain"><figcaption><span>判断set1是否是set2的父集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(set1.issuperset(set2))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;集合的最大特点是：集合里边的元素是不可重复的并且集合内的元素还是无序的。&lt;/p&gt;
&lt;p&gt;一般情况下集合常用的两个场景是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去重（如：列表去重）&lt;/li&gt;
&lt;li&gt;关系测试（如：取交集、取并集、取差集等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;去重&quot;</summary>
      
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="集合" scheme="https://matthew84.cf/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Python用list实现堆栈和队列</title>
    <link href="https://matthew84.cf/archives/63ac562f.html"/>
    <id>https://matthew84.cf/archives/63ac562f.html</id>
    <published>2020-11-03T09:36:40.000Z</published>
    <updated>2020-11-03T09:48:45.846Z</updated>
    
    <content type="html"><![CDATA[<p>Python中可以用list来模拟栈和队列：</p><ul><li><strong>栈（stack）</strong>: 只能在一端进行数据操作，遵循后进先出（LIFO）原则</li><li><strong>队列（queue）</strong>: 可以在两端进行数据操作，遵循先进先出（FIFO）原则，出队列的一端称为队首，入队列的一端称为队尾</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈要记录的数据"><a href="#栈要记录的数据" class="headerlink" title="栈要记录的数据"></a>栈要记录的数据</h2><ul><li>栈顶位置 top：注意这个 top 有两种理解方式，一种是表示栈的最后一个数据的位置，另一种是表示栈的最后一个数据的下一个位置，这两种理解对栈的操作代码有一定的影响</li><li>栈最大大小 size</li></ul><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><code>isEmpty()</code>：判断栈是否为空</li><li><code>isFull()</code>：判断栈是否已满</li><li><code>push(element)</code>：向栈中添加一个值，<strong>注意栈是否为满的</strong></li><li><code>pop()</code>：从栈中弹出一个值，<strong>注意栈是否为空</strong></li></ul><h2 id="Python-列表实现栈"><a href="#Python-列表实现栈" class="headerlink" title="Python 列表实现栈"></a>Python 列表实现栈</h2><figure class="highlight plain"><figcaption><span>StackException(Exception):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">class Stack(object):</span><br><span class="line">    def __init__(self,size &#x3D; 10):</span><br><span class="line">        self.S &#x3D; []</span><br><span class="line">        self.size &#x3D; size  # 栈大小</span><br><span class="line">        self.top &#x3D; -1     # 栈顶位置</span><br><span class="line"></span><br><span class="line">    def setSize(self, size):</span><br><span class="line">        # 设置栈的大小</span><br><span class="line">        self.size &#x3D; size    </span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判断栈是否为空</span><br><span class="line">        if self.top &#x3D;&#x3D; -1:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    </span><br><span class="line">    def isFull(self):</span><br><span class="line">        # 判断栈是否满</span><br><span class="line">        if self.top &#x3D;&#x3D; self.size - 1:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        # 查看栈顶的对象，但不移除</span><br><span class="line">        if self.isEmpty():</span><br><span class="line">            raise StackException(&#39;StackUnderflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.S[-1]</span><br><span class="line">            return element</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        # 移除栈顶对象，并返回该对象的值</span><br><span class="line">        if self.isEmpty():</span><br><span class="line">            raise StackException(&#39;StackUnderflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.S[-1]</span><br><span class="line">            self.top &#x3D; self.top - 1</span><br><span class="line">            del self.S[-1]</span><br><span class="line">            return element</span><br><span class="line"></span><br><span class="line">    def push(self, element):</span><br><span class="line">        # 把对象压入栈顶</span><br><span class="line">        if self.isFull():</span><br><span class="line">            raise StackException(&#39;StackOverflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            self.S.append(element)</span><br><span class="line">            self.top &#x3D; self.top + 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    s &#x3D; Stack()</span><br><span class="line">    # 压栈测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        s.push(i)</span><br><span class="line">    # 栈满测试</span><br><span class="line">    try:</span><br><span class="line">        s.push(1)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    # 出栈测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(s.pop())</span><br><span class="line">    # 栈空测试</span><br><span class="line">    try:</span><br><span class="line">        s.pop()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列要记录的数据"><a href="#队列要记录的数据" class="headerlink" title="队列要记录的数据"></a>队列要记录的数据</h2><ul><li>队头位置 end</li><li>队列的大小 size</li></ul><h2 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h2><div class="note simple"><p>利用数组 Q[1..n] 来实现含有 n-1 个元素队列（保留一位元素用来判断队列空或满）。该列有一个属性 Q.head 指向队头元素，属性 Q.tail 指向下一个新元素将要插入的位置，列中的元素存放在位置 Q.head, Q.head+1, …, Q.tail-1 上。</p><ul><li>初始时，Q.head = Q.tail = 1</li><li>当 Q.head = Q.tail 时， 队列为空</li><li>当 Q.head = Q.tail + 1 时，队列为满</li></ul></div><h2 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h2><ul><li>isEmpty()：判断队列是否为空</li><li>isFull()：判断队列是否已满</li><li>inQueue(element)：入队</li><li>outQueue()：出队</li></ul><h2 id="Python-列表实现队列"><a href="#Python-列表实现队列" class="headerlink" title="Python 列表实现队列"></a>Python 列表实现队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class QueueException(Exception):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">class Queue(object):</span><br><span class="line">    def __init__(self, size&#x3D;10):</span><br><span class="line">        self.Q &#x3D; []</span><br><span class="line">        self.size &#x3D; size  # 队列大小</span><br><span class="line">        self.end &#x3D; -1     # 队头位置</span><br><span class="line">    </span><br><span class="line">    def setSize(self, size):</span><br><span class="line">        # 设置队列的大小</span><br><span class="line">        self.size &#x3D; size</span><br><span class="line">    </span><br><span class="line">    def inQueue(self, element):</span><br><span class="line">        # 对象入队</span><br><span class="line">        if self.end &lt; self.size - 1:</span><br><span class="line">            self.Q.append(element)</span><br><span class="line">            self.end +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            raise QueueException(&#39;QueueFull&#39;)</span><br><span class="line">    </span><br><span class="line">    def outQueue(self):</span><br><span class="line">        # 对象出队</span><br><span class="line">        if self.end &#x3D;&#x3D; -1:</span><br><span class="line">            raise QueueException(&#39;QueueEmpty&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.Q[0]</span><br><span class="line">            self.Q &#x3D; self.Q[1:]</span><br><span class="line">            self.end -&#x3D; 1</span><br><span class="line">            return element</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    q &#x3D; Queue()</span><br><span class="line">    # 入队测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        q.inQueue(i)</span><br><span class="line">    # 队列满测试</span><br><span class="line">    try:</span><br><span class="line">        q.inQueue(1)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    # 出队测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(q.outQueue())</span><br><span class="line">    # 队列空测试</span><br><span class="line">    try:</span><br><span class="line">        q.outQueue()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Python中用list来模拟栈和队列</summary>
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="list" scheme="https://matthew84.cf/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的选择字体 (font-family)</title>
    <link href="https://matthew84.cf/archives/75cb947d.html"/>
    <id>https://matthew84.cf/archives/75cb947d.html</id>
    <published>2020-11-03T09:04:40.000Z</published>
    <updated>2020-11-03T09:35:05.163Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道，在不同操作系统、不同游览器里面默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同，那么如何设置字体显示效果会比较好呢？下面我们逐步的分析一下：</p><h1 id="首先我们看看各平台的默认字体情况"><a href="#首先我们看看各平台的默认字体情况" class="headerlink" title="首先我们看看各平台的默认字体情况"></a>首先我们看看各平台的默认字体情况</h1><h2 id="Window-下："><a href="#Window-下：" class="headerlink" title="Window 下："></a>Window 下：</h2><ul><li><p><strong>宋体（SimSun）</strong>：Win 下大部分游览器的默认字体，宋体在小字号下（如 12px、14px）的显示效果还可以接受，但是字号一大就非常糟糕了，所以使用的时候要注意。</p></li><li><p><strong>微软雅黑（”Microsoft Yahei”）</strong>：从 Vista 开始，微软提供了这款新的字体，一款无衬线的黑体类字体，并且拥有<code>Regular</code>、<code>Bold</code>两种粗细的字重，显著提高了字体的显示效果。现在这款字体已经成为 Windows 游览器中最值得使用的中文字体。从 Win8 开始，微软雅黑又加入了<code>Light</code>这款更细的字重，对于喜欢细字体的设计、开发人员又多了一个新的选择。</p></li><li><p><strong>Arial</strong>：Win 平台上默认的无衬线西文字体（为什么要说英文字体后面会解释），有多种变体，显示效果一般。</p></li><li><p><strong>Tahoma</strong>：十分常见的无衬线字体，被采用为 Windows 2000、Windows XP、Windows Server 2003 及 Sega 游戏主机 Dreamcast 等系统的预设字型，显示效果比 Arial 要好。</p></li><li><p><strong>Verdana</strong>：无衬线字体，优点在于它在小字上仍结构清晰端整、阅读辨识容易。</p></li></ul><p>其他：Windows 下默认字体列表：微软官网、维基百科、Office 字体</p><p>结论：微软雅黑为 Win 平台上最值得选择的中文字体，但非游览器默认，需要设置；西文字体的选择以<code>Arial</code>、<code>Tahoma</code>等无衬线字体为主。</p><h2 id="Mac-OS-下："><a href="#Mac-OS-下：" class="headerlink" title="Mac OS 下："></a>Mac OS 下：</h2><ul><li><p><strong>华文黑体（STHeiti）、华文细黑（STXihei）</strong>：属于同一字体家族系列，OS X 10.6 之前的简体中文系统界面默认字体，也是目前 Chrome 游览器下的默认字体，有<code>Regular</code>和<code>Bold</code>两个字重，显示效果可以接受，华文细黑也曾是我最喜欢的字体之一。</p></li><li><p><strong>黑体 - 简（Heiti SC）</strong>：从 10.6 开始，黑体 - 简代替华文黑体用作简体中文系统界面默认字体，苹果生态最常用的字体之一，包括 iPhone、iPad 等设备用的也是这款字体，显示效果不错，但是喇叭口设计遭人诟病。</p></li><li><p><strong>冬青黑体（ Hiragino Sans GB ）</strong>：听说又叫苹果丽黑，日文字体<code>Hiragino KakuGothic</code>的简体中文版，简体中文有<code>常规体</code>和<code>粗体</code>两种，冬青黑体是一款清新的专业印刷字体，小字号时足够清晰，拥有很多人的追捧。</p></li><li><p><strong>Times New Roman</strong>：Mac 平台 Safari 下默认的字体，是最常见且广为人知的西文衬线字体之一，众多网页浏览器和文字处理软件都是用它作为默认字体。</p></li><li><p><strong>Helvetica、Helvetica Neue</strong>：一种被广泛使用的传奇般的西文字体（这货还有专门的记录片呢），在微软使用山寨货的<code>Arial</code>时，乔布斯却花费重金获得了<code>Helvetica</code>苹果系统上的使用权，因此该字体也一直伴随着苹果用户，是苹果生态中最常用的西文字体。<code>Helvetica Neue</code>为<code>Helvetica</code>的改善版本，且增加了更多不同粗细与宽度的字形，共拥有 51 种字体版本，极大的满足了日常的使用。</p></li><li><p><strong>苹方（PingFang SC）</strong>：在 Mac OS X EL Capitan 上，苹果为中国用户打造了一款全新中文字体–<code>苹方</code>，去掉了为人诟病的喇叭口，整体造型看上去更加简洁，字族共六枚字体：<code>极细体</code>、<code>纤细体</code>、<code>细体</code>、<code>常规体</code>、<code>中黑体</code>、<code>中粗体</code>。</p></li><li><p><strong>San Francisco</strong>：同样是 Mac OS X EL Capitan 上最新发布的西文字体，感觉和<code>Helvetica</code>看上去差别不大，目前已经应用在 Mac OS 10.11+、iOS 9.0+、watch OS 等最新系统上。</p></li></ul><p>其他：Mac 下默认字体列表：苹果官网、维基百科</p><p>结论：目前苹方和 San Francisco 为苹果推出的最新字体，显示效果也最为优雅，但只有最新系统才能支持，而黑体 - 简和 Helvetica 可以获得更多系统版本支持，显示效果也相差无几，可以接受。</p><h2 id="Android-系统："><a href="#Android-系统：" class="headerlink" title="Android 系统："></a>Android 系统：</h2><ul><li><strong>Droid Sans、Droid Sans Fallback</strong>：<code>Droid Sans</code>为安卓系统中默认的西文字体，是一款人文主义无衬线字体，而<code>Droid Sans Fallback</code>则是包含汉字、日文假名、韩文的文字扩展支持。<br>结论：<code>Droid Sans</code>为默认的字体，并结合了中英文，无需单独设置。</li></ul><h2 id="iOS-系统："><a href="#iOS-系统：" class="headerlink" title="iOS 系统："></a>iOS 系统：</h2><p>iOS 系统的字体和 Mac OS 系统的字体相同，保证了 Mac 上的字体效果，iOS 设备就没有太大问题。</p><h2 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h2><ul><li><p><strong>文泉驿点阵宋体</strong>：类似宋体的衬线字体，一般不推荐使用。</p></li><li><p><strong>文泉驿微米黑</strong>：几乎是 Linux 社区现有的最佳简体中文字体。</p></li></ul><h1 id="选择字体需要注意的问题"><a href="#选择字体需要注意的问题" class="headerlink" title="选择字体需要注意的问题"></a>选择字体需要注意的问题</h1><h2 id="字体的中英文写法："><a href="#字体的中英文写法：" class="headerlink" title="字体的中英文写法："></a>字体的中英文写法：</h2><p>我们在操作系统中常常看到宋体、微软雅黑这样的字体名称，但实际上这只是字体的显示名称，而不是字体文件的名称，一般字体文件都是用英文命名的，如<code>SimSun</code>、<code>Microsoft Yahei</code>。在大多数情况下直接使用显示名称也能正确的显示，但是有一些用户的特殊设置会导致中文声明无效。</p><p>因此，<strong>保守的做法是使用字体的字体名称（英文）或者两者兼写</strong>。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-family: STXihei, &quot;Microsoft YaHei&quot;;</span><br><span class="line">font-family: STXihei, &quot;华文细黑&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;;</span><br></pre></td></tr></table></figure><h2 id="声明英文字体："><a href="#声明英文字体：" class="headerlink" title="声明英文字体："></a>声明英文字体：</h2><p>绝大部分中文字体里都包含英文字母和数字，不进行英文字体声明是没有问题的，但是大多数中文字体中的英文和数字的部分都不是特别漂亮，所以建议也对英文字体进行声明。<br><strong>由于英文字体中大多不包含中文，我们可以先进行英文字体的声明，这样不会影响到中文字体的选择，因此优先使用最优秀的英文字体，中文字体声明则紧随其次</strong>。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Arial, &quot;Microsoft YaHei&quot;;</span><br></pre></td></tr></table></figure><h2 id="照顾不同的操作系统："><a href="#照顾不同的操作系统：" class="headerlink" title="照顾不同的操作系统："></a>照顾不同的操作系统：</h2><ul><li><strong>英文、数字部分</strong>：在默认的操作系统中，Mac 和 Win 都会带有<code>Arial</code>、<code>Verdana</code>、<code>Tahoma</code>等几个预装字体，从显示效果来看，<code>Tahoma</code>要比<code>Arial</code>更加清晰一些，因此字体设置<code>Tahoma</code>最好放到前面，当找不到<code>Tahoma</code>时再使用<code>Arial</code>；而在 Mac 中，还拥有一款更加漂亮的<code>Helvetica</code>字体，所以为了照顾 Mac 用户有更好的体验，应该更优先设置<code>Helvetica</code>字体；Android 系统下默认的无衬线字体就可以接受，因此无需单独设置。最后，英文、数字字体的最佳写法如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial;</span><br></pre></td></tr></table></figure><ul><li><strong>中文部分</strong>：在 Win 下，微软雅黑为大部分人最常使用的中文字体，由于很多人安装 Office 的缘故，Mac 电脑中也会出现微软雅黑字体，因此把显示效果不错的微软雅黑加入到字体列表是个不错的选择；同样，为了保证 Mac 中更为优雅字体苹方（<code>PingFang SC</code>）、黑体 - 简（<code>Heiti SC</code>）、冬青黑体（<code>Hiragino Sans GB</code>）的优先显示，需要把这些字体放到中文字体列表的最前面；同时为了照顾到 Linux 操作系统的体验，还需要添加<code>文泉驿微米黑</code>字体。最后，中文字体部分最佳写法如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><p>中英文整合写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><h2 id="注意向下兼容"><a href="#注意向下兼容" class="headerlink" title="注意向下兼容"></a>注意向下兼容</h2><p>如果还需要考虑旧版本操作系统用户的话，不得不加上一些旧版操作系统存在的字体：Mac 中的<code>华文黑体</code>、<code>冬青黑体</code>，Win 中的<code>黑体</code>等。同样按照显示效果排列在列表后面，写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, STXihei, &quot;Microsoft YaHei&quot;, SimHei, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><p>加入了<code>STXihei</code>（<code>华文细黑</code>）和<code>SimHei</code>（<code>黑体</code>）。</p><h2 id="补充字体族名称"><a href="#补充字体族名称" class="headerlink" title="补充字体族名称"></a>补充字体族名称</h2><p>字体族大体上分为两类：<code>sans-serif</code>（无衬线体）和 <code>serif</code>（衬线体），<strong>当所有的字体都找不到时，我们可以使用字体族名称作为操作系统最后选择字体的方向</strong>。一般非衬线字体在显示器中的显示效果会比较好，因此我们需要在最后添加<code>sans-serif</code>，写法如下：。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><h1 id="我们看一下大公司的常见写法（2016-07-查看）"><a href="#我们看一下大公司的常见写法（2016-07-查看）" class="headerlink" title="我们看一下大公司的常见写法（2016.07 查看）"></a>我们看一下大公司的常见写法（2016.07 查看）</h1><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 14px&#x2F;1.5 &quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Heiti SC&quot;,&quot;WenQuanYi Micro Hei&quot;,sans-serif;</span><br></pre></td></tr></table></figure><p>小米公司优先使用<code>Helvetica Neue</code>这款字体以保证最新版本 Mac 用户的最佳体验，选择了 Arial 作为 Win 下默认英文字体及 Mac 的替代英文字体；中文字体方面首选了微软雅黑，然后选择了冬青黑体及黑体-简作为 Mac 上的替代方案；最后使用文泉驿微米黑兼顾了 Linux 系统。</p><h2 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h2><p>鉴于淘宝网改版频率较频繁，这里截图保存了一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 12px&#x2F;1.5 tahoma,arial,&#39;Hiragino Sans GB&#39;,&#39;\5b8b\4f53&#39;,sans-serif;</span><br></pre></td></tr></table></figure><p>其实从图中明显看出淘宝网的导航及内容有着大量的衬线字体，鉴于淘宝网站大部分字号比较小，显示效果也还可以接受。代码中可以看出淘宝使用了<code>Tahoma</code>、<code>Arial</code>作为首选英文字体，中文字体首选了<code>冬青黑体</code>，由于 Win 下没有预装该款字体，所以显示出了后面的<code>宋体</code>（<code>5b8b4f53</code>）为汉字宋体用 unicode 表示的写法，不用<code>SimSun</code>是因为 Firefox 的某些版本和 Opera 不支持<code>SimSun</code>的写法）</p><h2 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;lucida grande&quot;, &quot;lucida sans unicode&quot;, lucida, helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>自认为简书的阅读体验很棒，我们看看简书所用的字体，简书优先选择了<code>lucida</code>家族的系列字体作为英文字体，该系列字体在 Mac 和 Win 上都是预装的，并且有着不俗的表现；中文字体方面将<code>冬青黑体</code>作为最优先使用的字体，同样考虑了 Linux 系统。</p><p>各大公司的字体设置大同小异，这里不再一一举例查看，有兴趣的可以自己多多查看。</p><h1 id="其他的一些注意点"><a href="#其他的一些注意点" class="headerlink" title="其他的一些注意点"></a>其他的一些注意点</h1><h2 id="字体何时需要添加引号"><a href="#字体何时需要添加引号" class="headerlink" title="字体何时需要添加引号"></a>字体何时需要添加引号</h2><p>当字体具体某个取值中若有一种样式名称包含空格，则需要用双引号或单引号表示，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Microsoft YaHei&quot;, &quot;Arial Narrow&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>如果书写中文字体名称为了保证兼容性也会添加引号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;黑体-简&quot;, &quot;微软雅黑&quot;, &quot;文泉驿微米黑&quot;;</span><br></pre></td></tr></table></figure><h2 id="引用外部字体"><a href="#引用外部字体" class="headerlink" title="引用外部字体"></a>引用外部字体</h2><p>大多数的中文字体由于版权原因不能随意使用，这里推荐一个免版权而且漂亮的中文字体<code>思源黑体</code>，该字体为 Adobe 与 Google 推出的一款开源字体， 有七种字体粗细（<code>ExtraLight</code>、<code>Light</code>、<code>Normal</code>、<code>Regular</code>、<code>Medium</code>、<code>Bold</code>和<code>Heavy</code>），完全支持日文、韩文、繁体中文和简体中文，字形优美，依稀记得小米公司好像有使用过。</p><p>鉴于中文字体的体积比较大（一般字库全一点的中文字体动辄几 Mb），所以较少人会使用外部字体，如果真的需要引入，也可以考虑通过工具根据页面文字的使用多少单独生成中文字体，以减小文件大小。</p><h1 id="最后，推荐写法"><a href="#最后，推荐写法" class="headerlink" title="最后，推荐写法"></a>最后，推荐写法</h1><p>由于每个人的审美不一样，钟爱的字体也会有所有不同，这里给出我个人的常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>另外推荐两个 github 上的关于中文字体和排版的项目：</p><ul><li><a href="https://github.com/zenozeng/fonts.css">Fonts.css – 跨平台中文字体解决方案</a></li><li><a href="https://github.com/sofish/typo.css">typo.css – 中文网页重设与排版：一致化浏览器排版效果</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家都知道，在不同操作系统、不同游览器里面默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同，那么如何设置字体显示效果会比较好呢？下面我们逐步的分析一下：&lt;/p&gt;
&lt;h1 id=&quot;首先我们看看各平台的默认字体情况&quot;&gt;&lt;a href=&quot;#首先我们看看</summary>
      
    
    
    
    <category term="前端" scheme="https://matthew84.cf/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://matthew84.cf/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
    <category term="前端" scheme="https://matthew84.cf/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://matthew84.cf/tags/CSS/"/>
    
    <category term="选择字体" scheme="https://matthew84.cf/tags/%E9%80%89%E6%8B%A9%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>排序算法的 Python 实现以及时间复杂度分析</title>
    <link href="https://matthew84.cf/archives/42010ce.html"/>
    <id>https://matthew84.cf/archives/42010ce.html</id>
    <published>2020-11-03T06:43:00.000Z</published>
    <updated>2020-11-03T09:03:38.912Z</updated>
    
    <content type="html"><![CDATA[<p>我用 Python 实现了冒泡排序、选择排序、插入排序、归并排序、快速排序。然后简单讲了讲快速排序的优化，我们可以通过<strong>小数组采用插入排序</strong>来减少递归的开销；对于有一定顺序的数组，我采用<strong>三数取中</strong>来提高性能；对于包含大量重复数的数组，我用了<strong>三路快速排序</strong>来提高性能。<br>最后，我把这些排序算法应用在随机数组、升序数组、降序数组、包含大量重复数的数组上，比较了一下它们的耗时。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def BubbleSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        for j in range(len(nums)-i-1):</span><br><span class="line">            if nums[j] &gt; nums[j+1]:</span><br><span class="line">                exchange(nums,j,j+1)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>首先，找到数组中最小的那个元素，然后将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。然后在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在<strong>不断地选择剩余元素之中的最小者</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序体现的是一种分治思想（Divide and conquer），下面是其排序的步骤：</p><ol><li>将数组一分为二（Divide array into two halves）</li><li>对每部分进行递归式地排序（Recursively sort each half）</li><li>合并两个部分（Merge two halves）</li></ol><h2 id="merge-函数"><a href="#merge-函数" class="headerlink" title="merge () 函数"></a>merge () 函数</h2><p>具体步骤如下：</p><ol><li>给出原数组 a []，该数组的 low 到 mid，mid+1 到 high 的子数组是各自有序的。</li><li>将数组复制到辅助数组（auxiliary array）中，两部分数组的首元素分别以 i 和 j 为下标，给原数组首元素以 k 为下标。</li><li>比较 i 下标和 j 下标的元素，将较小值赋到 k 下标位置的元素内，然后对 k 和赋值的下标进行递增。</li><li>重复上述过程，直到比较完全部元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def merge(a,aux,low,mid,high):</span><br><span class="line">    i &#x3D; low</span><br><span class="line">    j &#x3D; mid+1</span><br><span class="line">    k &#x3D; 0</span><br><span class="line">    for k in range(low,high+1):</span><br><span class="line">        if i &gt; mid:</span><br><span class="line">            a[k] &#x3D; aux[j]</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        elif j &gt; high:</span><br><span class="line">            a[k] &#x3D; aux[i]</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            if aux[i] &gt; aux[j]:</span><br><span class="line">                a[k] &#x3D; aux[j]</span><br><span class="line">                j +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                a[k] &#x3D; aux[i]</span><br><span class="line">                i +&#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort () 函数"></a>sort () 函数</h2><p>我们要对数组<code>a[low..high]</code> 进行排序，先将它分为<code>a[low..mid]</code> 和<code>a[mid+1..high]</code>两部分，分别<strong>递归调用</strong>将它们单独排序，最后将有序的子数组归并为最终的排序结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,aux,low,high):</span><br><span class="line">    # 退出条件</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line">    sort(a,aux,low,mid)</span><br><span class="line">    sort(a,aux,mid+1,high)</span><br><span class="line">    merge(a,aux,low,mid,high)      </span><br></pre></td></tr></table></figure><h2 id="MergeSort-函数"><a href="#MergeSort-函数" class="headerlink" title="MergeSort () 函数"></a>MergeSort () 函数</h2><p>为了保证归并排序函数 MergeSort () 输入只有未排序的数组，这里调用前面的辅助函数 sort ()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def MergeSort(nums):</span><br><span class="line">    aux &#x3D; nums.copy()</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,aux,low,high)</span><br><span class="line">    return nums      </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O (nlogn)</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。</p><div class="note icon simple"><i class="note-icon fas fa-bullhorn"></i><p>分治策略指的是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p></div><p>下面是一个示例：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/plxupython1.webp"></p><div class="note simple"><p>来源：<a href="https://www.cnblogs.com/sfencs-hcy/p/10602598.html">快速排序 python 实现</a></p></div><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>下面的代码短小利于理解，但是空间复杂度大，使用了三个列表解析式，而且每次选取进行比较时需要遍历整个序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def QuickSort(a):</span><br><span class="line">    if len(a) &lt; 2:</span><br><span class="line">        return a</span><br><span class="line">    else:</span><br><span class="line">        pivot &#x3D; a[0]</span><br><span class="line">        less_than_pivot &#x3D; [x for x in a if x &lt; pivot]</span><br><span class="line">        more_than_pivot &#x3D; [x for x in a if x &gt; pivot]</span><br><span class="line">        pivot_list &#x3D; [x for x in a if x &#x3D;&#x3D; pivot]</span><br><span class="line">        return QuickSort(less_than_pivot) + pivot_list + QuickSort(more_than_pivot)      </span><br></pre></td></tr></table></figure><h2 id="原地排序实现"><a href="#原地排序实现" class="headerlink" title="原地排序实现"></a>原地排序实现</h2><pre><code>1. 切分 ——partition ()</code></pre><p>切分方法：先随意地取<code>a[low]</code>作为切分元素（即那个将会被排定的元素），然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素是没有排定的，因此我们交换它们的位置。如此继续，当两个指针相遇时，我们只需要将切分元素<code>a[low]</code>和左子元素最右侧的元素<code>a[j]</code>交换然后返回 j 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">    i &#x3D; low       # 循环内i&#x3D;i+1</span><br><span class="line">    j &#x3D; high + 1  # 循环内j&#x3D;j-1</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        i +&#x3D; 1   # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[i] &lt; a[low] and i &lt; high:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        j -&#x3D; 1   # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[j] &gt; a[low] and j &gt; low:</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 指针相遇后，j所在的元素小于low，进行互换</span><br><span class="line">    exchange(a,low,j)</span><br><span class="line">    </span><br><span class="line">    return j      </span><br></pre></td></tr></table></figure><p>这里有个细节需要注意下，这个代码相比我最初的代码改变了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">-   i &#x3D; low + 1</span><br><span class="line">+   i &#x3D; low       # 循环内i&#x3D;i+1</span><br><span class="line">-   j &#x3D; high</span><br><span class="line">+   j &#x3D; high + 1  # 循环内j&#x3D;j-1</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">+       i +&#x3D; 1   # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[i] &lt; a[low] and i &lt; high:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">+       j -&#x3D; 1   # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[j] &gt; a[low] and j &gt; low:</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 指针相遇后，j所在的元素小于low，进行互换</span><br><span class="line">    exchange(a,low,j)</span><br><span class="line">    </span><br><span class="line">    return j     </span><br></pre></td></tr></table></figure><p>如果没有这些代码，当碰到<code>[2,2,2]</code>这样的情况时，i 和 j 一直不会改变，永远无法满足<code>if i &gt;= j</code>，然后函数就一直在<code>while True</code>里边死循环。</p><pre><code>2. sort()函数</code></pre><p>快速排序递归地将子数组<code>a[low..high]</code>排序，先用<code>partition()</code>方法将<code>a[j]</code>放到一个合适位置，然后再用递归调用将其他位置的元素排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)     </span><br></pre></td></tr></table></figure><pre><code>3. QuickSort () 函数</code></pre><p>为了保证快速排序函数 QuickSort () 输入只有未排序的数组，这里调用前面的辅助函数 sort ()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def QuickSort(nums):</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,low,high)</span><br><span class="line">    return nums      </span><br></pre></td></tr></table></figure><h2 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h2><ul><li>最优情况：每一次的基准值都正好为序列的中位数，时间复杂度为 nlogn</li><li>最坏情况：<strong>每一次的基准值都恰好是序列的最大值或最小值，时间复杂度为 n^2</strong>。有意思的是如果每次选第一个数做基准值，但每次这个数又是最小值，那么序列本身就是有序的，但时间复杂度也是最高的<br>因此，要想优化时间复杂度，<strong>关键在于基准值的选择</strong>。</li></ul><h2 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h2><pre><code>1. 优化小数组效率</code></pre><p><strong>对于规模很小的情况，快速排序的优势并不明显（可能没有优势），而递归型的算法还会带来额外的开销</strong>。于是对于这类情况可以选择非递归型的算法来替代。</p><p>那就有两个问题：多小的数组算小数组？替换的算法是什么？</p><p>通常这个阈值设定为 10，替换的算法一般是插入排序。</p><p>下面是 Python 实现，这里只需要在 sort () 函数中加一个数组大小判断即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)      </span><br></pre></td></tr></table></figure><pre><code>2. 合理选择 pivot</code></pre><p>前面也讨论过，直接选择分区的第一个或最后一个元素做 pivot 是不合适的。对于已经排好序，或者接近排好序的情况，会进入最差情况，时间复杂度退化到 n^2。</p><p>pivot 选取的理想情况是：让分区中比 pivot 小的元素数量和比 pivot 大的元素数量差不多。较常用的做法是三数取中（ median of three ），即从第一项、最后一项、中间一项中取中位数作为 pivot。当然这并不能完全避免最差情况的发生。所以很多时候会采取更小心、更严谨的 pivot 选择方案（对于大数组特别重要）。比如先把大数组平均切分成左中右三个部分，每个部分用三数取中得到一个中位数，再从得到的三个中位数中找出中位数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def get_median(nums,low,high):</span><br><span class="line">    # 计算数组中间的元素的下标</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    # 目标: arr[mid] &lt;&#x3D; arr[high] </span><br><span class="line">    if nums[mid] &gt; nums[high]:</span><br><span class="line">        exchange(nums,mid,high)</span><br><span class="line">    # 目标: arr[low] &lt;&#x3D; arr[high]</span><br><span class="line">    if nums[low] &gt; nums[high]:</span><br><span class="line">        exchange(nums,low,high)</span><br><span class="line">    # 目标: arr[low] &gt;&#x3D; arr[mid]</span><br><span class="line">    if nums[low] &lt; nums[mid]:</span><br><span class="line">        exchange(nums,low,mid)</span><br><span class="line">    </span><br><span class="line">    # 此时，arr[mid] &lt;&#x3D; arr[low] &lt;&#x3D; arr[high]，low的位置上保存这三个位置中间的值</span><br><span class="line">    return nums[low]</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # 三数取中(median of three)，low的位置上保存这三个位置中间的值</span><br><span class="line">    _ &#x3D; get_median(a,low,high)</span><br><span class="line"></span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)      </span><br></pre></td></tr></table></figure><pre><code>3. 处理重复元素问题</code></pre><p>当一个数组里的元素全部一样大（或者存在大量相同元素）会令快速排序进入最差情况，因为不管怎么选 pivot，都会使分区结果一边很大一边很小。</p><p>为了解决这个问题，我们需要修改分区过程，思路跟上面说的两路分区（基本的快排）类似，只是现在我们需要小于 pivot、等于 pivot、大于 pivot 三个分区。</p><p>举个例子，待分割序列：<code>6 4 6 7 1 6 7 6 8 6</code>，其中<code>pivot=6</code>：</p><ul><li>未对与 key 元素相等处理的划分结果：<code>1 4 6 6 7 6 7 6 8 6</code><ul><li>下次的两个子序列为：<code>1 4 6</code> 和 <code>7 6 7 6 8 6</code></li></ul></li><li>对与 key 元素相等处理的划分结果：<code>1 4 6 6 6 6 6 7 8 7</code><ul><li>下次的两个子序列为：<code>1 4</code> 和 <code>7 8 7</code></li></ul></li></ul><p>经过对比，我们可以看出，<strong>在一次划分后，把与 key 相等的元素聚在一起，能减少迭代次数，效率会提高不少</strong>。</p><p>具体过程：</p><p>如下图，我们可以设置四个游标，左端 p、i，右端 j、q。i、j 的作用跟之前两路划分时候的左右游标相同，就是从两端向中间遍历序列，并将遍历到的元素与 pivot 比较，如果等于 pivot，则移到两端（i 对应的元素移到左端，j 对应的元素移到右端。移动的方式就是拿此元素和 a 或 d 对应的元素进行交换，所以 p 和 q 的作用就是记录等于 pivot 的元素移动过后的边界），反之，如果大于或小于 pivot，还按照之前两路划分的方式进行移动。这样一来，中间部分就和两路划分相同，两头是等于 pivot 的部分，我们只需要将这两部分移动到中间即可。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/plxupython2.webp"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">    p &#x3D; low + 1</span><br><span class="line">    i &#x3D; low + 1</span><br><span class="line">    j &#x3D; high</span><br><span class="line">    q &#x3D; high</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        while a[i] &lt;&#x3D; a[low] and i &lt; high:</span><br><span class="line">            # 与pivot相等的元素将其交换到p所在的位置</span><br><span class="line">            if a[i] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,p,i)</span><br><span class="line">                p +&#x3D; 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        while a[j] &gt;&#x3D; a[low] and j &gt; low:</span><br><span class="line">            # 与pivot相等的元素将其交换到q所在的位置</span><br><span class="line">            if a[j] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,j,q)</span><br><span class="line">                q -&#x3D; 1</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    i -&#x3D; 1</span><br><span class="line">    p -&#x3D; 1</span><br><span class="line">    while p &gt;&#x3D; low:</span><br><span class="line">        exchange(a, i, p)</span><br><span class="line">        i -&#x3D; 1</span><br><span class="line">        p -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    j +&#x3D; 1</span><br><span class="line">    q +&#x3D; 1</span><br><span class="line">    while q &lt;&#x3D; high:</span><br><span class="line">        exchange(a, q, j)</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        q +&#x3D; 1</span><br><span class="line">    </span><br><span class="line">    return i,j      </span><br></pre></td></tr></table></figure><p>下面是 sort () 函数，这里我只写了修改的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,low,high):</span><br><span class="line">    </span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    i,j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,i)</span><br><span class="line">    sort(a,j,high)      </span><br></pre></td></tr></table></figure><h2 id="整体代码实现"><a href="#整体代码实现" class="headerlink" title="整体代码实现"></a>整体代码实现</h2><p>下面是经过优化的快速排序代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br><span class="line"></span><br><span class="line">def partition(a,low,high):</span><br><span class="line">    p &#x3D; low + 1</span><br><span class="line">    i &#x3D; low + 1</span><br><span class="line">    j &#x3D; high</span><br><span class="line">    q &#x3D; high</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        while a[i] &lt;&#x3D; a[low] and i &lt; high:</span><br><span class="line">            # 与pivot相等的元素将其交换到p所在的位置</span><br><span class="line">            if a[i] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,p,i)</span><br><span class="line">                p +&#x3D; 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        while a[j] &gt;&#x3D; a[low] and j &gt; low:</span><br><span class="line">            # 与pivot相等的元素将其交换到q所在的位置</span><br><span class="line">            if a[j] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,j,q)</span><br><span class="line">                q -&#x3D; 1</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    i -&#x3D; 1</span><br><span class="line">    p -&#x3D; 1</span><br><span class="line">    while p &gt;&#x3D; low:</span><br><span class="line">        exchange(a, i, p)</span><br><span class="line">        i -&#x3D; 1</span><br><span class="line">        p -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    j +&#x3D; 1</span><br><span class="line">    q +&#x3D; 1</span><br><span class="line">    while q &lt;&#x3D; high:</span><br><span class="line">        exchange(a, q, j)</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        q +&#x3D; 1</span><br><span class="line">    </span><br><span class="line">    return i,j</span><br><span class="line"></span><br><span class="line">def get_median(nums,low,high):</span><br><span class="line">    # 计算数组中间的元素的下标</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    # 目标: arr[mid] &lt;&#x3D; arr[high] </span><br><span class="line">    if nums[mid] &gt; nums[high]:</span><br><span class="line">        exchange(nums,mid,high)</span><br><span class="line">    # 目标: arr[low] &lt;&#x3D; arr[high]</span><br><span class="line">    if nums[low] &gt; nums[high]:</span><br><span class="line">        exchange(nums,low,high)</span><br><span class="line">    # 目标: arr[low] &gt;&#x3D; arr[mid]</span><br><span class="line">    if nums[low] &lt; nums[mid]:</span><br><span class="line">        exchange(nums,low,mid)</span><br><span class="line">    </span><br><span class="line">    # 此时，arr[mid] &lt;&#x3D; arr[low] &lt;&#x3D; arr[high]，low的位置上保存这三个位置中间的值</span><br><span class="line">    return nums[low]</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # 三数取中(median of three)，low的位置上保存这三个位置中间的值</span><br><span class="line">    _ &#x3D; get_median(a,low,high)</span><br><span class="line"></span><br><span class="line">    i,j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,i)</span><br><span class="line">    sort(a,j,high)</span><br><span class="line"></span><br><span class="line">def QuickSort3Ways(nums):</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,low,high)</span><br><span class="line">    return nums</span><br><span class="line"></span><br><span class="line">nums &#x3D; [4,5,6,1,2,3,3,3,1,2]</span><br><span class="line">print(QuickSort(nums))     </span><br></pre></td></tr></table></figure><h1 id="快速排序和归并排序对比"><a href="#快速排序和归并排序对比" class="headerlink" title="快速排序和归并排序对比"></a>快速排序和归并排序对比</h1><p>快速排序和归并排序是互补的：</p><ul><li>归并排序：<ol><li>将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；</li><li>递归调用发生在处理整个数组之前；</li><li>一个数组被等分为两半。</li></ol></li><li>快速排序：<ol><li>当两个子数组都有序时，整个数组也就自然有序了；</li><li>递归调用发生在处理整个数组之后；</li><li>切分（partition）的位置取决于数组的内容。</li></ol></li></ul><h1 id="各大排序算法测试"><a href="#各大排序算法测试" class="headerlink" title="各大排序算法测试"></a>各大排序算法测试</h1><h2 id="计时函数"><a href="#计时函数" class="headerlink" title="计时函数"></a>计时函数</h2><p>不同数据集可以用同一个计时函数，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 计时函数</span><br><span class="line">def count_time(a,sortname):</span><br><span class="line">    time_start &#x3D; time.time()</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;BubbleSort&#39;:</span><br><span class="line">        BubbleSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;SelectSort&#39;:</span><br><span class="line">        SelectSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;InsertSort&#39;:</span><br><span class="line">        InsertSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;MergeSort&#39;:</span><br><span class="line">        MergeSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;QuickSort&#39;:</span><br><span class="line">        QuickSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;QuickSort3Ways&#39;:</span><br><span class="line">        QuickSort3Ways(a)</span><br><span class="line">    time_end &#x3D; time.time()</span><br><span class="line">    return (time_end - time_start)      </span><br></pre></td></tr></table></figure><h2 id="随机数据集"><a href="#随机数据集" class="headerlink" title="随机数据集"></a>随机数据集</h2><p>随机数据生成器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime      </span><br></pre></td></tr></table></figure><p>这里我们生成一个长度为 5000 的数组，然后重复测试 10 次，最后计算各个排序算法用时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">length &#x3D; 5000</span><br><span class="line">numberOfArrays &#x3D; 10</span><br><span class="line"></span><br><span class="line">print(&quot;BubbleSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;BubbleSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;SelectSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;SelectSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;InsertSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;InsertSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;MergeSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;MergeSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;QuickSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;QuickSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;QuickSort3Ways&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;QuickSort3Ways&#39;,length,numberOfArrays))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">30.023681640625</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.03202223777771</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">24.185371160507202</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.1900651454925537</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">0.1554875373840332</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.19011521339416504</span><br></pre></td></tr></table></figure><h2 id="降序数据集"><a href="#降序数据集" class="headerlink" title="降序数据集"></a>降序数据集</h2><p>这里我们看下这些排序算法在降序数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+       a.sort(reverse &#x3D; True)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>这里如果生成一个长度为 10000 的数组，快速排序会出现<code>RecursionError: maximum recursion depth exceeded in comparison</code>错误。这个因为 Python 中默认的最大递归深度是 989。解决方案：<strong>手动设置递归调用深度</strong>，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">+import sys</span><br><span class="line"></span><br><span class="line">+sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">        a.sort(reverse &#x3D; True)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>数组大小改变为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">45.00776267051697</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.393858909606934</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">48.275355100631714</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.18087530136108398</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">14.895536661148071</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.10853052139282227</span><br></pre></td></tr></table></figure><h2 id="升序数据集"><a href="#升序数据集" class="headerlink" title="升序数据集"></a>升序数据集</h2><p>这里我们看下这些排序算法在升序数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+       a.sort(reverse &#x3D; False)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>同样的，这里数组大小为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">14.935291051864624</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.371372699737549</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">0.008459329605102539</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.15901756286621094</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">16.011647939682007</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.10053849220275879</span><br></pre></td></tr></table></figure><h2 id="含有大量重复数的数组"><a href="#含有大量重复数的数组" class="headerlink" title="含有大量重复数的数组"></a>含有大量重复数的数组</h2><p>这里我们看下这些排序算法在含有大量重复数的数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">-           a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+           a.append(random.randint(999990, 1000000))  # 测试数据范围            </span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>同样的，这里数组大小为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">28.813392877578735</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.362754821777344</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">22.454782247543335</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.1563563346862793</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">0.15424251556396484</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.08862972259521484</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center"></th><th align="center">BubbleSort</th><th>SelectSort</th><th>InsertSort</th><th>MergeSort</th><th>QuickSort</th><th>QuickSort3Ways</th></tr></thead><tbody><tr><td align="center"> 随机数据集</td><td align="center"> 30.023</td><td>11.032</td><td>24.185</td><td>0.190</td><td>0.155</td><td>0.190</td></tr><tr><td align="center"> 升序数据集</td><td align="center"> 14.935</td><td>11.371</td><td><strong>0.008</strong></td><td>0.159</td><td><strong>16.011</strong></td><td>0.100</td></tr><tr><td align="center"> 降序数据集</td><td align="center"> 45.007</td><td>11.393</td><td>48.275</td><td>0.180</td><td><strong>14.895</strong></td><td>0.108</td></tr><tr><td align="center"> 大量重复数的数据集</td><td align="center"> 28.813</td><td>11.362</td><td>22.454</td><td>0.156</td><td>0.154</td><td><strong>0.088</strong></td></tr></tbody></table>经过优化后的三路快速排序在升序、降序、包含大量重复数的情况下表现均非常优异。]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我用 Python 实现了冒泡排序、选择排序、插入排序、归并排序、快速排序。然后简单讲了讲快速排序的优化，我们可以通过&lt;strong&gt;小数组采用插入排序&lt;/strong&gt;来减少递归的开销；对于有一定顺序的数组，我采用&lt;strong&gt;三数取中&lt;/strong&gt;来提高性能；对于</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="算法" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="计算机基础" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="算法" scheme="https://matthew84.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>风语咒</title>
    <link href="https://matthew84.cf/archives/c9490a15.html"/>
    <id>https://matthew84.cf/archives/c9490a15.html</id>
    <published>2020-10-31T04:19:28.000Z</published>
    <updated>2020-11-03T08:46:02.424Z</updated>
    
    <content type="html"><![CDATA[<div class="note red icon flat"><i class="note-icon fas fa-bullhorn"></i><p>众侠岚结阵。</p></div><iframe  id="fgyuvb" src="https://player.bilibili.com/player.html?aid=842628459&bvid=BV1554y1r7rr&cid=251155915&page=1&high_quality=1"      onload="adjustIframe(id);" height="" width="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">电影风语咒众侠岚结阵剪辑片段。</summary>
    
    
    
    <category term="娱乐" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="电影剪辑" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/%E7%94%B5%E5%BD%B1%E5%89%AA%E8%BE%91/"/>
    
    
    <category term="电影" scheme="https://matthew84.cf/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="剪辑片段" scheme="https://matthew84.cf/tags/%E5%89%AA%E8%BE%91%E7%89%87%E6%AE%B5/"/>
    
    <category term="风语咒" scheme="https://matthew84.cf/tags/%E9%A3%8E%E8%AF%AD%E5%92%92/"/>
    
  </entry>
  
  <entry>
    <title>灵魂摆渡·黄泉</title>
    <link href="https://matthew84.cf/archives/3d13b2cb.html"/>
    <id>https://matthew84.cf/archives/3d13b2cb.html</id>
    <published>2020-10-30T11:27:48.000Z</published>
    <updated>2020-10-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note orange icon flat"><i class="note-icon fas fa-bullhorn"></i><p>开篇无名入黄泉，杀死孟婆。</p></div><iframe id="lhpbldu" src="https://player.bilibili.com/player.html?aid=842612941&bvid=BV1354y1r7SC&cid=250992002&page=1&high_quality=1"     onload="adjustIframe(id);" height="" width="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">电影灵魂摆渡·黄泉剪辑片段</summary>
    
    
    
    <category term="娱乐" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="电影剪辑" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/%E7%94%B5%E5%BD%B1%E5%89%AA%E8%BE%91/"/>
    
    
    <category term="电影" scheme="https://matthew84.cf/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="剪辑片段" scheme="https://matthew84.cf/tags/%E5%89%AA%E8%BE%91%E7%89%87%E6%AE%B5/"/>
    
    <category term="灵魂摆渡·黄泉" scheme="https://matthew84.cf/tags/%E7%81%B5%E9%AD%82%E6%91%86%E6%B8%A1%C2%B7%E9%BB%84%E6%B3%89/"/>
    
  </entry>
  
  <entry>
    <title>白蛇·缘起</title>
    <link href="https://matthew84.cf/archives/4bc3d25a.html"/>
    <id>https://matthew84.cf/archives/4bc3d25a.html</id>
    <published>2020-10-30T11:24:56.000Z</published>
    <updated>2020-10-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>阿宣和小白一起去宝青坊。</p></div>   <iframe id="blue1" src="https://player.bilibili.com/player.html?aid=330138990&bvid=BV1nA411j7FR&cid=251139053&page=1&high_quality=1"       onload="adjustIframe(id);" width="" height="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="note green icon flat"><i class="note-icon fas fa-bullhorn"></i><p>阿宣第二次去宝青坊。</p></div><iframe  id="blue2" src="https://player.bilibili.com/player.html?aid=457731505&bvid=BV1j5411V7Dr&cid=251149732&page=1&high_quality=1"     onload="adjustIframe(id);" width="" height="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="note green icon flat"><i class="note-icon fas fa-bullhorn"></i><p>阿宣小白游船唱歌。</p></div><iframe  id="blue3" src="https://player.bilibili.com/player.html?aid=627743152&bvid=BV1Ut4y1e7BR&cid=251156520&page=1&high_quality=1"     onload="adjustIframe(id);" width="" height="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">电影白蛇·缘起剪辑片段。</summary>
    
    
    
    <category term="娱乐" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="电影剪辑" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/%E7%94%B5%E5%BD%B1%E5%89%AA%E8%BE%91/"/>
    
    
    <category term="白蛇·缘起" scheme="https://matthew84.cf/tags/%E7%99%BD%E8%9B%87%C2%B7%E7%BC%98%E8%B5%B7/"/>
    
    <category term="电影" scheme="https://matthew84.cf/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="剪辑片段" scheme="https://matthew84.cf/tags/%E5%89%AA%E8%BE%91%E7%89%87%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>阿里云九营齐开卡通图片</title>
    <link href="https://matthew84.cf/archives/23991835.html"/>
    <id>https://matthew84.cf/archives/23991835.html</id>
    <published>2020-10-30T08:39:06.000Z</published>
    <updated>2020-11-03T08:54:36.199Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning flat"><p>Hologres</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-hologres.webp"></p><div class="note warning flat"><p>Flink</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-flink.webp"></p><div class="note warning flat"><p>Dataworks</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-dataworks.webp"></p><div class="note warning flat"><p>SaaS</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-saas.webp"></p><div class="note warning flat"><p>Spark</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-spark.webp"></p><div class="note warning flat"><p>搜索与推荐</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-search.webp"></p><div class="note warning flat"><p>Elasticsearch</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-elasticsearch.webp"></p><div class="note warning flat"><p>云原生数据湖</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-uujuhu.webp"></p><div class="note warning flat"><p>PAI-DSW</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-pai-dsw.webp"></p>]]></content>
    
    
    <summary type="html">阿里云9营齐开卡通图片集合</summary>
    
    
    
    <category term="阿里云" scheme="https://matthew84.cf/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="训练营" scheme="https://matthew84.cf/categories/%E9%98%BF%E9%87%8C%E4%BA%91/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="阿里云" scheme="https://matthew84.cf/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="训练营" scheme="https://matthew84.cf/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    <category term="图库" scheme="https://matthew84.cf/tags/%E5%9B%BE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--兰斯洛特</title>
    <link href="https://matthew84.cf/archives/b65d7333.html"/>
    <id>https://matthew84.cf/archives/b65d7333.html</id>
    <published>2020-10-25T13:27:38.000Z</published>
    <updated>2020-10-31T02:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="兰斯洛特"><a href="#兰斯洛特" class="headerlink" title="兰斯洛特"></a>兰斯洛特</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>第四次战争间桐家所准备的英灵，本体为湖之骑士兰斯洛特。兰斯洛特本为Saber身边第一骑士，为了Saber立下汗马功劳，Saber也非常感激和尊敬他。阿尔托莉亚和格尼薇儿结婚后，阿尔托莉亚拜托兰斯洛特做了王后的护卫。知道王实际是女性，和王后结婚只不过是政治演戏的兰斯洛特看着王后每日孤独和悲伤，最后两人不幸地陷入了爱情。阿尔托莉亚对格尼薇儿心存歉意，知道后不但不生气，反而私下非常欣慰，但是最后东窗事发，阿尔托莉亚被迫和兰斯洛特战场相见。但一直到最后阿尔托莉亚也没有丝毫责怪兰斯洛特和格尼薇儿的意思，这反而增加了两人的负罪感。这种背叛信任的人的悔恨和对自己的诅咒，以及对王不了解自己真心的怨怒，一直到死仍然盘踞在兰斯洛特心里，所以他抛下了骑士的荣誉和高贵，变身为Berserker参加圣杯战争，希望和王交战，以寻找到救赎的办法。但是在即将击败Saber的时候，因为Berserker魔力暴走，抽空了Master和自身的备用魔力而动作陷入停顿，被Saber条件反射地刺杀，死在了王的怀抱中，Saber还没来得及把自己的真心告诉他，兰斯洛特的身体就消失了……</p><h2 id="骑士は徒手にて死せず（ナイト·オブ·オーナー）"><a href="#骑士は徒手にて死せず（ナイト·オブ·オーナー）" class="headerlink" title="骑士は徒手にて死せず（ナイト·オブ·オーナー）"></a>骑士は徒手にて死せず（ナイト·オブ·オーナー）</h2><p>骑士徒手也不会死（Knight of Owner＝持有者是骑士）<br>能够赋予手中的武器作为自己宝具的属性并加以驱使。不管是什么武器、兵器，在兰斯洛特拿起的时刻就会成为相当于Ｄ级的宝具。原先的Rank在此之上的宝具就会以原本的Rank置入Lancelot的支配之下。（因为Ferotto的策略，而没带著剑进行战斗的困境时，用(这里没读到)的树枝，打倒了ferotto的小故事的具体化。）<br>即使是现代的枪械、飞机，被Berserker的魔力侵蚀后也可以变成和传说中的武器同等级的宝具。同时对于他人的武器，只要被Berserker侵蚀，也会被夺去。<br>（能力原型：在传说中，亚瑟王对于兰斯洛特和王后格尼薇儿的恋情非常愤怒，但是当时基督教规定，妻子如果对他人只是保持有柏拉图式的爱慕，丈夫无权干涉，因此亚瑟王不能公开非难兰斯洛特，于是派出12位骑士，在兰斯洛特和王后幽会的地方暗杀他。兰斯洛特当时没有携带武器，但是他仅凭一根树枝就击败了来暗杀他的骑士们，平安脱逃。在Fate/Zero中该事件的起因被描写为兰斯洛特落入了敌人的陷阱。）</p><h2 id="己が荣光の为でなく（フォー·サムワンズ·グローリー）"><a href="#己が荣光の为でなく（フォー·サムワンズ·グローリー）" class="headerlink" title="己が荣光の为でなく（フォー·サムワンズ·グローリー）"></a>己が荣光の为でなく（フォー·サムワンズ·グローリー）</h2><p>不是为了自己的荣光（For　Someone’s　Glory＝为了某人的荣耀）<br>能够隐藏自己能力值的能力。 Lancelot在多次的冒险中都藉由伪装来隐藏身分而赢得了胜利的荣耀。Berserker可以变身为其他任何可以建立功勋的骑士，但是由于狂暴化，该能力劣化成了伪装。平时笼罩Berserker的黑色烟雾，就是这一能力的劣化形态的表现之一。<br>（能力原型：兰斯洛特被称为骑士中的骑士，是所有骑士的典范，是站在骑士中最高点的人。另外曾经因为朋友和人以名誉打赌赛马，为了保全朋友的名誉，兰斯洛特化装代替朋友参加赛马并取得了冠军。）这是作为典故而具体化的能力 。</p><h2 id="无毁なる湖光（アロンダイト）"><a href="#无毁なる湖光（アロンダイト）" class="headerlink" title="无毁なる湖光（アロンダイト）"></a>无毁なる湖光（アロンダイト）</h2><p>无毁的湖光(Alondight)<br>受到湖中精灵祝福的剑，不论受到什么样的攻击，都不会有一丝一毫的损伤。原本和Excalibur是成对的圣剑，但是因为Berserker使用它杀害了同伴，所以堕落为了魔剑。<br>这是Lancelot封印其他宝具才首次解放的真正的宝具。抽出这把剑的时候，Lancelot全部的参数值提升一个Rank ，再让全部的ST判定中成功率变成两倍。因为有打倒过龙的故事，能够对持有龙属性的英灵追加伤害。（Saber有龙种因子（英格兰的赤龙））<br>（能力原型：在传说中并没有这把剑的存在。兰斯洛特从小被湖中的仙女抚养长大，所以被人们称为湖之骑士。在传说中，亚瑟王在盛怒之下决定烧死王后格尼薇儿（火之试炼），兰斯洛特为了拯救爱人的性命而袭击刑场救人。在混乱中兰斯洛特失手误杀加文爵士的两个弟弟，同为圆桌骑士的加雷思和加埃里思，直接导致了圆桌骑士的崩溃。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;兰斯洛特&quot;&gt;&lt;a href=&quot;#兰斯洛特&quot; class=&quot;headerlink&quot; title=&quot;兰斯洛特&quot;&gt;&lt;/a&gt;兰斯洛特&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Berserker</title>
    <link href="https://matthew84.cf/archives/a1ee37f8.html"/>
    <id>https://matthew84.cf/archives/a1ee37f8.html</id>
    <published>2020-10-25T12:34:33.000Z</published>
    <updated>2020-11-03T08:44:58.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="狂战士—Berserker"><a href="#狂战士—Berserker" class="headerlink" title="狂战士—Berserker"></a>狂战士—Berserker</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>依莉雅的Servant。以丧失理性为代价大大强化了能力。如果说Saber是最优秀的Servant，那他就是力量最强的Servant。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>赫拉克勒斯<br>P1：<br>希腊神话中最有名的英雄。<br>是主神宙斯与人类的女性所生，半神半人的英雄。<br>虽然赫拉克勒斯在各方面都有着优秀的能力，但是他的性格却有着很大的问题。在他小时候，曾经因为一些小事而把教竖琴的老师活活打死。后来为了稳定心性，在成年之前一直在放羊。<br>再后来，成长为一个强壮的青年的赫拉克勒斯达成了数项伟业，底比斯王将女儿梅加拉许配给他，生下了两个孩子，他也得到了王位的继承权。</p><p>P2：<br>赫拉克勒斯年轻且强壮，在人类之中已没有对手可言。又娶了王的女儿，一直到他的两个儿子出生为止，他的前途看起来都是一帆风顺。<br>可是主神宙斯之妻赫拉憎恨宙斯与人类结合而生的赫拉克勒斯，总是要让他的命途充满了苦难。</p><p>P3：<br>首先，赫拉让赫拉克勒斯发狂，将梅加拉和两个孩子杀死。<br>赫拉克勒斯内疚于自己犯下的罪，便听从神的意见，成为了一个奴隶以此赎罪，而他要效忠之人，便是那个夺走自己本应继承之王位的欧律斯透斯。<br>欧律斯透斯嫉妒强壮的英雄赫拉克勒斯，便给予他数个难题，宣布若不能完成，则他要一直当奴隶。<br>以人类之力哪怕一项都难以达成的重重难关，那便是举世有名的，赫拉克勒斯所通过的十二个道难关。</p><p>P4：<br>虽然众神说作为赫拉克勒斯所应得的惩罚，他应闯过十道难关，但其中两次欧律斯透斯不予承认，便又追加了两道难关。<br>但是即便如此赫拉克勒斯仍平安达成，不再是努力之身，而作为其伟业的证明，他得到了不死的身体。<br>赫拉克勒斯以一人之力，达成了堪与特洛伊战争和阿尔戈探险队比肩的伟业，成为了希腊最大的英雄。<br>但是，赫拉克勒斯之后的人生仍然遍染着疯狂的色彩。</p><p>P5：<br>本应不死的他并没有死于赫拉的憎恨，而是被他那位已不知是第几任的妻子亲手毒杀。<br>结果，这位能以人的身躯与太阳神势均力敌地战斗的大英雄，就这样被女神那执拗的嫉妒心一步一步地推进了死路。<br>在临终之时，赫拉克勒斯自己将他那混身是毒的身体火葬，让自己听从主神宙斯的裁判。</p><p>P6：<br>众神协议的结果是承认赫拉克勒斯的伟业，按照宙斯的意志，在他死后于奥林匹斯山的一席与众神并列接受人们的祭祀，要求赫拉与他和解，并把青春女神赫柏赐他为妻。<br>虽然在神话中赫拉克勒斯曾经数次发狂，但是本来的他是一个十八般兵器皆运用自如的卓越的战士。<br>他拥有着适合除了Caster之外的其他六个职阶的资质，所持的最强宝具，是闯过十二道难关所得的，名为“射杀百头（Nine lives）”的弓矢。</p><h2 id="十二试炼："><a href="#十二试炼：" class="headerlink" title="十二试炼："></a>十二试炼：</h2><p>(1) 扼死铜筋铁骨的涅墨亚森林的猛狮；<br>(2) 杀死勒尔涅沼泽为害人畜的九头水蛇；<br>(3) 生擒克律涅亚山里金角铜蹄的赤牡鹿（一说赫拉克勒斯不小心杀了它）；<br>(4) 活捉埃里曼托斯山密林里的大野猪；<br>(5) 引河水清扫奥革阿斯积粪如山的牛圈；<br>(6) 赶走斯廷法罗湖上的怪鸟；<br>(7) 捕捉克里特岛发疯的公牛；<br>(8) 把狄奥墨得斯的吃人的马群从色雷斯赶到迈锡尼；<br>(9) 战胜阿马宗女人的首领希波吕忒，取来她的腰带；<br>(10) 从埃里忒亚岛赶回革律翁的红牛，途中将两座峭岩立在地中海的尽头（即赫拉克勒斯石柱）；<br>(11)获取赫斯佩里得斯圣园里的金苹果（为此曾代阿忒拉斯支撑整个苍穹。路上还曾战胜该亚的儿子安泰）；<br>(12) 把冥府的三头狗刻尔柏罗斯带到人间，后又送回冥府。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>God hand<br>十二道试炼<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/berserkerbkju1.webp"><br>隐藏的能力：就算是死亡也能自动复活（Raise）。累积的复活次数为十一回。<br>也就是说，不把Berserker打倒十二次是无法消灭他的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;狂战士—Berserker&quot;&gt;&lt;a href=&quot;#狂战士—Berserker&quot; class=&quot;headerlink&quot; title=&quot;狂战士—Berserker&quot;&gt;&lt;/a&gt;狂战士—Berserker&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cla</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--真·Assassin</title>
    <link href="https://matthew84.cf/archives/de51fe18.html"/>
    <id>https://matthew84.cf/archives/de51fe18.html</id>
    <published>2020-10-25T12:34:21.000Z</published>
    <updated>2020-11-03T08:44:51.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暗杀者—Assassin"><a href="#暗杀者—Assassin" class="headerlink" title="暗杀者—Assassin"></a>暗杀者—Assassin</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>第五回圣杯战争中，与间桐脏砚订下契约的Servant。真正的身份是以「山中老人」的称号闻名，十字军东征时期伊朗一带的杀手训练者。<br>戴着白色面具披着黑色斗篷。在黑暗中出没的他，因职业缘故没有留下名字。故严格来说「暗杀者」这个阶级不属于英灵而是亡灵(英灵候补)中的群体。本身能力低下。对自己的肉体进行改造作为对抗其它Servent的手段。刚出现在现世时没有知性，吃了ランサー的心脏后立刻飞跃性地提升。以ランサー的声音说话，也有受到ランサー的人格的影响。<br>从外表看不出来内心有着厚重的忠义感。但是只要是被其认同的话，就绝对不会其背叛主人。<br>被召唤时以佐佐木小次郎的尸体为媒介，可说是代替小次郎成为第五次战争中的暗杀者（Assassin）。通体漆黑，面具下的相貌跟面具的外观其实差不多，都像是裸露的头骨一般。参加战争的原因，是希望将过去成为暗杀者时不得不抛弃的名字永远留在世上。亦即他希望人们在提及他时想到的不是「山中老人」这个称号，而是他在成为暗杀者之前所拥有的本名。<br>实力并不强，几乎每一个Servant都能胜过他，甚至身为人类的言峰绮礼也能在策略加成下打退他。平常的战术是投掷被称为「ダーク」的小刀干扰敌人（从来没有Servant被打伤，伤害效果很差），搭配黑影及宝具来取得胜利。<br>冬木市所召唤出的Assassin的名字全部都是「哈桑」。因为「哈桑」只是个代名,就等于是每次从「哈桑·萨巴赫的群体」中召唤出一个而已，共有十八位。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>哈珊·萨巴赫（Hasan-e Sabbah，？-1124）波斯人，伊斯兰教什叶派尼查尔派（Nizari）的伊斯玛仪派（Ismailite）领袖，及通称阿萨辛派（Assassin）的创始人。曾在波斯国赖伊攻读神学，约十七岁时参加伊斯玛仪派。1076年前往埃及，居留大约三年。回到伊朗后各处奔走，扩大伊斯玛仪派的影响，劝化信徒甚多。1090年率众攻打塞琉古帝国戴拉姆省阿拉穆特城（Alamut，eagle’s nest），城中守军有人归顺，里应外合，使哈珊得以夺取该城。又经过一段动乱，哈珊建成领土分散而组织严密的政权。1118年最后一次率众大规模围攻阿拉穆特，后平静地度过馀年，禁欲修行，建立严格排斥世俗享乐的统治。着有教义学论文多种，强调在信仰问题上服从绝对权威。<br>由于他要求手下的人在政治性暗杀活动中必要时应自我牺牲，并多次使用激烈的暗杀手段对付敌人，因此十字军将其教派名称「阿萨辛」（Assassin）带回西方成为「暗杀」的意思。虽然坊间常见他利用麻醉药使其训练的杀手们进入迷幻状态，再送进秘密建造的花园，使人以为自己进入天堂；之后又再次服药昏迷，重回人间，从此坚信必有天堂而在行动时奋不顾身的说法；但这类叙述的真实性十分可议，相当程度可能是深受其害的十字军以讹传讹的丑化渲染。<br>也由于其根据地阿拉穆特城位在阿尔伯兹山脉（Alborz Mountains），因此他得到了Shaykh al Jabal 即「山中王子」（Prince of the Mountain）的称号。因「Shaykh」也有「老人」的意思，因此记述十字军东征的历史学者和马可波罗称他为「山中老人」（Old Man of the Mountain）。元朝宪宗八年（1258）旭烈兀率领大军进攻报达这个回教哈里发所驻的大城（caliphate），《新元史·郭侃传》写到汉人将领郭侃「破其兵七万，屠西城，又破其东城。东城殿宇皆构以沉檀木，举火焚之，香闻百里。」元朝的西征带给伊斯玛仪派相当大的打击，政治影响力和势力自此衰微。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Zabaniya<br>妄想心音<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/realassassinbkju1.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暗杀者—Assassin&quot;&gt;&lt;a href=&quot;#暗杀者—Assassin&quot; class=&quot;headerlink&quot; title=&quot;暗杀者—Assassin&quot;&gt;&lt;/a&gt;暗杀者—Assassin&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Assassin</title>
    <link href="https://matthew84.cf/archives/e8655ce7.html"/>
    <id>https://matthew84.cf/archives/e8655ce7.html</id>
    <published>2020-10-25T12:07:00.000Z</published>
    <updated>2020-11-03T08:44:45.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暗杀者—Assassin"><a href="#暗杀者—Assassin" class="headerlink" title="暗杀者—Assassin"></a>暗杀者—Assassin</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以Assassin的职阶被召唤出来的。与セイバー初次见面时自称佐佐木小次郎。是个身分存疑的架空剑豪。<br>佐佐木小次郎其人为虚构的存在，因此以Assassin的身份被呼唤出来的这位亡灵并非传说中的那位佐佐木小次郎，而是剑技符合其传说的一位无名剑士。话说回来，他生前连名字也没有。被三枝由纪香问到名字时，曾报出津田小次郎这名字。<br>召唤者虽是Caster，但作为凭依的MASTER是柳洞寺的山门。所以推测生前是跟柳洞寺有缘的武者。也因此无法离开柳洞寺的范围，如同地缚灵一般。生前因是平民百姓无望进入仕途，其本人除了剑技也无他求。<br>Caster只给予其足够存在二十天左右的魔力。原本应该以Assassin位阶出现的真アサシン被他取代。HF路线中，间桐脏砚曾用他的身体重新召唤出真アサシン。<br>因为是Caster钻规则漏洞召唤的缘故，也非真正的英灵，故没有宝具。这是与其它英灵的不同之处。背上的物干竿长达五尺馀，物干竿被很多人认为是备前长船长光，不过也有一说是备中青江，由名为青江一门的刀匠打造。物干竿只是一般称呼而已，正式的「铭」不详。记录上长度是三尺馀，但本编中Assassin所持有的物干竿是五尺馀，是规格外的长刀，长度已经接近枪。攻击范围大，但以实战来说一般根本难以使用。除了刀法超乎常人、能使用秘剑的Assassin以外，可能没有剑士能充分发挥这长刀。<br>与大多数攻击型英灵不同，他是防御型。曾借助柳洞寺的地形，再加上キャスター的援助击退バーサーカー的进攻。本来Assassin阶级是被Berserker所克制，虽说是占了地利跟人数的便宜，但他的实力也可见一斑。<br>不会使用魔术。纯以剑技达到宝具的领域。单以剑技而论，为第五次圣杯战争中最强的英灵。以个人剑术为基础使出的「对人魔剑·燕返し」具有多重次元屈折现象（キシュア·ゼルレッチ）的效果，能够将三种剑路的剑同时具现，是一种具有第二魔法部分性质的剑术。连Saber都没办法躲过的魔剑。<br>因为不是真正的Assassin，所以没有作为Assassin最重要的「気配遮断／气息遮断」这个技能，但身为武者的修为已达到「无想の域」（明镜止水／武人之心／架势(自我暗示)）这一境界，所以能够切断自己的气息。<br>梦想是能和Saber决一胜负，这份梦想在UBW线中才得以实现，最后因为自己的剑被打歪，使燕返し出现破绽而被saber击败。喜爱大自然，喜欢观赏花鸟风月。平时一言不发，无论什麽事情都不会把喜恶说出来。爱好是独自思考。剑的修练讲究顿悟，因此在精神方面的修为也很高。</p><h2 id="原型介绍："><a href="#原型介绍：" class="headerlink" title="原型介绍："></a>原型介绍：</h2><p>佐佐木小次郎<br>日本战国后期的著名剑客，富田势源的弟子，曾与中条流的钟卷自斋学习武术。为了修炼武艺而游历各国，并独自创立了自己的流派。相传他相貌英俊，擅长使用三尺的长刀，由于剑身相当长，攻击范围大，据称连天上的飞燕皆飞不出其长剑范围，被一切为二的绝招 故名“燕返”，与被后世尊为“剑圣”的宫本武藏于小仓岛（今严流岛）对决，战败被杀。其实小次郎的剑技未必输于武藏，但武藏除了是一名剑客外，也是名优秀的兵法家。相传两者相约在小仓岛决战，武藏故意迟到，令小次郎心烦意乱。决战中，武藏手持比对方更长的兵刃，更背对夕阳，利用落日余晖迷住佐佐木的视线，击杀小次郎，再由沙滩不留足迹地脱离现场。两强相争，斗智斗力，小次郎力则有之，智有不逮，可惜“燕返”也随之失传。<br>与出身于并不富裕的家庭的武藏相比，小次郎则是在拥护和赞扬的光环的环绕中成长起来的。但是，跟那些平庸的纨绔子弟不同，小次郎绝对是一个剑术奇材。虽然曾经跟随钟卷自斋学习过富田流的小太刀技法，但小次郎自己所创立的严流，使用的却是比小太刀长得多的太刀。小次郎的爱刀”长光”便是长达三尺二寸的长刀，而小次郎的绝技”燕返”，更是能够将长刀之利发挥到淋漓尽致的招式。可是，即使是这样的小次郎，却连”燕返”都没有使出就败在了宫本武藏的剑下。跟武藏决斗时的小次郎，无法发挥自己刀长的优势，因为武藏在决斗之前，特意制作了一把木刀，刀的长度是四尺二寸，比小次郎的”长光”长了整整一尺。<br>因为小次郎在决斗之前并未将绝技”燕返”传给弟子，这一招便从此失传。或许从《侍魂》里右京的必杀技之一”秘剑·燕返”中，可以领略到一点小次郎”燕返”的风采（不知道是否真的能划出一只火鸟来……）。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>信息不详<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/assassinbkju1.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暗杀者—Assassin&quot;&gt;&lt;a href=&quot;#暗杀者—Assassin&quot; class=&quot;headerlink&quot; title=&quot;暗杀者—Assassin&quot;&gt;&lt;/a&gt;暗杀者—Assassin&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Caster</title>
    <link href="https://matthew84.cf/archives/716c0d5d.html"/>
    <id>https://matthew84.cf/archives/716c0d5d.html</id>
    <published>2020-10-25T12:06:43.000Z</published>
    <updated>2020-11-03T08:44:37.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="魔术师—Rider"><a href="#魔术师—Rider" class="headerlink" title="魔术师—Rider"></a>魔术师—Rider</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以魔术为长，发挥出接近魔法等级的魔术，在这个以魔术师与使魔一组的圣杯战争中算是很不寻常的职种，而她也利用这种职种的设定的漏洞自己召唤出自己的使魔 Assassin。<br>Caster的真正身份，即古希腊科尔喀斯国的国王埃厄忒斯之女美狄亚（Medea）。在希腊神话中被视同为魔女的不幸女王，因自己的真爱背叛了自己造成她阴险的性格，但其本性依然是为了爱可以奉献一切的。 </p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>美狄亚<br>P1：<br>希腊神话中，被人当作魔女的代名词来对待的不幸的公主。<br>阿尔戈探险队里有名的英雄伊阿宋，在与夺去他父亲国家的珀利阿斯王的谈话之后，双方约定，若伊阿宋能赶赴极东之国科耳喀斯去将金羊毛带回，珀利阿斯便将国家奉还。<br>拥有金羊之皮的人，是科耳喀斯的公主美狄亚。她身为擅长魔道的科耳喀斯王埃厄忒斯之女，虽然学习了魔术，但其性格却还远不至于被称为魔女。</p><p>P2：<br>她的命运从英雄伊阿宋出现在她面前之时就被搅乱了。<br>支持伊阿宋的女神阿芙罗狄蒂见科耳喀斯王很难被说服，便控制了美狄亚的心，让她变成了一个为了伊阿宋不顾一切的少女。<br>最后，美狄亚就为了这个从来没见过面的、叫伊阿宋的外国男人，背叛了父王和自己的国家。<br>美狄亚使她父亲的魔术无效化，又让魔术做成的吐火之公牛无力化，使得伊阿宋得到了金羊毛皮。</p><p>P3：<br>科耳喀斯王自然非常生气，为了不让伊阿宋逃出科耳喀斯，他亲自上阵去追捕他。<br>为了让伊阿宋逃离其追捕，女神再次利用了美狄亚。<br>美狄亚乘上了那连名字都不知的爱人所驾驶的阿尔戈之船，在追来的父王面前将自己的弟弟亚比西托士分尸。<br>她的父亲叹息着，将被分尸的儿子的肉块收集起来。<br>趁这个机会阿尔戈之船逃离了追捕，伊阿宋平安地回到了伊奥尔科斯。</p><p>P4：<br>回到故乡的伊阿宋依约向父亲的仇人珀利阿斯王讨取国家，但是珀利阿斯王却不甘心就此罢休，他欲将伊阿宋置于死地。<br>伊阿宋凭借美狄亚的魔术三次自绝境脱险，美狄亚为了伊阿宋想了一个计策。<br>她请珀利阿斯王来做客，然后在他面前将一个仆人杀死。然后美狄亚用她的魔术使其复活。<br>然后美狄亚说她也可以在珀利阿斯王的身上施展这个可使人不死的魔术。</p><p>P5：<br>他自然喜出望外，便请美狄亚在他身上施术。自然，他之后就被分尸丢到了海里。<br>伊阿宋就这样成为了王，但阿尔戈之船上的伙伴们已经无法认可伊阿宋的行为，更无法容忍美狄亚的存在。<br>为了男人背叛了国家，将帮助自己的弟弟分尸，这次又欺骗了王夺取了宝座。<br>美狄亚被贬为魔女，与伊阿宋一起被驱出了国家。</p><p>P6：<br>伊阿宋与美狄亚之后到达了柯林斯，柯林斯王欢迎了他们。<br>在这个地方，美狄亚终于有了安宁的日子。<br>被人从大地彼方的国家带走，又被人当成魔女所惧怕，好不容易等来了那平和的日子，却也没能持续多久。<br>欣赏伊阿宋的柯林斯王想让女儿嫁给伊阿宋为妻，而伊阿宋也选择了王那年轻的女儿，而将美狄亚放逐。</p><p>P7：<br>而之后她所做出的行为，绝对符合她魔女之名。<br>美狄亚突然在伊阿宋的结婚典礼上现身，使用她的魔术，从柯林斯王和她的女儿开始，将参加婚礼的人逐个烧死，最后她只留下伊阿宋的一条命，便离开了王城。<br>离开柯林斯的美狄亚，其之后的去向已不得而知。<br>也有人说，人生只剩背叛与被人背叛的公主，成为了真正的魔女，一直在希腊的大地上彷徨。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Rule breaker<br>可破万法之符<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/casterbkju1.webp"><br>可破除所有魔术效果的短刀。<br>可以将被魔力强化的物体、以契约连起的关系以及用魔力制造的生命回复到“施术之前”的状态，是终极的对魔术宝具。<br>此魔术武器是背叛之魔女神性的具现化。<br>就如外表所见，攻击力极其微弱，杀伤力连小刀都不如。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;魔术师—Rider&quot;&gt;&lt;a href=&quot;#魔术师—Rider&quot; class=&quot;headerlink&quot; title=&quot;魔术师—Rider&quot;&gt;&lt;/a&gt;魔术师—Rider&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Rider</title>
    <link href="https://matthew84.cf/archives/66b3dcb.html"/>
    <id>https://matthew84.cf/archives/66b3dcb.html</id>
    <published>2020-10-25T12:06:27.000Z</published>
    <updated>2020-11-03T08:44:30.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="骑兵—Rider"><a href="#骑兵—Rider" class="headerlink" title="骑兵—Rider"></a>骑兵—Rider</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>骑兵的英灵。追求高机动性，持有强力的宝具的Servant。保有技能、宝具数量在Servant之中数一数二。<br>Master为间桐慎二和间桐樱。真名为有著「支配之女」之名的高尔根三姐妹的末女，希腊神话中的女怪梅杜莎(Medusa)。与其说是英灵倒不如说是神灵，持有多种多样的能力，曾有过被称为女神的时期，可惜因为负面的想念被当作牺牲品沦为女怪。因为Servant被召唤出来时是处於生前的全盛时期所以Rider还没变成女怪。<br>将她召唤出的Master是间桐樱，但因使用「伪臣之书」转移控制权的关系，而暂时听从慎二之命令。在Fate路线中只是作为让セイバー试剑的敌人甲出来被宰掉，UBW路线中则是被莫名其妙的被葛木宗一郎奇袭而退场，但是在HF路线中有著剧情上的出色表现。HF路线後ライダー消失了，却出现了一名叫间桐丽多的女性出现。<br>骑乘是Rider位阶的专长，也只有这个位阶能骑乘传说中的圣兽。最强的攻击为骑著天马，使用宝具骑英の手纲，冲撞敌人。行动敏捷，能灵活的在大楼间跳跃移动。在战斗时还能以石化魔眼和所持有的锁钉「无铭·短剑」作为武器。<br>战斗时的个性被形容是「散发著血的味道」。在三大路线中都做过使用他者封印．鲜血神殿把整个学校包围，准备吸光所有人的灵魂化为魔力的举动。有著可怕的杀戮者性格，不过事实上她最重视的是保护樱。而之所以会变成这种性格，似乎跟过去的经验有关。<br>十分在乎间桐樱，远超过普通Servant对Master的关心程度，为了樱几乎什么都会做，绝大部分为个人感情因素，不管用什么方法以保护Master樱为最优先考虑。判断出敌我之後决不容情，其速度相当惊人。本人并没有什么特别的兴趣而是像机械一样把工作完成到底。天敌为セイバー、葛木宗一郎、アサシン。<br>HF路线之後，作为樱的Servant留下来一起生活。樱的魔力已经足够供给了，但还是秘密地用自己封印．暗黑神殿吸血、吸精。吸血来自女性，吸精则是利用淫梦从男性处吸取。是否有吸血冲动不明。美缀绫子就曾被她吸过血。HF路线里曾对卫宫士郎使用淫梦。她并非死徒而是吸血种，对她来说补充魔力最有效也是最甜美的方法就是吸血。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>美杜莎<br>P1：<br>希腊神话中出现的，可以将她看到的人石化的半人半神之女怪。<br>在很多故事中她都被描写为蛇之化身的魔物。被英雄珀尔修斯所打倒。是一个被负面感情所造就的反英雄。<br>戈尔贡三姐妹——斯忒诺（Sthenno，力量）、尤琉蕾（Euryale，飞翔）、美杜莎（Medusa，支配）——中最小的三妹，与两位姐姐不同，她并非不死之身。居住于黄金苹果岛附近的“无形之岛”。</p><p>P2：<br>本来她们是美丽的女性，但是由于她们为海神波赛东所钟爱，因此受到海神之妻的诋毁，而嫉妒她们那美丽秀发的战争女神雅典娜让她们堕落为了魔物。<br>在变为魔物之后，她们一直居住在不见光的神殿，从来没有胡乱攻击别人。<br>美杜莎成为了众神那无道理可言之行为的牺牲者。最后的命运是因为众神的一时兴起而被人砍下了头颅。</p><p>P3：<br>从美杜莎被斩下首级之后所流出的血中，诞生了纯白的天马珀伽索斯。它可以说是海神波赛东的儿子。<br>从种类来分的话，与其说她是英灵，不如说是神灵更合适。其多种多样的能力是还身为女神之时所残留下来的。</p><h2 id="神话出处"><a href="#神话出处" class="headerlink" title="神话出处"></a>神话出处</h2><p>梅杜莎（Medusa），希腊神话中的女性怪物，以能将注视到的人化为石头的能力闻名。「高尔根」（Gorgans）三姊妹中最小的妹妹。梅杜莎、Stheno、和Euryale头发为蛇，具有利齿、面貌丑陋，有巨大翅膀。高尔根和格赖埃三姊妹（Graiae）是Phorcys和Ceto（两者皆为Pontus与盖亚（Gaia）的子女；Phorcys是最初的海神，他的配偶Ceto则是代表海洋危险面的海怪）的女儿。在某些版本的神话记述中，梅杜莎的两位姊姊是为了保护她，才将自己变成怪物（梅杜莎是三姊妹中唯一不具不死之身者）。<br>在最广为人知的神话版本中，梅杜莎原本是一位美丽的女子；海洋之神波赛顿（Poseidon）在雅典娜（Athena）的神殿里强暴了她。波赛顿和雅典娜曾竞争雅典守护者的地位，而波赛顿败给了雅典娜。<br>当雅典娜得知这件亵渎神殿的事情後，她将梅杜莎的容貌变得如同其姊一般做为惩罚。梅杜莎的头发变成毒蛇，而她的目光会将活物化为石像，她之後被放逐到极北之地以外。<br>由於波赛顿让梅杜莎怀孕，因此当希腊神话中的英雄，宙斯和达娜厄（Danae）之子珀修斯（Perseus）强迫老年化身格赖埃姊妹（Graiae）告诉他高尔根的所在，并利用雅典娜和赫密斯送他的镰刀和磨亮的盾牌砍下梅杜莎的头後，从颈子涌出的血中诞生了其子嗣：天马Pegasus和巨人Chrysaor。珀修斯回程时经过衣索比亚，正好遇到公主安卓美妲（Andromeda）将被献祭给海怪；他以梅杜莎的头将海怪石化救了她。珀修斯最後将梅杜莎的头献给雅典娜，雅典娜将其镶在神盾Aegis上。<br>在另一个版本的传说中，身为凡人的梅杜莎宣称她的美貌胜过阿芙洛蒂忒（Aphrodite），爱与美的女神。这使阿芙洛蒂忒把她和她的两位姊姊变成高尔根。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Breaker·Gorgon<br>自我封印·暗黑神殿<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/riderbkju1.webp"><br>Bellerophon<br>骑英之缰绳<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/riderbkju2.webp"><br>Blood Fort·Andromeda<br>他者封印·鲜血神殿<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/riderbkju3.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;骑兵—Rider&quot;&gt;&lt;a href=&quot;#骑兵—Rider&quot; class=&quot;headerlink&quot; title=&quot;骑兵—Rider&quot;&gt;&lt;/a&gt;骑兵—Rider&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
</feed>
