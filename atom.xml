<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longzhiの个人博客</title>
  
  
  <link href="https://matthew84.cf/atom.xml" rel="self"/>
  
  <link href="https://matthew84.cf/"/>
  <updated>2020-11-03T10:03:57.409Z</updated>
  <id>https://matthew84.cf/</id>
  
  <author>
    <name>longzhi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 内建容器类型</title>
    <link href="https://matthew84.cf/archives/93eb5e7e.html"/>
    <id>https://matthew84.cf/archives/93eb5e7e.html</id>
    <published>2020-11-03T09:50:39.000Z</published>
    <updated>2020-11-03T10:03:57.409Z</updated>
    
    <content type="html"><![CDATA[<p>在 Python 中，有四类最常见的内建容器类型：列表（list）、元组（tuple）、字典（dict）、集合（set）。通过单独或是组合使用它们，可以高效的完成很多事情。</p><div class="note simple"><p>Python 是一门高级编程语言，它所提供的内置容器类型，都是经过高度封装和抽象后的结果。和 “链表”、“红黑树”、“哈希表” 这些名字相比，所有 Python 内建类型的名字，都只描述了这个类型的功能特点，其他人完全没法只通过这些名字了解它们的哪怕一丁点内部细节。这是 Python 编程语言的优势之一。相比 C 语言这类更接近计算机底层的编程语言，Python 重新设计并实现了对编程者更友好的内置容器类型，屏蔽掉了内存管理等额外工作。为我们提供了更好的开发体验。</p></div><h1 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 - list"></a>列表 - list</h1><p>列表的特性：</p><ol><li>有序的集合</li><li>通过偏移来索引，从而读取数据</li><li>支持嵌套</li><li>可变的类型</li><li>查找和插入元素的时间随元素增多而变慢，时间复杂度 O (n)</li></ol><h1 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 - tuple"></a>元组 - tuple</h1><p>下面是元组和列表的几个区别。</p><h2 id="元组是不可变的"><a href="#元组是不可变的" class="headerlink" title="元组是不可变的"></a>元组是不可变的</h2><div class="note simple"><p>The key difference is that tuples are immutable. This means that you cannot change the values in a tuple once you have created it.</p></div><p><strong>最重要的区别：元组是不可变的，而列表是可变的</strong>。</p><p>下面两点是元组的优点。</p><h2 id="大小不同"><a href="#大小不同" class="headerlink" title="大小不同"></a>大小不同</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; tuple(range(1000))</span><br><span class="line">b &#x3D; list(range(1000))</span><br><span class="line"></span><br><span class="line">print(a.__sizeof__()) # 8024</span><br><span class="line">print(b.__sizeof__()) # 9088</span><br></pre></td></tr></table></figure><div class="note simple"><p>Due to the smaller size of a tuple operation, it becomes a bit faster, but not that much to mention about until you have a huge number of elements.</p></div><p>由于元组支持的操作比列表小， 所以元组会比列表稍稍快上那么一丢丢。但是除非你有巨量的数据要去处理，否者这一点不需要特别强调。</p><h2 id="元组可以作为字典的-key"><a href="#元组可以作为字典的-key" class="headerlink" title="元组可以作为字典的 key"></a>元组可以作为字典的 key</h2><div class="note simple"><p>You can’t use list as a dictionary identifier.</p></div><p>你不能将列表当作字典的 key，而元组可以（<strong>因为元组是不可变的</strong>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; (1,2)</span><br><span class="line">b &#x3D; [1,2] </span><br><span class="line"></span><br><span class="line">c &#x3D; &#123;a: 1&#125;     # OK</span><br><span class="line">c &#x3D; &#123;b: 1&#125;     # Error (TypeError: unhashable type: &#39;list&#39;)</span><br></pre></td></tr></table></figure><h1 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 - dict"></a>字典 - dict</h1><p>下面是字典的几个特点。</p><h2 id="查找速度快"><a href="#查找速度快" class="headerlink" title="查找速度快"></a>查找速度快</h2><p>无论 dict 有 10 个元素还是 10 万个元素，查找速度都一样。而 list 的查找速度随着元素增加而逐渐下降。不过 dict 的查找速度快不是没有代价的，dict 的缺点是占用内存大，还会浪费很多内容，list 正好相反，占用内存小，但是查找速度慢。由于 dict 是按 key 查找，所以，在一个 dict 中，key 不能重复。</p><h2 id="存储的-key-value-序对没有顺序"><a href="#存储的-key-value-序对没有顺序" class="headerlink" title="存储的 key-value 序对没有顺序"></a>存储的 key-value 序对没有顺序</h2><p>这一点和 list 不一样。</p><p>当我们打印下面这个 dict 会得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d &#x3D; &#123;</span><br><span class="line">    &#39;Adam&#39;: 95,</span><br><span class="line">    &#39;Lisa&#39;: 85,</span><br><span class="line">    &#39;Bart&#39;: 59</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;Lisa&#39;: 85, &#39;Adam&#39;: 95, &#39;Bart&#39;: 59&#125;</span><br></pre></td></tr></table></figure><p>打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明<strong>dict 内部是无序的，不能用 dict 存储有序的集合</strong>。</p><h2 id="作为-key-的元素必须不可变"><a href="#作为-key-的元素必须不可变" class="headerlink" title="作为 key 的元素必须不可变"></a>作为 key 的元素必须不可变</h2><p>Python 的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是 list 是可变的，就不能作为 key。不可变这个限制仅作用于 key，value 是否可变是无所谓的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#39;123&#39;: [1, 2, 3],  # key 是 str，value是list</span><br><span class="line">    123: &#39;123&#39;,        # key 是 int，value 是 str</span><br><span class="line">    (&#39;a&#39;, &#39;b&#39;): True   # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的 key 还是字符串，因为用起来最方便。</p><h1 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 - set"></a>集合 - set</h1><p>dict 的作用是建立一组 key 和一组 value 的映射关系，dict 的 key 是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set 就派上用场了。set 持有一系列元素，这一点和 list 很像，但是 set 的元素没有重复，而且是无序的，这点和 dict 的 key 很像。</p><p>set 的特点：</p><ol><li>set 的内部结构和 dict 很像，唯一区别是不存储 value，因此，判断一个元素是否在 set 中速度很快。</li><li>set 存储的元素和 dict 的 key 类似，必须是不变对象，因此，任何可变对象是不能放入 set 中的。</li><li>set 存储的元素也是没有顺序的。</li><li>set 不能包含重复的元素（set 会自动去掉重复的元素）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Python 中，有四类最常见的内建容器类型：列表（list）、元组（tuple）、字典（dict）、集合（set）。通过单独或是组合使用它们，可以高效的完成很多事情。&lt;/p&gt;
&lt;div class=&quot;note simple&quot;&gt;&lt;p&gt;Python 是一门高级编程语言，它</summary>
      
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="容器类型" scheme="https://matthew84.cf/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python集合用处</title>
    <link href="https://matthew84.cf/archives/56cd6720.html"/>
    <id>https://matthew84.cf/archives/56cd6720.html</id>
    <published>2020-11-03T09:50:15.000Z</published>
    <updated>2020-11-03T09:56:30.277Z</updated>
    
    <content type="html"><![CDATA[<p>集合的最大特点是：集合里边的元素是不可重复的并且集合内的元素还是无序的。</p><p>一般情况下集合常用的两个场景是：</p><ul><li>去重（如：列表去重）</li><li>关系测试（如：取交集、取并集、取差集等）</li></ul><h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="比较麻烦的方法-——-利用列表"><a href="#比较麻烦的方法-——-利用列表" class="headerlink" title="比较麻烦的方法 —— 利用列表"></a>比较麻烦的方法 —— 利用列表</h2><p>方法就是遍历一个列表，对其中的每个数据判断在不在第二个列表里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1&#x3D;[1,2,3,4]</span><br><span class="line">list2&#x3D;[3,4,5,6]</span><br><span class="line">list3&#x3D;[]</span><br><span class="line">for i in list1:</span><br><span class="line">   if i in list2:</span><br><span class="line">       list3.append(i)</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure><h2 id="运用集合来去重"><a href="#运用集合来去重" class="headerlink" title="运用集合来去重"></a>运用集合来去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set1 &#x3D; set(list1)</span><br><span class="line">print(&quot;list1去重后的set集合：&quot;,set1)</span><br><span class="line"># 再转化成一个列表</span><br><span class="line">new_list &#x3D; [i for i in set1]</span><br><span class="line">print(&quot;list1去重后的list列表：&quot;,new_list)</span><br></pre></td></tr></table></figure><h1 id="关系测试"><a href="#关系测试" class="headerlink" title="关系测试"></a>关系测试</h1><p>一些集合的最基本操作，如集合取交集、取并集、取差集、判断一个集合是不是另一个集合子集或者父集等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1 &#x3D; set([1,2,3,4,5])</span><br><span class="line">set2 &#x3D; set([3,4,5,6,7])</span><br></pre></td></tr></table></figure><h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><figure class="highlight plain"><figcaption><span>方法1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(set1.intersection(set2))</span><br><span class="line"># 方法2</span><br><span class="line">print(set1 &amp; set2)</span><br></pre></td></tr></table></figure><h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><figure class="highlight plain"><figcaption><span>方法1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(set1.union(set2))</span><br><span class="line"># 方法2</span><br><span class="line">print(set1 | set2)</span><br></pre></td></tr></table></figure><h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><p>这里需要注意顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># set1 - set2</span><br><span class="line">print(set1.difference(set2))</span><br><span class="line">print(set1 - set2)</span><br><span class="line"># set2 - set1</span><br><span class="line">print(set2.difference(set1))</span><br><span class="line">print(set2 - set1)</span><br></pre></td></tr></table></figure><h2 id="子集判断"><a href="#子集判断" class="headerlink" title="子集判断"></a>子集判断</h2><figure class="highlight plain"><figcaption><span>判断set1是否是set2的子集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(set1.issubset(set2))</span><br></pre></td></tr></table></figure><h2 id="父集判断"><a href="#父集判断" class="headerlink" title="父集判断"></a>父集判断</h2><figure class="highlight plain"><figcaption><span>判断set1是否是set2的父集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(set1.issuperset(set2))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;集合的最大特点是：集合里边的元素是不可重复的并且集合内的元素还是无序的。&lt;/p&gt;
&lt;p&gt;一般情况下集合常用的两个场景是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去重（如：列表去重）&lt;/li&gt;
&lt;li&gt;关系测试（如：取交集、取并集、取差集等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;去重&quot;</summary>
      
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="集合" scheme="https://matthew84.cf/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Python用list实现堆栈和队列</title>
    <link href="https://matthew84.cf/archives/63ac562f.html"/>
    <id>https://matthew84.cf/archives/63ac562f.html</id>
    <published>2020-11-03T09:36:40.000Z</published>
    <updated>2020-11-03T09:48:45.846Z</updated>
    
    <content type="html"><![CDATA[<p>Python中可以用list来模拟栈和队列：</p><ul><li><strong>栈（stack）</strong>: 只能在一端进行数据操作，遵循后进先出（LIFO）原则</li><li><strong>队列（queue）</strong>: 可以在两端进行数据操作，遵循先进先出（FIFO）原则，出队列的一端称为队首，入队列的一端称为队尾</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈要记录的数据"><a href="#栈要记录的数据" class="headerlink" title="栈要记录的数据"></a>栈要记录的数据</h2><ul><li>栈顶位置 top：注意这个 top 有两种理解方式，一种是表示栈的最后一个数据的位置，另一种是表示栈的最后一个数据的下一个位置，这两种理解对栈的操作代码有一定的影响</li><li>栈最大大小 size</li></ul><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><code>isEmpty()</code>：判断栈是否为空</li><li><code>isFull()</code>：判断栈是否已满</li><li><code>push(element)</code>：向栈中添加一个值，<strong>注意栈是否为满的</strong></li><li><code>pop()</code>：从栈中弹出一个值，<strong>注意栈是否为空</strong></li></ul><h2 id="Python-列表实现栈"><a href="#Python-列表实现栈" class="headerlink" title="Python 列表实现栈"></a>Python 列表实现栈</h2><figure class="highlight plain"><figcaption><span>StackException(Exception):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">class Stack(object):</span><br><span class="line">    def __init__(self,size &#x3D; 10):</span><br><span class="line">        self.S &#x3D; []</span><br><span class="line">        self.size &#x3D; size  # 栈大小</span><br><span class="line">        self.top &#x3D; -1     # 栈顶位置</span><br><span class="line"></span><br><span class="line">    def setSize(self, size):</span><br><span class="line">        # 设置栈的大小</span><br><span class="line">        self.size &#x3D; size    </span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判断栈是否为空</span><br><span class="line">        if self.top &#x3D;&#x3D; -1:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    </span><br><span class="line">    def isFull(self):</span><br><span class="line">        # 判断栈是否满</span><br><span class="line">        if self.top &#x3D;&#x3D; self.size - 1:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        # 查看栈顶的对象，但不移除</span><br><span class="line">        if self.isEmpty():</span><br><span class="line">            raise StackException(&#39;StackUnderflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.S[-1]</span><br><span class="line">            return element</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        # 移除栈顶对象，并返回该对象的值</span><br><span class="line">        if self.isEmpty():</span><br><span class="line">            raise StackException(&#39;StackUnderflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.S[-1]</span><br><span class="line">            self.top &#x3D; self.top - 1</span><br><span class="line">            del self.S[-1]</span><br><span class="line">            return element</span><br><span class="line"></span><br><span class="line">    def push(self, element):</span><br><span class="line">        # 把对象压入栈顶</span><br><span class="line">        if self.isFull():</span><br><span class="line">            raise StackException(&#39;StackOverflow&#39;)</span><br><span class="line">        else:</span><br><span class="line">            self.S.append(element)</span><br><span class="line">            self.top &#x3D; self.top + 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    s &#x3D; Stack()</span><br><span class="line">    # 压栈测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        s.push(i)</span><br><span class="line">    # 栈满测试</span><br><span class="line">    try:</span><br><span class="line">        s.push(1)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    # 出栈测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(s.pop())</span><br><span class="line">    # 栈空测试</span><br><span class="line">    try:</span><br><span class="line">        s.pop()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列要记录的数据"><a href="#队列要记录的数据" class="headerlink" title="队列要记录的数据"></a>队列要记录的数据</h2><ul><li>队头位置 end</li><li>队列的大小 size</li></ul><h2 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h2><div class="note simple"><p>利用数组 Q[1..n] 来实现含有 n-1 个元素队列（保留一位元素用来判断队列空或满）。该列有一个属性 Q.head 指向队头元素，属性 Q.tail 指向下一个新元素将要插入的位置，列中的元素存放在位置 Q.head, Q.head+1, …, Q.tail-1 上。</p><ul><li>初始时，Q.head = Q.tail = 1</li><li>当 Q.head = Q.tail 时， 队列为空</li><li>当 Q.head = Q.tail + 1 时，队列为满</li></ul></div><h2 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h2><ul><li>isEmpty()：判断队列是否为空</li><li>isFull()：判断队列是否已满</li><li>inQueue(element)：入队</li><li>outQueue()：出队</li></ul><h2 id="Python-列表实现队列"><a href="#Python-列表实现队列" class="headerlink" title="Python 列表实现队列"></a>Python 列表实现队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class QueueException(Exception):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.data</span><br><span class="line"></span><br><span class="line">class Queue(object):</span><br><span class="line">    def __init__(self, size&#x3D;10):</span><br><span class="line">        self.Q &#x3D; []</span><br><span class="line">        self.size &#x3D; size  # 队列大小</span><br><span class="line">        self.end &#x3D; -1     # 队头位置</span><br><span class="line">    </span><br><span class="line">    def setSize(self, size):</span><br><span class="line">        # 设置队列的大小</span><br><span class="line">        self.size &#x3D; size</span><br><span class="line">    </span><br><span class="line">    def inQueue(self, element):</span><br><span class="line">        # 对象入队</span><br><span class="line">        if self.end &lt; self.size - 1:</span><br><span class="line">            self.Q.append(element)</span><br><span class="line">            self.end +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            raise QueueException(&#39;QueueFull&#39;)</span><br><span class="line">    </span><br><span class="line">    def outQueue(self):</span><br><span class="line">        # 对象出队</span><br><span class="line">        if self.end &#x3D;&#x3D; -1:</span><br><span class="line">            raise QueueException(&#39;QueueEmpty&#39;)</span><br><span class="line">        else:</span><br><span class="line">            element &#x3D; self.Q[0]</span><br><span class="line">            self.Q &#x3D; self.Q[1:]</span><br><span class="line">            self.end -&#x3D; 1</span><br><span class="line">            return element</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    q &#x3D; Queue()</span><br><span class="line">    # 入队测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        q.inQueue(i)</span><br><span class="line">    # 队列满测试</span><br><span class="line">    try:</span><br><span class="line">        q.inQueue(1)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    # 出队测试</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(q.outQueue())</span><br><span class="line">    # 队列空测试</span><br><span class="line">    try:</span><br><span class="line">        q.outQueue()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Python中用list来模拟栈和队列</summary>
    
    
    
    <category term="Python" scheme="https://matthew84.cf/categories/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="数据结构" scheme="https://matthew84.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="list" scheme="https://matthew84.cf/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的选择字体 (font-family)</title>
    <link href="https://matthew84.cf/archives/75cb947d.html"/>
    <id>https://matthew84.cf/archives/75cb947d.html</id>
    <published>2020-11-03T09:04:40.000Z</published>
    <updated>2020-11-03T09:35:05.163Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道，在不同操作系统、不同游览器里面默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同，那么如何设置字体显示效果会比较好呢？下面我们逐步的分析一下：</p><h1 id="首先我们看看各平台的默认字体情况"><a href="#首先我们看看各平台的默认字体情况" class="headerlink" title="首先我们看看各平台的默认字体情况"></a>首先我们看看各平台的默认字体情况</h1><h2 id="Window-下："><a href="#Window-下：" class="headerlink" title="Window 下："></a>Window 下：</h2><ul><li><p><strong>宋体（SimSun）</strong>：Win 下大部分游览器的默认字体，宋体在小字号下（如 12px、14px）的显示效果还可以接受，但是字号一大就非常糟糕了，所以使用的时候要注意。</p></li><li><p><strong>微软雅黑（”Microsoft Yahei”）</strong>：从 Vista 开始，微软提供了这款新的字体，一款无衬线的黑体类字体，并且拥有<code>Regular</code>、<code>Bold</code>两种粗细的字重，显著提高了字体的显示效果。现在这款字体已经成为 Windows 游览器中最值得使用的中文字体。从 Win8 开始，微软雅黑又加入了<code>Light</code>这款更细的字重，对于喜欢细字体的设计、开发人员又多了一个新的选择。</p></li><li><p><strong>Arial</strong>：Win 平台上默认的无衬线西文字体（为什么要说英文字体后面会解释），有多种变体，显示效果一般。</p></li><li><p><strong>Tahoma</strong>：十分常见的无衬线字体，被采用为 Windows 2000、Windows XP、Windows Server 2003 及 Sega 游戏主机 Dreamcast 等系统的预设字型，显示效果比 Arial 要好。</p></li><li><p><strong>Verdana</strong>：无衬线字体，优点在于它在小字上仍结构清晰端整、阅读辨识容易。</p></li></ul><p>其他：Windows 下默认字体列表：微软官网、维基百科、Office 字体</p><p>结论：微软雅黑为 Win 平台上最值得选择的中文字体，但非游览器默认，需要设置；西文字体的选择以<code>Arial</code>、<code>Tahoma</code>等无衬线字体为主。</p><h2 id="Mac-OS-下："><a href="#Mac-OS-下：" class="headerlink" title="Mac OS 下："></a>Mac OS 下：</h2><ul><li><p><strong>华文黑体（STHeiti）、华文细黑（STXihei）</strong>：属于同一字体家族系列，OS X 10.6 之前的简体中文系统界面默认字体，也是目前 Chrome 游览器下的默认字体，有<code>Regular</code>和<code>Bold</code>两个字重，显示效果可以接受，华文细黑也曾是我最喜欢的字体之一。</p></li><li><p><strong>黑体 - 简（Heiti SC）</strong>：从 10.6 开始，黑体 - 简代替华文黑体用作简体中文系统界面默认字体，苹果生态最常用的字体之一，包括 iPhone、iPad 等设备用的也是这款字体，显示效果不错，但是喇叭口设计遭人诟病。</p></li><li><p><strong>冬青黑体（ Hiragino Sans GB ）</strong>：听说又叫苹果丽黑，日文字体<code>Hiragino KakuGothic</code>的简体中文版，简体中文有<code>常规体</code>和<code>粗体</code>两种，冬青黑体是一款清新的专业印刷字体，小字号时足够清晰，拥有很多人的追捧。</p></li><li><p><strong>Times New Roman</strong>：Mac 平台 Safari 下默认的字体，是最常见且广为人知的西文衬线字体之一，众多网页浏览器和文字处理软件都是用它作为默认字体。</p></li><li><p><strong>Helvetica、Helvetica Neue</strong>：一种被广泛使用的传奇般的西文字体（这货还有专门的记录片呢），在微软使用山寨货的<code>Arial</code>时，乔布斯却花费重金获得了<code>Helvetica</code>苹果系统上的使用权，因此该字体也一直伴随着苹果用户，是苹果生态中最常用的西文字体。<code>Helvetica Neue</code>为<code>Helvetica</code>的改善版本，且增加了更多不同粗细与宽度的字形，共拥有 51 种字体版本，极大的满足了日常的使用。</p></li><li><p><strong>苹方（PingFang SC）</strong>：在 Mac OS X EL Capitan 上，苹果为中国用户打造了一款全新中文字体–<code>苹方</code>，去掉了为人诟病的喇叭口，整体造型看上去更加简洁，字族共六枚字体：<code>极细体</code>、<code>纤细体</code>、<code>细体</code>、<code>常规体</code>、<code>中黑体</code>、<code>中粗体</code>。</p></li><li><p><strong>San Francisco</strong>：同样是 Mac OS X EL Capitan 上最新发布的西文字体，感觉和<code>Helvetica</code>看上去差别不大，目前已经应用在 Mac OS 10.11+、iOS 9.0+、watch OS 等最新系统上。</p></li></ul><p>其他：Mac 下默认字体列表：苹果官网、维基百科</p><p>结论：目前苹方和 San Francisco 为苹果推出的最新字体，显示效果也最为优雅，但只有最新系统才能支持，而黑体 - 简和 Helvetica 可以获得更多系统版本支持，显示效果也相差无几，可以接受。</p><h2 id="Android-系统："><a href="#Android-系统：" class="headerlink" title="Android 系统："></a>Android 系统：</h2><ul><li><strong>Droid Sans、Droid Sans Fallback</strong>：<code>Droid Sans</code>为安卓系统中默认的西文字体，是一款人文主义无衬线字体，而<code>Droid Sans Fallback</code>则是包含汉字、日文假名、韩文的文字扩展支持。<br>结论：<code>Droid Sans</code>为默认的字体，并结合了中英文，无需单独设置。</li></ul><h2 id="iOS-系统："><a href="#iOS-系统：" class="headerlink" title="iOS 系统："></a>iOS 系统：</h2><p>iOS 系统的字体和 Mac OS 系统的字体相同，保证了 Mac 上的字体效果，iOS 设备就没有太大问题。</p><h2 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h2><ul><li><p><strong>文泉驿点阵宋体</strong>：类似宋体的衬线字体，一般不推荐使用。</p></li><li><p><strong>文泉驿微米黑</strong>：几乎是 Linux 社区现有的最佳简体中文字体。</p></li></ul><h1 id="选择字体需要注意的问题"><a href="#选择字体需要注意的问题" class="headerlink" title="选择字体需要注意的问题"></a>选择字体需要注意的问题</h1><h2 id="字体的中英文写法："><a href="#字体的中英文写法：" class="headerlink" title="字体的中英文写法："></a>字体的中英文写法：</h2><p>我们在操作系统中常常看到宋体、微软雅黑这样的字体名称，但实际上这只是字体的显示名称，而不是字体文件的名称，一般字体文件都是用英文命名的，如<code>SimSun</code>、<code>Microsoft Yahei</code>。在大多数情况下直接使用显示名称也能正确的显示，但是有一些用户的特殊设置会导致中文声明无效。</p><p>因此，<strong>保守的做法是使用字体的字体名称（英文）或者两者兼写</strong>。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-family: STXihei, &quot;Microsoft YaHei&quot;;</span><br><span class="line">font-family: STXihei, &quot;华文细黑&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;;</span><br></pre></td></tr></table></figure><h2 id="声明英文字体："><a href="#声明英文字体：" class="headerlink" title="声明英文字体："></a>声明英文字体：</h2><p>绝大部分中文字体里都包含英文字母和数字，不进行英文字体声明是没有问题的，但是大多数中文字体中的英文和数字的部分都不是特别漂亮，所以建议也对英文字体进行声明。<br><strong>由于英文字体中大多不包含中文，我们可以先进行英文字体的声明，这样不会影响到中文字体的选择，因此优先使用最优秀的英文字体，中文字体声明则紧随其次</strong>。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Arial, &quot;Microsoft YaHei&quot;;</span><br></pre></td></tr></table></figure><h2 id="照顾不同的操作系统："><a href="#照顾不同的操作系统：" class="headerlink" title="照顾不同的操作系统："></a>照顾不同的操作系统：</h2><ul><li><strong>英文、数字部分</strong>：在默认的操作系统中，Mac 和 Win 都会带有<code>Arial</code>、<code>Verdana</code>、<code>Tahoma</code>等几个预装字体，从显示效果来看，<code>Tahoma</code>要比<code>Arial</code>更加清晰一些，因此字体设置<code>Tahoma</code>最好放到前面，当找不到<code>Tahoma</code>时再使用<code>Arial</code>；而在 Mac 中，还拥有一款更加漂亮的<code>Helvetica</code>字体，所以为了照顾 Mac 用户有更好的体验，应该更优先设置<code>Helvetica</code>字体；Android 系统下默认的无衬线字体就可以接受，因此无需单独设置。最后，英文、数字字体的最佳写法如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial;</span><br></pre></td></tr></table></figure><ul><li><strong>中文部分</strong>：在 Win 下，微软雅黑为大部分人最常使用的中文字体，由于很多人安装 Office 的缘故，Mac 电脑中也会出现微软雅黑字体，因此把显示效果不错的微软雅黑加入到字体列表是个不错的选择；同样，为了保证 Mac 中更为优雅字体苹方（<code>PingFang SC</code>）、黑体 - 简（<code>Heiti SC</code>）、冬青黑体（<code>Hiragino Sans GB</code>）的优先显示，需要把这些字体放到中文字体列表的最前面；同时为了照顾到 Linux 操作系统的体验，还需要添加<code>文泉驿微米黑</code>字体。最后，中文字体部分最佳写法如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><p>中英文整合写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><h2 id="注意向下兼容"><a href="#注意向下兼容" class="headerlink" title="注意向下兼容"></a>注意向下兼容</h2><p>如果还需要考虑旧版本操作系统用户的话，不得不加上一些旧版操作系统存在的字体：Mac 中的<code>华文黑体</code>、<code>冬青黑体</code>，Win 中的<code>黑体</code>等。同样按照显示效果排列在列表后面，写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, STXihei, &quot;Microsoft YaHei&quot;, SimHei, &quot;WenQuanYi Micro Hei&quot;;</span><br></pre></td></tr></table></figure><p>加入了<code>STXihei</code>（<code>华文细黑</code>）和<code>SimHei</code>（<code>黑体</code>）。</p><h2 id="补充字体族名称"><a href="#补充字体族名称" class="headerlink" title="补充字体族名称"></a>补充字体族名称</h2><p>字体族大体上分为两类：<code>sans-serif</code>（无衬线体）和 <code>serif</code>（衬线体），<strong>当所有的字体都找不到时，我们可以使用字体族名称作为操作系统最后选择字体的方向</strong>。一般非衬线字体在显示器中的显示效果会比较好，因此我们需要在最后添加<code>sans-serif</code>，写法如下：。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Helvetica, Tahoma, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><h1 id="我们看一下大公司的常见写法（2016-07-查看）"><a href="#我们看一下大公司的常见写法（2016-07-查看）" class="headerlink" title="我们看一下大公司的常见写法（2016.07 查看）"></a>我们看一下大公司的常见写法（2016.07 查看）</h1><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 14px&#x2F;1.5 &quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Heiti SC&quot;,&quot;WenQuanYi Micro Hei&quot;,sans-serif;</span><br></pre></td></tr></table></figure><p>小米公司优先使用<code>Helvetica Neue</code>这款字体以保证最新版本 Mac 用户的最佳体验，选择了 Arial 作为 Win 下默认英文字体及 Mac 的替代英文字体；中文字体方面首选了微软雅黑，然后选择了冬青黑体及黑体-简作为 Mac 上的替代方案；最后使用文泉驿微米黑兼顾了 Linux 系统。</p><h2 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h2><p>鉴于淘宝网改版频率较频繁，这里截图保存了一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 12px&#x2F;1.5 tahoma,arial,&#39;Hiragino Sans GB&#39;,&#39;\5b8b\4f53&#39;,sans-serif;</span><br></pre></td></tr></table></figure><p>其实从图中明显看出淘宝网的导航及内容有着大量的衬线字体，鉴于淘宝网站大部分字号比较小，显示效果也还可以接受。代码中可以看出淘宝使用了<code>Tahoma</code>、<code>Arial</code>作为首选英文字体，中文字体首选了<code>冬青黑体</code>，由于 Win 下没有预装该款字体，所以显示出了后面的<code>宋体</code>（<code>5b8b4f53</code>）为汉字宋体用 unicode 表示的写法，不用<code>SimSun</code>是因为 Firefox 的某些版本和 Opera 不支持<code>SimSun</code>的写法）</p><h2 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;lucida grande&quot;, &quot;lucida sans unicode&quot;, lucida, helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>自认为简书的阅读体验很棒，我们看看简书所用的字体，简书优先选择了<code>lucida</code>家族的系列字体作为英文字体，该系列字体在 Mac 和 Win 上都是预装的，并且有着不俗的表现；中文字体方面将<code>冬青黑体</code>作为最优先使用的字体，同样考虑了 Linux 系统。</p><p>各大公司的字体设置大同小异，这里不再一一举例查看，有兴趣的可以自己多多查看。</p><h1 id="其他的一些注意点"><a href="#其他的一些注意点" class="headerlink" title="其他的一些注意点"></a>其他的一些注意点</h1><h2 id="字体何时需要添加引号"><a href="#字体何时需要添加引号" class="headerlink" title="字体何时需要添加引号"></a>字体何时需要添加引号</h2><p>当字体具体某个取值中若有一种样式名称包含空格，则需要用双引号或单引号表示，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Microsoft YaHei&quot;, &quot;Arial Narrow&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>如果书写中文字体名称为了保证兼容性也会添加引号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;黑体-简&quot;, &quot;微软雅黑&quot;, &quot;文泉驿微米黑&quot;;</span><br></pre></td></tr></table></figure><h2 id="引用外部字体"><a href="#引用外部字体" class="headerlink" title="引用外部字体"></a>引用外部字体</h2><p>大多数的中文字体由于版权原因不能随意使用，这里推荐一个免版权而且漂亮的中文字体<code>思源黑体</code>，该字体为 Adobe 与 Google 推出的一款开源字体， 有七种字体粗细（<code>ExtraLight</code>、<code>Light</code>、<code>Normal</code>、<code>Regular</code>、<code>Medium</code>、<code>Bold</code>和<code>Heavy</code>），完全支持日文、韩文、繁体中文和简体中文，字形优美，依稀记得小米公司好像有使用过。</p><p>鉴于中文字体的体积比较大（一般字库全一点的中文字体动辄几 Mb），所以较少人会使用外部字体，如果真的需要引入，也可以考虑通过工具根据页面文字的使用多少单独生成中文字体，以减小文件大小。</p><h1 id="最后，推荐写法"><a href="#最后，推荐写法" class="headerlink" title="最后，推荐写法"></a>最后，推荐写法</h1><p>由于每个人的审美不一样，钟爱的字体也会有所有不同，这里给出我个人的常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;</span><br></pre></td></tr></table></figure><p>另外推荐两个 github 上的关于中文字体和排版的项目：</p><ul><li><a href="https://github.com/zenozeng/fonts.css">Fonts.css – 跨平台中文字体解决方案</a></li><li><a href="https://github.com/sofish/typo.css">typo.css – 中文网页重设与排版：一致化浏览器排版效果</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家都知道，在不同操作系统、不同游览器里面默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同，那么如何设置字体显示效果会比较好呢？下面我们逐步的分析一下：&lt;/p&gt;
&lt;h1 id=&quot;首先我们看看各平台的默认字体情况&quot;&gt;&lt;a href=&quot;#首先我们看看</summary>
      
    
    
    
    <category term="前端" scheme="https://matthew84.cf/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://matthew84.cf/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
    <category term="前端" scheme="https://matthew84.cf/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://matthew84.cf/tags/CSS/"/>
    
    <category term="选择字体" scheme="https://matthew84.cf/tags/%E9%80%89%E6%8B%A9%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>排序算法的 Python 实现以及时间复杂度分析</title>
    <link href="https://matthew84.cf/archives/42010ce.html"/>
    <id>https://matthew84.cf/archives/42010ce.html</id>
    <published>2020-11-03T06:43:00.000Z</published>
    <updated>2020-11-03T09:03:38.912Z</updated>
    
    <content type="html"><![CDATA[<p>我用 Python 实现了冒泡排序、选择排序、插入排序、归并排序、快速排序。然后简单讲了讲快速排序的优化，我们可以通过<strong>小数组采用插入排序</strong>来减少递归的开销；对于有一定顺序的数组，我采用<strong>三数取中</strong>来提高性能；对于包含大量重复数的数组，我用了<strong>三路快速排序</strong>来提高性能。<br>最后，我把这些排序算法应用在随机数组、升序数组、降序数组、包含大量重复数的数组上，比较了一下它们的耗时。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def BubbleSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        for j in range(len(nums)-i-1):</span><br><span class="line">            if nums[j] &gt; nums[j+1]:</span><br><span class="line">                exchange(nums,j,j+1)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>首先，找到数组中最小的那个元素，然后将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。然后在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在<strong>不断地选择剩余元素之中的最小者</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O (n^2)</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序体现的是一种分治思想（Divide and conquer），下面是其排序的步骤：</p><ol><li>将数组一分为二（Divide array into two halves）</li><li>对每部分进行递归式地排序（Recursively sort each half）</li><li>合并两个部分（Merge two halves）</li></ol><h2 id="merge-函数"><a href="#merge-函数" class="headerlink" title="merge () 函数"></a>merge () 函数</h2><p>具体步骤如下：</p><ol><li>给出原数组 a []，该数组的 low 到 mid，mid+1 到 high 的子数组是各自有序的。</li><li>将数组复制到辅助数组（auxiliary array）中，两部分数组的首元素分别以 i 和 j 为下标，给原数组首元素以 k 为下标。</li><li>比较 i 下标和 j 下标的元素，将较小值赋到 k 下标位置的元素内，然后对 k 和赋值的下标进行递增。</li><li>重复上述过程，直到比较完全部元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def merge(a,aux,low,mid,high):</span><br><span class="line">    i &#x3D; low</span><br><span class="line">    j &#x3D; mid+1</span><br><span class="line">    k &#x3D; 0</span><br><span class="line">    for k in range(low,high+1):</span><br><span class="line">        if i &gt; mid:</span><br><span class="line">            a[k] &#x3D; aux[j]</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        elif j &gt; high:</span><br><span class="line">            a[k] &#x3D; aux[i]</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            if aux[i] &gt; aux[j]:</span><br><span class="line">                a[k] &#x3D; aux[j]</span><br><span class="line">                j +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                a[k] &#x3D; aux[i]</span><br><span class="line">                i +&#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort () 函数"></a>sort () 函数</h2><p>我们要对数组<code>a[low..high]</code> 进行排序，先将它分为<code>a[low..mid]</code> 和<code>a[mid+1..high]</code>两部分，分别<strong>递归调用</strong>将它们单独排序，最后将有序的子数组归并为最终的排序结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,aux,low,high):</span><br><span class="line">    # 退出条件</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line">    sort(a,aux,low,mid)</span><br><span class="line">    sort(a,aux,mid+1,high)</span><br><span class="line">    merge(a,aux,low,mid,high)      </span><br></pre></td></tr></table></figure><h2 id="MergeSort-函数"><a href="#MergeSort-函数" class="headerlink" title="MergeSort () 函数"></a>MergeSort () 函数</h2><p>为了保证归并排序函数 MergeSort () 输入只有未排序的数组，这里调用前面的辅助函数 sort ()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def MergeSort(nums):</span><br><span class="line">    aux &#x3D; nums.copy()</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,aux,low,high)</span><br><span class="line">    return nums      </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O (nlogn)</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。</p><div class="note icon simple"><i class="note-icon fas fa-bullhorn"></i><p>分治策略指的是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p></div><p>下面是一个示例：<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/plxupython1.webp"></p><div class="note simple"><p>来源：<a href="https://www.cnblogs.com/sfencs-hcy/p/10602598.html">快速排序 python 实现</a></p></div><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>下面的代码短小利于理解，但是空间复杂度大，使用了三个列表解析式，而且每次选取进行比较时需要遍历整个序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def QuickSort(a):</span><br><span class="line">    if len(a) &lt; 2:</span><br><span class="line">        return a</span><br><span class="line">    else:</span><br><span class="line">        pivot &#x3D; a[0]</span><br><span class="line">        less_than_pivot &#x3D; [x for x in a if x &lt; pivot]</span><br><span class="line">        more_than_pivot &#x3D; [x for x in a if x &gt; pivot]</span><br><span class="line">        pivot_list &#x3D; [x for x in a if x &#x3D;&#x3D; pivot]</span><br><span class="line">        return QuickSort(less_than_pivot) + pivot_list + QuickSort(more_than_pivot)      </span><br></pre></td></tr></table></figure><h2 id="原地排序实现"><a href="#原地排序实现" class="headerlink" title="原地排序实现"></a>原地排序实现</h2><pre><code>1. 切分 ——partition ()</code></pre><p>切分方法：先随意地取<code>a[low]</code>作为切分元素（即那个将会被排定的元素），然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素是没有排定的，因此我们交换它们的位置。如此继续，当两个指针相遇时，我们只需要将切分元素<code>a[low]</code>和左子元素最右侧的元素<code>a[j]</code>交换然后返回 j 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">    i &#x3D; low       # 循环内i&#x3D;i+1</span><br><span class="line">    j &#x3D; high + 1  # 循环内j&#x3D;j-1</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        i +&#x3D; 1   # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[i] &lt; a[low] and i &lt; high:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        j -&#x3D; 1   # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[j] &gt; a[low] and j &gt; low:</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 指针相遇后，j所在的元素小于low，进行互换</span><br><span class="line">    exchange(a,low,j)</span><br><span class="line">    </span><br><span class="line">    return j      </span><br></pre></td></tr></table></figure><p>这里有个细节需要注意下，这个代码相比我最初的代码改变了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">-   i &#x3D; low + 1</span><br><span class="line">+   i &#x3D; low       # 循环内i&#x3D;i+1</span><br><span class="line">-   j &#x3D; high</span><br><span class="line">+   j &#x3D; high + 1  # 循环内j&#x3D;j-1</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">+       i +&#x3D; 1   # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[i] &lt; a[low] and i &lt; high:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">+       j -&#x3D; 1   # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况）</span><br><span class="line">        while a[j] &gt; a[low] and j &gt; low:</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 指针相遇后，j所在的元素小于low，进行互换</span><br><span class="line">    exchange(a,low,j)</span><br><span class="line">    </span><br><span class="line">    return j     </span><br></pre></td></tr></table></figure><p>如果没有这些代码，当碰到<code>[2,2,2]</code>这样的情况时，i 和 j 一直不会改变，永远无法满足<code>if i &gt;= j</code>，然后函数就一直在<code>while True</code>里边死循环。</p><pre><code>2. sort()函数</code></pre><p>快速排序递归地将子数组<code>a[low..high]</code>排序，先用<code>partition()</code>方法将<code>a[j]</code>放到一个合适位置，然后再用递归调用将其他位置的元素排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)     </span><br></pre></td></tr></table></figure><pre><code>3. QuickSort () 函数</code></pre><p>为了保证快速排序函数 QuickSort () 输入只有未排序的数组，这里调用前面的辅助函数 sort ()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def QuickSort(nums):</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,low,high)</span><br><span class="line">    return nums      </span><br></pre></td></tr></table></figure><h2 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h2><ul><li>最优情况：每一次的基准值都正好为序列的中位数，时间复杂度为 nlogn</li><li>最坏情况：<strong>每一次的基准值都恰好是序列的最大值或最小值，时间复杂度为 n^2</strong>。有意思的是如果每次选第一个数做基准值，但每次这个数又是最小值，那么序列本身就是有序的，但时间复杂度也是最高的<br>因此，要想优化时间复杂度，<strong>关键在于基准值的选择</strong>。</li></ul><h2 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h2><pre><code>1. 优化小数组效率</code></pre><p><strong>对于规模很小的情况，快速排序的优势并不明显（可能没有优势），而递归型的算法还会带来额外的开销</strong>。于是对于这类情况可以选择非递归型的算法来替代。</p><p>那就有两个问题：多小的数组算小数组？替换的算法是什么？</p><p>通常这个阈值设定为 10，替换的算法一般是插入排序。</p><p>下面是 Python 实现，这里只需要在 sort () 函数中加一个数组大小判断即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)      </span><br></pre></td></tr></table></figure><pre><code>2. 合理选择 pivot</code></pre><p>前面也讨论过，直接选择分区的第一个或最后一个元素做 pivot 是不合适的。对于已经排好序，或者接近排好序的情况，会进入最差情况，时间复杂度退化到 n^2。</p><p>pivot 选取的理想情况是：让分区中比 pivot 小的元素数量和比 pivot 大的元素数量差不多。较常用的做法是三数取中（ median of three ），即从第一项、最后一项、中间一项中取中位数作为 pivot。当然这并不能完全避免最差情况的发生。所以很多时候会采取更小心、更严谨的 pivot 选择方案（对于大数组特别重要）。比如先把大数组平均切分成左中右三个部分，每个部分用三数取中得到一个中位数，再从得到的三个中位数中找出中位数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def get_median(nums,low,high):</span><br><span class="line">    # 计算数组中间的元素的下标</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    # 目标: arr[mid] &lt;&#x3D; arr[high] </span><br><span class="line">    if nums[mid] &gt; nums[high]:</span><br><span class="line">        exchange(nums,mid,high)</span><br><span class="line">    # 目标: arr[low] &lt;&#x3D; arr[high]</span><br><span class="line">    if nums[low] &gt; nums[high]:</span><br><span class="line">        exchange(nums,low,high)</span><br><span class="line">    # 目标: arr[low] &gt;&#x3D; arr[mid]</span><br><span class="line">    if nums[low] &lt; nums[mid]:</span><br><span class="line">        exchange(nums,low,mid)</span><br><span class="line">    </span><br><span class="line">    # 此时，arr[mid] &lt;&#x3D; arr[low] &lt;&#x3D; arr[high]，low的位置上保存这三个位置中间的值</span><br><span class="line">    return nums[low]</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # 三数取中(median of three)，low的位置上保存这三个位置中间的值</span><br><span class="line">    _ &#x3D; get_median(a,low,high)</span><br><span class="line"></span><br><span class="line">    j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,j-1)</span><br><span class="line">    sort(a,j+1,high)      </span><br></pre></td></tr></table></figure><pre><code>3. 处理重复元素问题</code></pre><p>当一个数组里的元素全部一样大（或者存在大量相同元素）会令快速排序进入最差情况，因为不管怎么选 pivot，都会使分区结果一边很大一边很小。</p><p>为了解决这个问题，我们需要修改分区过程，思路跟上面说的两路分区（基本的快排）类似，只是现在我们需要小于 pivot、等于 pivot、大于 pivot 三个分区。</p><p>举个例子，待分割序列：<code>6 4 6 7 1 6 7 6 8 6</code>，其中<code>pivot=6</code>：</p><ul><li>未对与 key 元素相等处理的划分结果：<code>1 4 6 6 7 6 7 6 8 6</code><ul><li>下次的两个子序列为：<code>1 4 6</code> 和 <code>7 6 7 6 8 6</code></li></ul></li><li>对与 key 元素相等处理的划分结果：<code>1 4 6 6 6 6 6 7 8 7</code><ul><li>下次的两个子序列为：<code>1 4</code> 和 <code>7 8 7</code></li></ul></li></ul><p>经过对比，我们可以看出，<strong>在一次划分后，把与 key 相等的元素聚在一起，能减少迭代次数，效率会提高不少</strong>。</p><p>具体过程：</p><p>如下图，我们可以设置四个游标，左端 p、i，右端 j、q。i、j 的作用跟之前两路划分时候的左右游标相同，就是从两端向中间遍历序列，并将遍历到的元素与 pivot 比较，如果等于 pivot，则移到两端（i 对应的元素移到左端，j 对应的元素移到右端。移动的方式就是拿此元素和 a 或 d 对应的元素进行交换，所以 p 和 q 的作用就是记录等于 pivot 的元素移动过后的边界），反之，如果大于或小于 pivot，还按照之前两路划分的方式进行移动。这样一来，中间部分就和两路划分相同，两头是等于 pivot 的部分，我们只需要将这两部分移动到中间即可。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/plxupython2.webp"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">def partition(a,low,high):</span><br><span class="line">    p &#x3D; low + 1</span><br><span class="line">    i &#x3D; low + 1</span><br><span class="line">    j &#x3D; high</span><br><span class="line">    q &#x3D; high</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        while a[i] &lt;&#x3D; a[low] and i &lt; high:</span><br><span class="line">            # 与pivot相等的元素将其交换到p所在的位置</span><br><span class="line">            if a[i] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,p,i)</span><br><span class="line">                p +&#x3D; 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        while a[j] &gt;&#x3D; a[low] and j &gt; low:</span><br><span class="line">            # 与pivot相等的元素将其交换到q所在的位置</span><br><span class="line">            if a[j] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,j,q)</span><br><span class="line">                q -&#x3D; 1</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    i -&#x3D; 1</span><br><span class="line">    p -&#x3D; 1</span><br><span class="line">    while p &gt;&#x3D; low:</span><br><span class="line">        exchange(a, i, p)</span><br><span class="line">        i -&#x3D; 1</span><br><span class="line">        p -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    j +&#x3D; 1</span><br><span class="line">    q +&#x3D; 1</span><br><span class="line">    while q &lt;&#x3D; high:</span><br><span class="line">        exchange(a, q, j)</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        q +&#x3D; 1</span><br><span class="line">    </span><br><span class="line">    return i,j      </span><br></pre></td></tr></table></figure><p>下面是 sort () 函数，这里我只写了修改的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sort(a,low,high):</span><br><span class="line">    </span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    i,j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,i)</span><br><span class="line">    sort(a,j,high)      </span><br></pre></td></tr></table></figure><h2 id="整体代码实现"><a href="#整体代码实现" class="headerlink" title="整体代码实现"></a>整体代码实现</h2><p>下面是经过优化的快速排序代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">CUTOFF &#x3D; 10</span><br><span class="line"></span><br><span class="line">def exchange(a,i,j):</span><br><span class="line">    temp &#x3D; a[i]</span><br><span class="line">    a[i] &#x3D; a[j]</span><br><span class="line">    a[j] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def InsertSort(nums):</span><br><span class="line">    for i in range(len(nums)-1):</span><br><span class="line">        j &#x3D; i + 1</span><br><span class="line">        while i &gt;&#x3D; 0 and nums[i] &gt; nums[j]:</span><br><span class="line">            exchange(nums,i,j)</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            i -&#x3D; 1</span><br><span class="line"></span><br><span class="line">def partition(a,low,high):</span><br><span class="line">    p &#x3D; low + 1</span><br><span class="line">    i &#x3D; low + 1</span><br><span class="line">    j &#x3D; high</span><br><span class="line">    q &#x3D; high</span><br><span class="line">    while True:</span><br><span class="line">        # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现</span><br><span class="line">        while a[i] &lt;&#x3D; a[low] and i &lt; high:</span><br><span class="line">            # 与pivot相等的元素将其交换到p所在的位置</span><br><span class="line">            if a[i] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,p,i)</span><br><span class="line">                p +&#x3D; 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现</span><br><span class="line">        while a[j] &gt;&#x3D; a[low] and j &gt; low:</span><br><span class="line">            # 与pivot相等的元素将其交换到q所在的位置</span><br><span class="line">            if a[j] &#x3D;&#x3D; a[low]:</span><br><span class="line">                exchange(a,j,q)</span><br><span class="line">                q -&#x3D; 1</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        # 如果两个指针交叉，说明已经排序完了</span><br><span class="line">        if i &gt;&#x3D; j:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        exchange(a,i,j)</span><br><span class="line">    </span><br><span class="line">    # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    i -&#x3D; 1</span><br><span class="line">    p -&#x3D; 1</span><br><span class="line">    while p &gt;&#x3D; low:</span><br><span class="line">        exchange(a, i, p)</span><br><span class="line">        i -&#x3D; 1</span><br><span class="line">        p -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间</span><br><span class="line">    j +&#x3D; 1</span><br><span class="line">    q +&#x3D; 1</span><br><span class="line">    while q &lt;&#x3D; high:</span><br><span class="line">        exchange(a, q, j)</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        q +&#x3D; 1</span><br><span class="line">    </span><br><span class="line">    return i,j</span><br><span class="line"></span><br><span class="line">def get_median(nums,low,high):</span><br><span class="line">    # 计算数组中间的元素的下标</span><br><span class="line">    mid &#x3D; (low + high) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    # 目标: arr[mid] &lt;&#x3D; arr[high] </span><br><span class="line">    if nums[mid] &gt; nums[high]:</span><br><span class="line">        exchange(nums,mid,high)</span><br><span class="line">    # 目标: arr[low] &lt;&#x3D; arr[high]</span><br><span class="line">    if nums[low] &gt; nums[high]:</span><br><span class="line">        exchange(nums,low,high)</span><br><span class="line">    # 目标: arr[low] &gt;&#x3D; arr[mid]</span><br><span class="line">    if nums[low] &lt; nums[mid]:</span><br><span class="line">        exchange(nums,low,mid)</span><br><span class="line">    </span><br><span class="line">    # 此时，arr[mid] &lt;&#x3D; arr[low] &lt;&#x3D; arr[high]，low的位置上保存这三个位置中间的值</span><br><span class="line">    return nums[low]</span><br><span class="line"></span><br><span class="line">def sort(a,low,high):</span><br><span class="line">    if low &gt;&#x3D; high:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 当数组大小小于CUTOFF时，调用插入排序</span><br><span class="line">    if high - low &lt;&#x3D; CUTOFF - 1:</span><br><span class="line">        InsertSort(a[low:high+1])</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # 三数取中(median of three)，low的位置上保存这三个位置中间的值</span><br><span class="line">    _ &#x3D; get_median(a,low,high)</span><br><span class="line"></span><br><span class="line">    i,j &#x3D; partition(a,low,high)</span><br><span class="line">    sort(a,low,i)</span><br><span class="line">    sort(a,j,high)</span><br><span class="line"></span><br><span class="line">def QuickSort3Ways(nums):</span><br><span class="line">    low &#x3D; 0</span><br><span class="line">    high &#x3D; len(nums)-1</span><br><span class="line">    sort(nums,low,high)</span><br><span class="line">    return nums</span><br><span class="line"></span><br><span class="line">nums &#x3D; [4,5,6,1,2,3,3,3,1,2]</span><br><span class="line">print(QuickSort(nums))     </span><br></pre></td></tr></table></figure><h1 id="快速排序和归并排序对比"><a href="#快速排序和归并排序对比" class="headerlink" title="快速排序和归并排序对比"></a>快速排序和归并排序对比</h1><p>快速排序和归并排序是互补的：</p><ul><li>归并排序：<ol><li>将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；</li><li>递归调用发生在处理整个数组之前；</li><li>一个数组被等分为两半。</li></ol></li><li>快速排序：<ol><li>当两个子数组都有序时，整个数组也就自然有序了；</li><li>递归调用发生在处理整个数组之后；</li><li>切分（partition）的位置取决于数组的内容。</li></ol></li></ul><h1 id="各大排序算法测试"><a href="#各大排序算法测试" class="headerlink" title="各大排序算法测试"></a>各大排序算法测试</h1><h2 id="计时函数"><a href="#计时函数" class="headerlink" title="计时函数"></a>计时函数</h2><p>不同数据集可以用同一个计时函数，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 计时函数</span><br><span class="line">def count_time(a,sortname):</span><br><span class="line">    time_start &#x3D; time.time()</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;BubbleSort&#39;:</span><br><span class="line">        BubbleSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;SelectSort&#39;:</span><br><span class="line">        SelectSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;InsertSort&#39;:</span><br><span class="line">        InsertSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;MergeSort&#39;:</span><br><span class="line">        MergeSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;QuickSort&#39;:</span><br><span class="line">        QuickSort(a)</span><br><span class="line">    if sortname &#x3D;&#x3D; &#39;QuickSort3Ways&#39;:</span><br><span class="line">        QuickSort3Ways(a)</span><br><span class="line">    time_end &#x3D; time.time()</span><br><span class="line">    return (time_end - time_start)      </span><br></pre></td></tr></table></figure><h2 id="随机数据集"><a href="#随机数据集" class="headerlink" title="随机数据集"></a>随机数据集</h2><p>随机数据生成器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime      </span><br></pre></td></tr></table></figure><p>这里我们生成一个长度为 5000 的数组，然后重复测试 10 次，最后计算各个排序算法用时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">length &#x3D; 5000</span><br><span class="line">numberOfArrays &#x3D; 10</span><br><span class="line"></span><br><span class="line">print(&quot;BubbleSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;BubbleSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;SelectSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;SelectSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;InsertSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;InsertSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;MergeSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;MergeSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;QuickSort&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;QuickSort&#39;,length,numberOfArrays))</span><br><span class="line"></span><br><span class="line">print(&quot;QuickSort3Ways&#39;s total time:&quot;)</span><br><span class="line">print(timeRandomInput(&#39;QuickSort3Ways&#39;,length,numberOfArrays))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">30.023681640625</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.03202223777771</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">24.185371160507202</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.1900651454925537</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">0.1554875373840332</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.19011521339416504</span><br></pre></td></tr></table></figure><h2 id="降序数据集"><a href="#降序数据集" class="headerlink" title="降序数据集"></a>降序数据集</h2><p>这里我们看下这些排序算法在降序数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+       a.sort(reverse &#x3D; True)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>这里如果生成一个长度为 10000 的数组，快速排序会出现<code>RecursionError: maximum recursion depth exceeded in comparison</code>错误。这个因为 Python 中默认的最大递归深度是 989。解决方案：<strong>手动设置递归调用深度</strong>，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">+import sys</span><br><span class="line"></span><br><span class="line">+sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">        a.sort(reverse &#x3D; True)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>数组大小改变为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">45.00776267051697</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.393858909606934</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">48.275355100631714</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.18087530136108398</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">14.895536661148071</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.10853052139282227</span><br></pre></td></tr></table></figure><h2 id="升序数据集"><a href="#升序数据集" class="headerlink" title="升序数据集"></a>升序数据集</h2><p>这里我们看下这些排序算法在升序数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">            a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+       a.sort(reverse &#x3D; False)</span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>同样的，这里数组大小为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">14.935291051864624</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.371372699737549</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">0.008459329605102539</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.15901756286621094</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">16.011647939682007</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.10053849220275879</span><br></pre></td></tr></table></figure><h2 id="含有大量重复数的数组"><a href="#含有大量重复数的数组" class="headerlink" title="含有大量重复数的数组"></a>含有大量重复数的数组</h2><p>这里我们看下这些排序算法在含有大量重复数的数据集下的表现，首先改变数据生成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(1000000)</span><br><span class="line"></span><br><span class="line">def timeRandomInput(sortname,length,numberOfArrays):</span><br><span class="line">    totalTime &#x3D; 0</span><br><span class="line">    #测试数组数</span><br><span class="line">    for _ in range(numberOfArrays):</span><br><span class="line">        #数组大小</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for _ in range(length):</span><br><span class="line">-           a.append(random.randint(1, 1000000))  # 测试数据范围</span><br><span class="line">+           a.append(random.randint(999990, 1000000))  # 测试数据范围            </span><br><span class="line">        totalTime +&#x3D; count_time(a,sortname)</span><br><span class="line">    return totalTime</span><br></pre></td></tr></table></figure><p>同样的，这里数组大小为 5000，重复 10 次，下面是测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort&#39;s total time:</span><br><span class="line">28.813392877578735</span><br><span class="line">SelectSort&#39;s total time:</span><br><span class="line">11.362754821777344</span><br><span class="line">InsertSort&#39;s total time:</span><br><span class="line">22.454782247543335</span><br><span class="line">MergeSort&#39;s total time:</span><br><span class="line">0.1563563346862793</span><br><span class="line">QuickSort&#39;s total time:</span><br><span class="line">0.15424251556396484</span><br><span class="line">QuickSort3Ways&#39;s total time:</span><br><span class="line">0.08862972259521484</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center"></th><th align="center">BubbleSort</th><th>SelectSort</th><th>InsertSort</th><th>MergeSort</th><th>QuickSort</th><th>QuickSort3Ways</th></tr></thead><tbody><tr><td align="center"> 随机数据集</td><td align="center"> 30.023</td><td>11.032</td><td>24.185</td><td>0.190</td><td>0.155</td><td>0.190</td></tr><tr><td align="center"> 升序数据集</td><td align="center"> 14.935</td><td>11.371</td><td><strong>0.008</strong></td><td>0.159</td><td><strong>16.011</strong></td><td>0.100</td></tr><tr><td align="center"> 降序数据集</td><td align="center"> 45.007</td><td>11.393</td><td>48.275</td><td>0.180</td><td><strong>14.895</strong></td><td>0.108</td></tr><tr><td align="center"> 大量重复数的数据集</td><td align="center"> 28.813</td><td>11.362</td><td>22.454</td><td>0.156</td><td>0.154</td><td><strong>0.088</strong></td></tr></tbody></table>经过优化后的三路快速排序在升序、降序、包含大量重复数的情况下表现均非常优异。]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我用 Python 实现了冒泡排序、选择排序、插入排序、归并排序、快速排序。然后简单讲了讲快速排序的优化，我们可以通过&lt;strong&gt;小数组采用插入排序&lt;/strong&gt;来减少递归的开销；对于有一定顺序的数组，我采用&lt;strong&gt;三数取中&lt;/strong&gt;来提高性能；对于</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="算法" scheme="https://matthew84.cf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://matthew84.cf/tags/Python/"/>
    
    <category term="计算机基础" scheme="https://matthew84.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="算法" scheme="https://matthew84.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>风语咒</title>
    <link href="https://matthew84.cf/archives/c9490a15.html"/>
    <id>https://matthew84.cf/archives/c9490a15.html</id>
    <published>2020-10-31T04:19:28.000Z</published>
    <updated>2020-11-03T08:46:02.424Z</updated>
    
    <content type="html"><![CDATA[<div class="note red icon flat"><i class="note-icon fas fa-bullhorn"></i><p>众侠岚结阵。</p></div><iframe  id="fgyuvb" src="https://player.bilibili.com/player.html?aid=842628459&bvid=BV1554y1r7rr&cid=251155915&page=1&high_quality=1"      onload="adjustIframe(id);" height="" width="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">电影风语咒众侠岚结阵剪辑片段。</summary>
    
    
    
    <category term="娱乐" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="电影剪辑" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/%E7%94%B5%E5%BD%B1%E5%89%AA%E8%BE%91/"/>
    
    
    <category term="电影" scheme="https://matthew84.cf/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="剪辑片段" scheme="https://matthew84.cf/tags/%E5%89%AA%E8%BE%91%E7%89%87%E6%AE%B5/"/>
    
    <category term="风语咒" scheme="https://matthew84.cf/tags/%E9%A3%8E%E8%AF%AD%E5%92%92/"/>
    
  </entry>
  
  <entry>
    <title>灵魂摆渡·黄泉</title>
    <link href="https://matthew84.cf/archives/3d13b2cb.html"/>
    <id>https://matthew84.cf/archives/3d13b2cb.html</id>
    <published>2020-10-30T11:27:48.000Z</published>
    <updated>2020-10-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note orange icon flat"><i class="note-icon fas fa-bullhorn"></i><p>开篇无名入黄泉，杀死孟婆。</p></div><iframe id="lhpbldu" src="https://player.bilibili.com/player.html?aid=842612941&bvid=BV1354y1r7SC&cid=250992002&page=1&high_quality=1"     onload="adjustIframe(id);" height="" width="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">电影灵魂摆渡·黄泉剪辑片段</summary>
    
    
    
    <category term="娱乐" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="电影剪辑" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/%E7%94%B5%E5%BD%B1%E5%89%AA%E8%BE%91/"/>
    
    
    <category term="电影" scheme="https://matthew84.cf/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="剪辑片段" scheme="https://matthew84.cf/tags/%E5%89%AA%E8%BE%91%E7%89%87%E6%AE%B5/"/>
    
    <category term="灵魂摆渡·黄泉" scheme="https://matthew84.cf/tags/%E7%81%B5%E9%AD%82%E6%91%86%E6%B8%A1%C2%B7%E9%BB%84%E6%B3%89/"/>
    
  </entry>
  
  <entry>
    <title>白蛇·缘起</title>
    <link href="https://matthew84.cf/archives/4bc3d25a.html"/>
    <id>https://matthew84.cf/archives/4bc3d25a.html</id>
    <published>2020-10-30T11:24:56.000Z</published>
    <updated>2020-10-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>阿宣和小白一起去宝青坊。</p></div>   <iframe id="blue1" src="https://player.bilibili.com/player.html?aid=330138990&bvid=BV1nA411j7FR&cid=251139053&page=1&high_quality=1"       onload="adjustIframe(id);" width="" height="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="note green icon flat"><i class="note-icon fas fa-bullhorn"></i><p>阿宣第二次去宝青坊。</p></div><iframe  id="blue2" src="https://player.bilibili.com/player.html?aid=457731505&bvid=BV1j5411V7Dr&cid=251149732&page=1&high_quality=1"     onload="adjustIframe(id);" width="" height="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="note green icon flat"><i class="note-icon fas fa-bullhorn"></i><p>阿宣小白游船唱歌。</p></div><iframe  id="blue3" src="https://player.bilibili.com/player.html?aid=627743152&bvid=BV1Ut4y1e7BR&cid=251156520&page=1&high_quality=1"     onload="adjustIframe(id);" width="" height="" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">电影白蛇·缘起剪辑片段。</summary>
    
    
    
    <category term="娱乐" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="电影剪辑" scheme="https://matthew84.cf/categories/%E5%A8%B1%E4%B9%90/%E7%94%B5%E5%BD%B1%E5%89%AA%E8%BE%91/"/>
    
    
    <category term="白蛇·缘起" scheme="https://matthew84.cf/tags/%E7%99%BD%E8%9B%87%C2%B7%E7%BC%98%E8%B5%B7/"/>
    
    <category term="电影" scheme="https://matthew84.cf/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="剪辑片段" scheme="https://matthew84.cf/tags/%E5%89%AA%E8%BE%91%E7%89%87%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>阿里云九营齐开卡通图片</title>
    <link href="https://matthew84.cf/archives/23991835.html"/>
    <id>https://matthew84.cf/archives/23991835.html</id>
    <published>2020-10-30T08:39:06.000Z</published>
    <updated>2020-11-03T08:54:36.199Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning flat"><p>Hologres</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-hologres.webp"></p><div class="note warning flat"><p>Flink</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-flink.webp"></p><div class="note warning flat"><p>Dataworks</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-dataworks.webp"></p><div class="note warning flat"><p>SaaS</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-saas.webp"></p><div class="note warning flat"><p>Spark</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-spark.webp"></p><div class="note warning flat"><p>搜索与推荐</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-search.webp"></p><div class="note warning flat"><p>Elasticsearch</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-elasticsearch.webp"></p><div class="note warning flat"><p>云原生数据湖</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-uujuhu.webp"></p><div class="note warning flat"><p>PAI-DSW</p></div><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/oali-pai-dsw.webp"></p>]]></content>
    
    
    <summary type="html">阿里云9营齐开卡通图片集合</summary>
    
    
    
    <category term="阿里云" scheme="https://matthew84.cf/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="训练营" scheme="https://matthew84.cf/categories/%E9%98%BF%E9%87%8C%E4%BA%91/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="阿里云" scheme="https://matthew84.cf/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="训练营" scheme="https://matthew84.cf/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    <category term="图库" scheme="https://matthew84.cf/tags/%E5%9B%BE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--兰斯洛特</title>
    <link href="https://matthew84.cf/archives/b65d7333.html"/>
    <id>https://matthew84.cf/archives/b65d7333.html</id>
    <published>2020-10-25T13:27:38.000Z</published>
    <updated>2020-10-31T02:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="兰斯洛特"><a href="#兰斯洛特" class="headerlink" title="兰斯洛特"></a>兰斯洛特</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>第四次战争间桐家所准备的英灵，本体为湖之骑士兰斯洛特。兰斯洛特本为Saber身边第一骑士，为了Saber立下汗马功劳，Saber也非常感激和尊敬他。阿尔托莉亚和格尼薇儿结婚后，阿尔托莉亚拜托兰斯洛特做了王后的护卫。知道王实际是女性，和王后结婚只不过是政治演戏的兰斯洛特看着王后每日孤独和悲伤，最后两人不幸地陷入了爱情。阿尔托莉亚对格尼薇儿心存歉意，知道后不但不生气，反而私下非常欣慰，但是最后东窗事发，阿尔托莉亚被迫和兰斯洛特战场相见。但一直到最后阿尔托莉亚也没有丝毫责怪兰斯洛特和格尼薇儿的意思，这反而增加了两人的负罪感。这种背叛信任的人的悔恨和对自己的诅咒，以及对王不了解自己真心的怨怒，一直到死仍然盘踞在兰斯洛特心里，所以他抛下了骑士的荣誉和高贵，变身为Berserker参加圣杯战争，希望和王交战，以寻找到救赎的办法。但是在即将击败Saber的时候，因为Berserker魔力暴走，抽空了Master和自身的备用魔力而动作陷入停顿，被Saber条件反射地刺杀，死在了王的怀抱中，Saber还没来得及把自己的真心告诉他，兰斯洛特的身体就消失了……</p><h2 id="骑士は徒手にて死せず（ナイト·オブ·オーナー）"><a href="#骑士は徒手にて死せず（ナイト·オブ·オーナー）" class="headerlink" title="骑士は徒手にて死せず（ナイト·オブ·オーナー）"></a>骑士は徒手にて死せず（ナイト·オブ·オーナー）</h2><p>骑士徒手也不会死（Knight of Owner＝持有者是骑士）<br>能够赋予手中的武器作为自己宝具的属性并加以驱使。不管是什么武器、兵器，在兰斯洛特拿起的时刻就会成为相当于Ｄ级的宝具。原先的Rank在此之上的宝具就会以原本的Rank置入Lancelot的支配之下。（因为Ferotto的策略，而没带著剑进行战斗的困境时，用(这里没读到)的树枝，打倒了ferotto的小故事的具体化。）<br>即使是现代的枪械、飞机，被Berserker的魔力侵蚀后也可以变成和传说中的武器同等级的宝具。同时对于他人的武器，只要被Berserker侵蚀，也会被夺去。<br>（能力原型：在传说中，亚瑟王对于兰斯洛特和王后格尼薇儿的恋情非常愤怒，但是当时基督教规定，妻子如果对他人只是保持有柏拉图式的爱慕，丈夫无权干涉，因此亚瑟王不能公开非难兰斯洛特，于是派出12位骑士，在兰斯洛特和王后幽会的地方暗杀他。兰斯洛特当时没有携带武器，但是他仅凭一根树枝就击败了来暗杀他的骑士们，平安脱逃。在Fate/Zero中该事件的起因被描写为兰斯洛特落入了敌人的陷阱。）</p><h2 id="己が荣光の为でなく（フォー·サムワンズ·グローリー）"><a href="#己が荣光の为でなく（フォー·サムワンズ·グローリー）" class="headerlink" title="己が荣光の为でなく（フォー·サムワンズ·グローリー）"></a>己が荣光の为でなく（フォー·サムワンズ·グローリー）</h2><p>不是为了自己的荣光（For　Someone’s　Glory＝为了某人的荣耀）<br>能够隐藏自己能力值的能力。 Lancelot在多次的冒险中都藉由伪装来隐藏身分而赢得了胜利的荣耀。Berserker可以变身为其他任何可以建立功勋的骑士，但是由于狂暴化，该能力劣化成了伪装。平时笼罩Berserker的黑色烟雾，就是这一能力的劣化形态的表现之一。<br>（能力原型：兰斯洛特被称为骑士中的骑士，是所有骑士的典范，是站在骑士中最高点的人。另外曾经因为朋友和人以名誉打赌赛马，为了保全朋友的名誉，兰斯洛特化装代替朋友参加赛马并取得了冠军。）这是作为典故而具体化的能力 。</p><h2 id="无毁なる湖光（アロンダイト）"><a href="#无毁なる湖光（アロンダイト）" class="headerlink" title="无毁なる湖光（アロンダイト）"></a>无毁なる湖光（アロンダイト）</h2><p>无毁的湖光(Alondight)<br>受到湖中精灵祝福的剑，不论受到什么样的攻击，都不会有一丝一毫的损伤。原本和Excalibur是成对的圣剑，但是因为Berserker使用它杀害了同伴，所以堕落为了魔剑。<br>这是Lancelot封印其他宝具才首次解放的真正的宝具。抽出这把剑的时候，Lancelot全部的参数值提升一个Rank ，再让全部的ST判定中成功率变成两倍。因为有打倒过龙的故事，能够对持有龙属性的英灵追加伤害。（Saber有龙种因子（英格兰的赤龙））<br>（能力原型：在传说中并没有这把剑的存在。兰斯洛特从小被湖中的仙女抚养长大，所以被人们称为湖之骑士。在传说中，亚瑟王在盛怒之下决定烧死王后格尼薇儿（火之试炼），兰斯洛特为了拯救爱人的性命而袭击刑场救人。在混乱中兰斯洛特失手误杀加文爵士的两个弟弟，同为圆桌骑士的加雷思和加埃里思，直接导致了圆桌骑士的崩溃。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;兰斯洛特&quot;&gt;&lt;a href=&quot;#兰斯洛特&quot; class=&quot;headerlink&quot; title=&quot;兰斯洛特&quot;&gt;&lt;/a&gt;兰斯洛特&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Berserker</title>
    <link href="https://matthew84.cf/archives/a1ee37f8.html"/>
    <id>https://matthew84.cf/archives/a1ee37f8.html</id>
    <published>2020-10-25T12:34:33.000Z</published>
    <updated>2020-11-03T08:44:58.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="狂战士—Berserker"><a href="#狂战士—Berserker" class="headerlink" title="狂战士—Berserker"></a>狂战士—Berserker</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>依莉雅的Servant。以丧失理性为代价大大强化了能力。如果说Saber是最优秀的Servant，那他就是力量最强的Servant。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>赫拉克勒斯<br>P1：<br>希腊神话中最有名的英雄。<br>是主神宙斯与人类的女性所生，半神半人的英雄。<br>虽然赫拉克勒斯在各方面都有着优秀的能力，但是他的性格却有着很大的问题。在他小时候，曾经因为一些小事而把教竖琴的老师活活打死。后来为了稳定心性，在成年之前一直在放羊。<br>再后来，成长为一个强壮的青年的赫拉克勒斯达成了数项伟业，底比斯王将女儿梅加拉许配给他，生下了两个孩子，他也得到了王位的继承权。</p><p>P2：<br>赫拉克勒斯年轻且强壮，在人类之中已没有对手可言。又娶了王的女儿，一直到他的两个儿子出生为止，他的前途看起来都是一帆风顺。<br>可是主神宙斯之妻赫拉憎恨宙斯与人类结合而生的赫拉克勒斯，总是要让他的命途充满了苦难。</p><p>P3：<br>首先，赫拉让赫拉克勒斯发狂，将梅加拉和两个孩子杀死。<br>赫拉克勒斯内疚于自己犯下的罪，便听从神的意见，成为了一个奴隶以此赎罪，而他要效忠之人，便是那个夺走自己本应继承之王位的欧律斯透斯。<br>欧律斯透斯嫉妒强壮的英雄赫拉克勒斯，便给予他数个难题，宣布若不能完成，则他要一直当奴隶。<br>以人类之力哪怕一项都难以达成的重重难关，那便是举世有名的，赫拉克勒斯所通过的十二个道难关。</p><p>P4：<br>虽然众神说作为赫拉克勒斯所应得的惩罚，他应闯过十道难关，但其中两次欧律斯透斯不予承认，便又追加了两道难关。<br>但是即便如此赫拉克勒斯仍平安达成，不再是努力之身，而作为其伟业的证明，他得到了不死的身体。<br>赫拉克勒斯以一人之力，达成了堪与特洛伊战争和阿尔戈探险队比肩的伟业，成为了希腊最大的英雄。<br>但是，赫拉克勒斯之后的人生仍然遍染着疯狂的色彩。</p><p>P5：<br>本应不死的他并没有死于赫拉的憎恨，而是被他那位已不知是第几任的妻子亲手毒杀。<br>结果，这位能以人的身躯与太阳神势均力敌地战斗的大英雄，就这样被女神那执拗的嫉妒心一步一步地推进了死路。<br>在临终之时，赫拉克勒斯自己将他那混身是毒的身体火葬，让自己听从主神宙斯的裁判。</p><p>P6：<br>众神协议的结果是承认赫拉克勒斯的伟业，按照宙斯的意志，在他死后于奥林匹斯山的一席与众神并列接受人们的祭祀，要求赫拉与他和解，并把青春女神赫柏赐他为妻。<br>虽然在神话中赫拉克勒斯曾经数次发狂，但是本来的他是一个十八般兵器皆运用自如的卓越的战士。<br>他拥有着适合除了Caster之外的其他六个职阶的资质，所持的最强宝具，是闯过十二道难关所得的，名为“射杀百头（Nine lives）”的弓矢。</p><h2 id="十二试炼："><a href="#十二试炼：" class="headerlink" title="十二试炼："></a>十二试炼：</h2><p>(1) 扼死铜筋铁骨的涅墨亚森林的猛狮；<br>(2) 杀死勒尔涅沼泽为害人畜的九头水蛇；<br>(3) 生擒克律涅亚山里金角铜蹄的赤牡鹿（一说赫拉克勒斯不小心杀了它）；<br>(4) 活捉埃里曼托斯山密林里的大野猪；<br>(5) 引河水清扫奥革阿斯积粪如山的牛圈；<br>(6) 赶走斯廷法罗湖上的怪鸟；<br>(7) 捕捉克里特岛发疯的公牛；<br>(8) 把狄奥墨得斯的吃人的马群从色雷斯赶到迈锡尼；<br>(9) 战胜阿马宗女人的首领希波吕忒，取来她的腰带；<br>(10) 从埃里忒亚岛赶回革律翁的红牛，途中将两座峭岩立在地中海的尽头（即赫拉克勒斯石柱）；<br>(11)获取赫斯佩里得斯圣园里的金苹果（为此曾代阿忒拉斯支撑整个苍穹。路上还曾战胜该亚的儿子安泰）；<br>(12) 把冥府的三头狗刻尔柏罗斯带到人间，后又送回冥府。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>God hand<br>十二道试炼<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/berserkerbkju1.webp"><br>隐藏的能力：就算是死亡也能自动复活（Raise）。累积的复活次数为十一回。<br>也就是说，不把Berserker打倒十二次是无法消灭他的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;狂战士—Berserker&quot;&gt;&lt;a href=&quot;#狂战士—Berserker&quot; class=&quot;headerlink&quot; title=&quot;狂战士—Berserker&quot;&gt;&lt;/a&gt;狂战士—Berserker&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cla</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--真·Assassin</title>
    <link href="https://matthew84.cf/archives/de51fe18.html"/>
    <id>https://matthew84.cf/archives/de51fe18.html</id>
    <published>2020-10-25T12:34:21.000Z</published>
    <updated>2020-11-03T08:44:51.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暗杀者—Assassin"><a href="#暗杀者—Assassin" class="headerlink" title="暗杀者—Assassin"></a>暗杀者—Assassin</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>第五回圣杯战争中，与间桐脏砚订下契约的Servant。真正的身份是以「山中老人」的称号闻名，十字军东征时期伊朗一带的杀手训练者。<br>戴着白色面具披着黑色斗篷。在黑暗中出没的他，因职业缘故没有留下名字。故严格来说「暗杀者」这个阶级不属于英灵而是亡灵(英灵候补)中的群体。本身能力低下。对自己的肉体进行改造作为对抗其它Servent的手段。刚出现在现世时没有知性，吃了ランサー的心脏后立刻飞跃性地提升。以ランサー的声音说话，也有受到ランサー的人格的影响。<br>从外表看不出来内心有着厚重的忠义感。但是只要是被其认同的话，就绝对不会其背叛主人。<br>被召唤时以佐佐木小次郎的尸体为媒介，可说是代替小次郎成为第五次战争中的暗杀者（Assassin）。通体漆黑，面具下的相貌跟面具的外观其实差不多，都像是裸露的头骨一般。参加战争的原因，是希望将过去成为暗杀者时不得不抛弃的名字永远留在世上。亦即他希望人们在提及他时想到的不是「山中老人」这个称号，而是他在成为暗杀者之前所拥有的本名。<br>实力并不强，几乎每一个Servant都能胜过他，甚至身为人类的言峰绮礼也能在策略加成下打退他。平常的战术是投掷被称为「ダーク」的小刀干扰敌人（从来没有Servant被打伤，伤害效果很差），搭配黑影及宝具来取得胜利。<br>冬木市所召唤出的Assassin的名字全部都是「哈桑」。因为「哈桑」只是个代名,就等于是每次从「哈桑·萨巴赫的群体」中召唤出一个而已，共有十八位。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>哈珊·萨巴赫（Hasan-e Sabbah，？-1124）波斯人，伊斯兰教什叶派尼查尔派（Nizari）的伊斯玛仪派（Ismailite）领袖，及通称阿萨辛派（Assassin）的创始人。曾在波斯国赖伊攻读神学，约十七岁时参加伊斯玛仪派。1076年前往埃及，居留大约三年。回到伊朗后各处奔走，扩大伊斯玛仪派的影响，劝化信徒甚多。1090年率众攻打塞琉古帝国戴拉姆省阿拉穆特城（Alamut，eagle’s nest），城中守军有人归顺，里应外合，使哈珊得以夺取该城。又经过一段动乱，哈珊建成领土分散而组织严密的政权。1118年最后一次率众大规模围攻阿拉穆特，后平静地度过馀年，禁欲修行，建立严格排斥世俗享乐的统治。着有教义学论文多种，强调在信仰问题上服从绝对权威。<br>由于他要求手下的人在政治性暗杀活动中必要时应自我牺牲，并多次使用激烈的暗杀手段对付敌人，因此十字军将其教派名称「阿萨辛」（Assassin）带回西方成为「暗杀」的意思。虽然坊间常见他利用麻醉药使其训练的杀手们进入迷幻状态，再送进秘密建造的花园，使人以为自己进入天堂；之后又再次服药昏迷，重回人间，从此坚信必有天堂而在行动时奋不顾身的说法；但这类叙述的真实性十分可议，相当程度可能是深受其害的十字军以讹传讹的丑化渲染。<br>也由于其根据地阿拉穆特城位在阿尔伯兹山脉（Alborz Mountains），因此他得到了Shaykh al Jabal 即「山中王子」（Prince of the Mountain）的称号。因「Shaykh」也有「老人」的意思，因此记述十字军东征的历史学者和马可波罗称他为「山中老人」（Old Man of the Mountain）。元朝宪宗八年（1258）旭烈兀率领大军进攻报达这个回教哈里发所驻的大城（caliphate），《新元史·郭侃传》写到汉人将领郭侃「破其兵七万，屠西城，又破其东城。东城殿宇皆构以沉檀木，举火焚之，香闻百里。」元朝的西征带给伊斯玛仪派相当大的打击，政治影响力和势力自此衰微。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Zabaniya<br>妄想心音<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/realassassinbkju1.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暗杀者—Assassin&quot;&gt;&lt;a href=&quot;#暗杀者—Assassin&quot; class=&quot;headerlink&quot; title=&quot;暗杀者—Assassin&quot;&gt;&lt;/a&gt;暗杀者—Assassin&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Assassin</title>
    <link href="https://matthew84.cf/archives/e8655ce7.html"/>
    <id>https://matthew84.cf/archives/e8655ce7.html</id>
    <published>2020-10-25T12:07:00.000Z</published>
    <updated>2020-11-03T08:44:45.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暗杀者—Assassin"><a href="#暗杀者—Assassin" class="headerlink" title="暗杀者—Assassin"></a>暗杀者—Assassin</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以Assassin的职阶被召唤出来的。与セイバー初次见面时自称佐佐木小次郎。是个身分存疑的架空剑豪。<br>佐佐木小次郎其人为虚构的存在，因此以Assassin的身份被呼唤出来的这位亡灵并非传说中的那位佐佐木小次郎，而是剑技符合其传说的一位无名剑士。话说回来，他生前连名字也没有。被三枝由纪香问到名字时，曾报出津田小次郎这名字。<br>召唤者虽是Caster，但作为凭依的MASTER是柳洞寺的山门。所以推测生前是跟柳洞寺有缘的武者。也因此无法离开柳洞寺的范围，如同地缚灵一般。生前因是平民百姓无望进入仕途，其本人除了剑技也无他求。<br>Caster只给予其足够存在二十天左右的魔力。原本应该以Assassin位阶出现的真アサシン被他取代。HF路线中，间桐脏砚曾用他的身体重新召唤出真アサシン。<br>因为是Caster钻规则漏洞召唤的缘故，也非真正的英灵，故没有宝具。这是与其它英灵的不同之处。背上的物干竿长达五尺馀，物干竿被很多人认为是备前长船长光，不过也有一说是备中青江，由名为青江一门的刀匠打造。物干竿只是一般称呼而已，正式的「铭」不详。记录上长度是三尺馀，但本编中Assassin所持有的物干竿是五尺馀，是规格外的长刀，长度已经接近枪。攻击范围大，但以实战来说一般根本难以使用。除了刀法超乎常人、能使用秘剑的Assassin以外，可能没有剑士能充分发挥这长刀。<br>与大多数攻击型英灵不同，他是防御型。曾借助柳洞寺的地形，再加上キャスター的援助击退バーサーカー的进攻。本来Assassin阶级是被Berserker所克制，虽说是占了地利跟人数的便宜，但他的实力也可见一斑。<br>不会使用魔术。纯以剑技达到宝具的领域。单以剑技而论，为第五次圣杯战争中最强的英灵。以个人剑术为基础使出的「对人魔剑·燕返し」具有多重次元屈折现象（キシュア·ゼルレッチ）的效果，能够将三种剑路的剑同时具现，是一种具有第二魔法部分性质的剑术。连Saber都没办法躲过的魔剑。<br>因为不是真正的Assassin，所以没有作为Assassin最重要的「気配遮断／气息遮断」这个技能，但身为武者的修为已达到「无想の域」（明镜止水／武人之心／架势(自我暗示)）这一境界，所以能够切断自己的气息。<br>梦想是能和Saber决一胜负，这份梦想在UBW线中才得以实现，最后因为自己的剑被打歪，使燕返し出现破绽而被saber击败。喜爱大自然，喜欢观赏花鸟风月。平时一言不发，无论什麽事情都不会把喜恶说出来。爱好是独自思考。剑的修练讲究顿悟，因此在精神方面的修为也很高。</p><h2 id="原型介绍："><a href="#原型介绍：" class="headerlink" title="原型介绍："></a>原型介绍：</h2><p>佐佐木小次郎<br>日本战国后期的著名剑客，富田势源的弟子，曾与中条流的钟卷自斋学习武术。为了修炼武艺而游历各国，并独自创立了自己的流派。相传他相貌英俊，擅长使用三尺的长刀，由于剑身相当长，攻击范围大，据称连天上的飞燕皆飞不出其长剑范围，被一切为二的绝招 故名“燕返”，与被后世尊为“剑圣”的宫本武藏于小仓岛（今严流岛）对决，战败被杀。其实小次郎的剑技未必输于武藏，但武藏除了是一名剑客外，也是名优秀的兵法家。相传两者相约在小仓岛决战，武藏故意迟到，令小次郎心烦意乱。决战中，武藏手持比对方更长的兵刃，更背对夕阳，利用落日余晖迷住佐佐木的视线，击杀小次郎，再由沙滩不留足迹地脱离现场。两强相争，斗智斗力，小次郎力则有之，智有不逮，可惜“燕返”也随之失传。<br>与出身于并不富裕的家庭的武藏相比，小次郎则是在拥护和赞扬的光环的环绕中成长起来的。但是，跟那些平庸的纨绔子弟不同，小次郎绝对是一个剑术奇材。虽然曾经跟随钟卷自斋学习过富田流的小太刀技法，但小次郎自己所创立的严流，使用的却是比小太刀长得多的太刀。小次郎的爱刀”长光”便是长达三尺二寸的长刀，而小次郎的绝技”燕返”，更是能够将长刀之利发挥到淋漓尽致的招式。可是，即使是这样的小次郎，却连”燕返”都没有使出就败在了宫本武藏的剑下。跟武藏决斗时的小次郎，无法发挥自己刀长的优势，因为武藏在决斗之前，特意制作了一把木刀，刀的长度是四尺二寸，比小次郎的”长光”长了整整一尺。<br>因为小次郎在决斗之前并未将绝技”燕返”传给弟子，这一招便从此失传。或许从《侍魂》里右京的必杀技之一”秘剑·燕返”中，可以领略到一点小次郎”燕返”的风采（不知道是否真的能划出一只火鸟来……）。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>信息不详<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/assassinbkju1.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暗杀者—Assassin&quot;&gt;&lt;a href=&quot;#暗杀者—Assassin&quot; class=&quot;headerlink&quot; title=&quot;暗杀者—Assassin&quot;&gt;&lt;/a&gt;暗杀者—Assassin&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Caster</title>
    <link href="https://matthew84.cf/archives/716c0d5d.html"/>
    <id>https://matthew84.cf/archives/716c0d5d.html</id>
    <published>2020-10-25T12:06:43.000Z</published>
    <updated>2020-11-03T08:44:37.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="魔术师—Rider"><a href="#魔术师—Rider" class="headerlink" title="魔术师—Rider"></a>魔术师—Rider</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以魔术为长，发挥出接近魔法等级的魔术，在这个以魔术师与使魔一组的圣杯战争中算是很不寻常的职种，而她也利用这种职种的设定的漏洞自己召唤出自己的使魔 Assassin。<br>Caster的真正身份，即古希腊科尔喀斯国的国王埃厄忒斯之女美狄亚（Medea）。在希腊神话中被视同为魔女的不幸女王，因自己的真爱背叛了自己造成她阴险的性格，但其本性依然是为了爱可以奉献一切的。 </p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>美狄亚<br>P1：<br>希腊神话中，被人当作魔女的代名词来对待的不幸的公主。<br>阿尔戈探险队里有名的英雄伊阿宋，在与夺去他父亲国家的珀利阿斯王的谈话之后，双方约定，若伊阿宋能赶赴极东之国科耳喀斯去将金羊毛带回，珀利阿斯便将国家奉还。<br>拥有金羊之皮的人，是科耳喀斯的公主美狄亚。她身为擅长魔道的科耳喀斯王埃厄忒斯之女，虽然学习了魔术，但其性格却还远不至于被称为魔女。</p><p>P2：<br>她的命运从英雄伊阿宋出现在她面前之时就被搅乱了。<br>支持伊阿宋的女神阿芙罗狄蒂见科耳喀斯王很难被说服，便控制了美狄亚的心，让她变成了一个为了伊阿宋不顾一切的少女。<br>最后，美狄亚就为了这个从来没见过面的、叫伊阿宋的外国男人，背叛了父王和自己的国家。<br>美狄亚使她父亲的魔术无效化，又让魔术做成的吐火之公牛无力化，使得伊阿宋得到了金羊毛皮。</p><p>P3：<br>科耳喀斯王自然非常生气，为了不让伊阿宋逃出科耳喀斯，他亲自上阵去追捕他。<br>为了让伊阿宋逃离其追捕，女神再次利用了美狄亚。<br>美狄亚乘上了那连名字都不知的爱人所驾驶的阿尔戈之船，在追来的父王面前将自己的弟弟亚比西托士分尸。<br>她的父亲叹息着，将被分尸的儿子的肉块收集起来。<br>趁这个机会阿尔戈之船逃离了追捕，伊阿宋平安地回到了伊奥尔科斯。</p><p>P4：<br>回到故乡的伊阿宋依约向父亲的仇人珀利阿斯王讨取国家，但是珀利阿斯王却不甘心就此罢休，他欲将伊阿宋置于死地。<br>伊阿宋凭借美狄亚的魔术三次自绝境脱险，美狄亚为了伊阿宋想了一个计策。<br>她请珀利阿斯王来做客，然后在他面前将一个仆人杀死。然后美狄亚用她的魔术使其复活。<br>然后美狄亚说她也可以在珀利阿斯王的身上施展这个可使人不死的魔术。</p><p>P5：<br>他自然喜出望外，便请美狄亚在他身上施术。自然，他之后就被分尸丢到了海里。<br>伊阿宋就这样成为了王，但阿尔戈之船上的伙伴们已经无法认可伊阿宋的行为，更无法容忍美狄亚的存在。<br>为了男人背叛了国家，将帮助自己的弟弟分尸，这次又欺骗了王夺取了宝座。<br>美狄亚被贬为魔女，与伊阿宋一起被驱出了国家。</p><p>P6：<br>伊阿宋与美狄亚之后到达了柯林斯，柯林斯王欢迎了他们。<br>在这个地方，美狄亚终于有了安宁的日子。<br>被人从大地彼方的国家带走，又被人当成魔女所惧怕，好不容易等来了那平和的日子，却也没能持续多久。<br>欣赏伊阿宋的柯林斯王想让女儿嫁给伊阿宋为妻，而伊阿宋也选择了王那年轻的女儿，而将美狄亚放逐。</p><p>P7：<br>而之后她所做出的行为，绝对符合她魔女之名。<br>美狄亚突然在伊阿宋的结婚典礼上现身，使用她的魔术，从柯林斯王和她的女儿开始，将参加婚礼的人逐个烧死，最后她只留下伊阿宋的一条命，便离开了王城。<br>离开柯林斯的美狄亚，其之后的去向已不得而知。<br>也有人说，人生只剩背叛与被人背叛的公主，成为了真正的魔女，一直在希腊的大地上彷徨。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Rule breaker<br>可破万法之符<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/casterbkju1.webp"><br>可破除所有魔术效果的短刀。<br>可以将被魔力强化的物体、以契约连起的关系以及用魔力制造的生命回复到“施术之前”的状态，是终极的对魔术宝具。<br>此魔术武器是背叛之魔女神性的具现化。<br>就如外表所见，攻击力极其微弱，杀伤力连小刀都不如。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;魔术师—Rider&quot;&gt;&lt;a href=&quot;#魔术师—Rider&quot; class=&quot;headerlink&quot; title=&quot;魔术师—Rider&quot;&gt;&lt;/a&gt;魔术师—Rider&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Rider</title>
    <link href="https://matthew84.cf/archives/66b3dcb.html"/>
    <id>https://matthew84.cf/archives/66b3dcb.html</id>
    <published>2020-10-25T12:06:27.000Z</published>
    <updated>2020-11-03T08:44:30.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="骑兵—Rider"><a href="#骑兵—Rider" class="headerlink" title="骑兵—Rider"></a>骑兵—Rider</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>骑兵的英灵。追求高机动性，持有强力的宝具的Servant。保有技能、宝具数量在Servant之中数一数二。<br>Master为间桐慎二和间桐樱。真名为有著「支配之女」之名的高尔根三姐妹的末女，希腊神话中的女怪梅杜莎(Medusa)。与其说是英灵倒不如说是神灵，持有多种多样的能力，曾有过被称为女神的时期，可惜因为负面的想念被当作牺牲品沦为女怪。因为Servant被召唤出来时是处於生前的全盛时期所以Rider还没变成女怪。<br>将她召唤出的Master是间桐樱，但因使用「伪臣之书」转移控制权的关系，而暂时听从慎二之命令。在Fate路线中只是作为让セイバー试剑的敌人甲出来被宰掉，UBW路线中则是被莫名其妙的被葛木宗一郎奇袭而退场，但是在HF路线中有著剧情上的出色表现。HF路线後ライダー消失了，却出现了一名叫间桐丽多的女性出现。<br>骑乘是Rider位阶的专长，也只有这个位阶能骑乘传说中的圣兽。最强的攻击为骑著天马，使用宝具骑英の手纲，冲撞敌人。行动敏捷，能灵活的在大楼间跳跃移动。在战斗时还能以石化魔眼和所持有的锁钉「无铭·短剑」作为武器。<br>战斗时的个性被形容是「散发著血的味道」。在三大路线中都做过使用他者封印．鲜血神殿把整个学校包围，准备吸光所有人的灵魂化为魔力的举动。有著可怕的杀戮者性格，不过事实上她最重视的是保护樱。而之所以会变成这种性格，似乎跟过去的经验有关。<br>十分在乎间桐樱，远超过普通Servant对Master的关心程度，为了樱几乎什么都会做，绝大部分为个人感情因素，不管用什么方法以保护Master樱为最优先考虑。判断出敌我之後决不容情，其速度相当惊人。本人并没有什么特别的兴趣而是像机械一样把工作完成到底。天敌为セイバー、葛木宗一郎、アサシン。<br>HF路线之後，作为樱的Servant留下来一起生活。樱的魔力已经足够供给了，但还是秘密地用自己封印．暗黑神殿吸血、吸精。吸血来自女性，吸精则是利用淫梦从男性处吸取。是否有吸血冲动不明。美缀绫子就曾被她吸过血。HF路线里曾对卫宫士郎使用淫梦。她并非死徒而是吸血种，对她来说补充魔力最有效也是最甜美的方法就是吸血。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>美杜莎<br>P1：<br>希腊神话中出现的，可以将她看到的人石化的半人半神之女怪。<br>在很多故事中她都被描写为蛇之化身的魔物。被英雄珀尔修斯所打倒。是一个被负面感情所造就的反英雄。<br>戈尔贡三姐妹——斯忒诺（Sthenno，力量）、尤琉蕾（Euryale，飞翔）、美杜莎（Medusa，支配）——中最小的三妹，与两位姐姐不同，她并非不死之身。居住于黄金苹果岛附近的“无形之岛”。</p><p>P2：<br>本来她们是美丽的女性，但是由于她们为海神波赛东所钟爱，因此受到海神之妻的诋毁，而嫉妒她们那美丽秀发的战争女神雅典娜让她们堕落为了魔物。<br>在变为魔物之后，她们一直居住在不见光的神殿，从来没有胡乱攻击别人。<br>美杜莎成为了众神那无道理可言之行为的牺牲者。最后的命运是因为众神的一时兴起而被人砍下了头颅。</p><p>P3：<br>从美杜莎被斩下首级之后所流出的血中，诞生了纯白的天马珀伽索斯。它可以说是海神波赛东的儿子。<br>从种类来分的话，与其说她是英灵，不如说是神灵更合适。其多种多样的能力是还身为女神之时所残留下来的。</p><h2 id="神话出处"><a href="#神话出处" class="headerlink" title="神话出处"></a>神话出处</h2><p>梅杜莎（Medusa），希腊神话中的女性怪物，以能将注视到的人化为石头的能力闻名。「高尔根」（Gorgans）三姊妹中最小的妹妹。梅杜莎、Stheno、和Euryale头发为蛇，具有利齿、面貌丑陋，有巨大翅膀。高尔根和格赖埃三姊妹（Graiae）是Phorcys和Ceto（两者皆为Pontus与盖亚（Gaia）的子女；Phorcys是最初的海神，他的配偶Ceto则是代表海洋危险面的海怪）的女儿。在某些版本的神话记述中，梅杜莎的两位姊姊是为了保护她，才将自己变成怪物（梅杜莎是三姊妹中唯一不具不死之身者）。<br>在最广为人知的神话版本中，梅杜莎原本是一位美丽的女子；海洋之神波赛顿（Poseidon）在雅典娜（Athena）的神殿里强暴了她。波赛顿和雅典娜曾竞争雅典守护者的地位，而波赛顿败给了雅典娜。<br>当雅典娜得知这件亵渎神殿的事情後，她将梅杜莎的容貌变得如同其姊一般做为惩罚。梅杜莎的头发变成毒蛇，而她的目光会将活物化为石像，她之後被放逐到极北之地以外。<br>由於波赛顿让梅杜莎怀孕，因此当希腊神话中的英雄，宙斯和达娜厄（Danae）之子珀修斯（Perseus）强迫老年化身格赖埃姊妹（Graiae）告诉他高尔根的所在，并利用雅典娜和赫密斯送他的镰刀和磨亮的盾牌砍下梅杜莎的头後，从颈子涌出的血中诞生了其子嗣：天马Pegasus和巨人Chrysaor。珀修斯回程时经过衣索比亚，正好遇到公主安卓美妲（Andromeda）将被献祭给海怪；他以梅杜莎的头将海怪石化救了她。珀修斯最後将梅杜莎的头献给雅典娜，雅典娜将其镶在神盾Aegis上。<br>在另一个版本的传说中，身为凡人的梅杜莎宣称她的美貌胜过阿芙洛蒂忒（Aphrodite），爱与美的女神。这使阿芙洛蒂忒把她和她的两位姊姊变成高尔根。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Breaker·Gorgon<br>自我封印·暗黑神殿<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/riderbkju1.webp"><br>Bellerophon<br>骑英之缰绳<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/riderbkju2.webp"><br>Blood Fort·Andromeda<br>他者封印·鲜血神殿<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/riderbkju3.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;骑兵—Rider&quot;&gt;&lt;a href=&quot;#骑兵—Rider&quot; class=&quot;headerlink&quot; title=&quot;骑兵—Rider&quot;&gt;&lt;/a&gt;骑兵—Rider&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--金Archer</title>
    <link href="https://matthew84.cf/archives/980fa868.html"/>
    <id>https://matthew84.cf/archives/980fa868.html</id>
    <published>2020-10-25T12:06:13.000Z</published>
    <updated>2020-11-03T08:44:22.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="金Archer"><a href="#金Archer" class="headerlink" title="金Archer"></a>金Archer</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>弓兵的英灵。和Saber一样同时参加过第四、第五次圣杯战争。第四次时的Master是远坂时臣。第五次时则是言峰绮礼。真名吉尔伽美什（又译作吉尔伽美修、基尔加梅修等）人类历史上最古老的英雄王、三分之二神、三分之一人。<br>因为承受了被Saber破坏的圣杯中流出的アンリ·マユ「人世间所有的恶（この世全ての恶）」，而得到肉身。魔力的维持来源是言峰从没在大火中死去的人们身上榨取的生命力。<br>第四次圣杯战争时，向Saber求婚被拒。他相信自己依然拥有世上的一切，所以不会理会别人的感受，非常横暴。爱称呼别人为「杂种」，普通人多说几句就会被他杀死。杀人的理由是让他们从痛苦的生活中解脱出来。虽然他的行为似乎是恶人，但实际上他从某些角度看着也有着特殊的个人美学:即英雄类型。曾说过「不自高自大做什麽王」。算是前所未闻的英雄类型。喜欢权力，讨厌蛇。<br>其人虽然讨厌Servent的身份，但原本英灵就不是这个男人的对手。对方Servent越是有名，其传说流传越广就对他越有利的「英灵杀手」。虽然对魔力不强，但凭藉着众多武装让大部分的魔术无效。<br>持有黄金律。一生不为贫穷所困过着大富豪的生活。能自由转移所有物的所有权。因为是王所以喜欢开宴会，目的是欣赏为了追求快乐而集合起来的人们的丑态，参加者们越High越堕落之后松弛下来的笑容对他来说是种享受。<br>基尔加梅什毫无疑问其实力是Fate系列中最强的英灵，光是王的财宝就几乎无人可敌，其中的天之锁更是拥有「具神性英灵绝对必杀」的优势，而单凭宝具最重要的威力还有乖离剑·エア这把对界宝具的存在。虽然实力上无敌但因为个性的缘故加上运气不好而经常在关键时落败。几乎每条路线都有天敌出来挡路，第四次圣杯战争有バーサーカー(第四次圣杯战争)。Fate线有セイバー的乖离剑克星遥远的理想乡存在，UBW线则是卫宫士郎的王的财宝克星无限之剑制阻挡，HF线则是遇到「对英灵无敌」的黑影攻击。可以说是实力最强但运气最差的英灵。<br>另外，在《Fate/hollow ataraxia》中因为感到「现在的情况根本是闹剧」后就服下返老药而变成了可爱的闪亮少年。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>吉尔伽美什<br>古代美索布达米亚之王，号称人类最古老的英雄王，肉体与灵魂有三分之二为神，三分之一为人。据说生前收集了世上所有的财宝，死后流散到世界各地，名称以及由来也因其它的传说之故升格为宝具。因此持有所有宝具的原型。由于好友恩奇杜（Enkidu）死去的影响，受到打击而周游列国，探求不老不死。不过，好不容易得到的不老不死药却被蛇吞下。</p><h2 id="神话出处"><a href="#神话出处" class="headerlink" title="神话出处"></a>神话出处</h2><p>故事及记载见于《基尔加梅修史诗》（Epic of Gilgamesh），为古代阿卡德语重要文学作品。在古尼尼微城内亚述国王亚述巴尼帕的图书馆中所发现的12块残缺泥版，是现存最完整的文本；在美索不达米亚和安纳托利亚所发现的其他残片足资补充。<br>尼尼微本的《基尔加梅修史诗》开端是序曲，称基尔加梅修三分之二为神，三分之一为人，受太阳神沙玛什守护，精于土木，勇于征战，为乌鲁克国王，海中陆上万物无不知晓。安奴神见基尔加梅修虐待臣民，遂以黏土创造野人恩奇杜以挫其势。恩奇杜一开始与兽同居，不久学会城市生活，前往乌鲁克，基尔加梅修在该地等候他。第二块泥版叙述两人较量，基尔加梅修在摔跤比赛中胜过恩奇杜，两人成为莫逆之交。<br>第三至第五块泥版叙述两人前去挑战奉神灵之命护卫远方雪松林的巨人胡瓦瓦，连根拔起一棵棵雪松；胡瓦瓦认输后，他们斩下他的头。第六块泥版叙述基尔加梅修返回乌鲁克后，爱情女神伊什塔（Ishtar）向他求爱。基尔加梅修知道她的激情会杀死她的爱人，遂加以拒绝。女神气愤不已，劝说最高的天神阿奴（Anu）降七年乾旱到地上，并差遣神牛去杀害基尔加梅修。基尔加梅修得恩奇杜之助将神牛杀死，并将其心脏献给沙玛什。<br>在第七块泥版的记述中，恩奇杜自述在梦中得安奴、埃阿、沙玛什诸神指示要为神牛抵命，之后因病而亡。基尔加梅修痛哭并厚葬挚友之事见于第八块泥版。第九、十块泥版记述基尔加梅修冒险出走寻访经历巴比伦洪水而健在的乌特那庇什廷，请教如何避免一死。第十一块泥版载基尔加梅修遵照乌特那庇什廷的指示找到可让人不老不死的植物却被蛇所夺。第十二块泥版是尾声，叙述伊什塔赠与基尔加梅修的「普库」和「米库」（可能是鼓和鼓搥）之失踪。史诗结尾叙述恩奇杜亡魂重返人间（或解释作基尔加梅修至地府寻找好友）。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Gate·of·Babylon<br>王之宝藏<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/gold-archerbkju1.webp"><br>连通黄金之都的钥匙之剑。<br>将空间连通，可以自由地取出宝物库中的道具。<br>可以说是使用者的财宝越多，就越是强力的宝具。<br>Enuma elish<br>天地乖离す开辟の星（乖离剑·エア（Ea））<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/gold-archerbkju2.webp"><br>传说中用来开天辟地创造美索布达米亚的对界宝具。威力强大，具有胜过Saber所持约束的胜利之剑的破坏力,号称“切开世界”之剑。另一特点是擅长透视物体的卫宫士郎也无法看穿其构造。这把剑本来没有名字，エア这名字是基尔加梅什自己取的。<br>还有一样传闻中的宝具「完全简朴的考验（忧郁工人）（全く简素な试练ブルワーカー）」。锻炼身体用，本来不是剑士的他剑术也因此高强。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;金Archer&quot;&gt;&lt;a href=&quot;#金Archer&quot; class=&quot;headerlink&quot; title=&quot;金Archer&quot;&gt;&lt;/a&gt;金Archer&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Archer</title>
    <link href="https://matthew84.cf/archives/71560399.html"/>
    <id>https://matthew84.cf/archives/71560399.html</id>
    <published>2020-10-25T12:05:50.000Z</published>
    <updated>2020-11-03T08:44:16.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弓之骑士—Archer"><a href="#弓之骑士—Archer" class="headerlink" title="弓之骑士—Archer"></a>弓之骑士—Archer</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>五次圣杯战争时由远坂凛召唤出的Servant，做为英灵的基本能力和魔力都比其他英灵低，主要靠从手中出现的众多宝具和自身的技能来弥补差距。因为阶级是弓箭手，弓术擅长是绝对的，却又精于近身格斗战及武器战，亦擅长对魔术战和家务。<br>真正身份为英灵Emiya，是未来的卫宫士郎死后化身的英灵。脸变咖啡色是由于经常使用固有结界反冲的缘故，身上的项链是证明身分的最有力证据。彻底的现实主义者，但性格倒不至于让人完全讨厌。喜欢悄悄地做事却谎称什麽都没做，经常以挖苦的方式给予别人劝告。在被凛召唤后，谎称记忆丧失（半真半假），UBW篇时，在记忆恢复后决定杀死现代的自己；HF篇则将自己的左手臂给了否定原先理想的士郎，以挽救他的生命。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>卫宫<br>奇迹的交换条件，即卫宫士郎的英雄化。<br>可以不受修正地使用固有结界，将大量的武器具现化的锻铁之英灵。<br>未来的士郎维持自己小时候的信念，为了救助世间一切现有的生命，拼命终结了战争。不过，应该成为救世主的他，被世人冠上战争主谋的罪名，在绞刑台上处决。<br>虽然相信死后成为英灵能够拯救更多人；但现实中为了救多数人，却不得不杀害少数人的这种行为，实际上早已违背了他「救助一切生命」的初衷。发觉使自己陷入困境的是那不成熟的正义理想后，士郎迁怒于过去的自己。<br>即使过去和未来的两人处于同一世界，也是不同的存在。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>他的能力大都是成为英灵前锻炼得来，而非出于天生的才能。并没有特定的宝具，取而代之的是他做为魔术师所拥有的固有结界能力「无限の剑制/Unlimited Blade Works」。该能力能够在结界空间内无限量地具现出他心中幻想的宝具或武器，不过由于会被世界修正，故持续的时间很短。<br>另外他的投影魔术也不是一般的投影，而是从固有结界中直接把宝具拉出的非正规投影。克服了正规投影只有真品完成度四成的铁则，这样近似魔法的投影，所消耗的魔力也不多。能有这种特殊魔术，要归功士郎的属性是”剑”才能做到。<br>而另一个是被称为「坏れた幻想（崩坏的幻想）/Broken Fantasy」的绝技，把投影出的宝具用弓射出，再将其中蕴含的魔力与信仰引爆，可以造成强大的攻击效果。据アーチャー所言，其破坏威力能秒杀普通英灵。<br>Archer虽没有特定宝具，但最常投影的宝具是干将、莫邪。而在防御上有所保障，所以特别锻炼过ロ─·アイアス(炽天覆う七つの円环)。<br>在腰间的红色外套是圣骸布，以圣人的裹尸布制成，是具有一流守护效果的概念武装。其他技能包含他生前就擅长的强化、投影、构造解析、入门魔术中的魔力感知和魔术抵抗（对魔力）。<br>干将、莫邪<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/archer-bkju1.webp"><br>干将、莫邪（解放状态）<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/archer-bkju2.webp"><br>崩坏的幻想之弓<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/archer-bkju3.webp"></p><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>archer对战saber，咏唱无限剑制。</p></div><iframe id="archer" src="https://player.youku.com/embed/XNDkzMjk1ODMzNg=="         onload="adjustIframe(id);" height="" width="" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;弓之骑士—Archer&quot;&gt;&lt;a href=&quot;#弓之骑士—Archer&quot; class=&quot;headerlink&quot; title=&quot;弓之骑士—Archer&quot;&gt;&lt;/a&gt;弓之骑士—Archer&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;head</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Lancer</title>
    <link href="https://matthew84.cf/archives/14b7ca29.html"/>
    <id>https://matthew84.cf/archives/14b7ca29.html</id>
    <published>2020-10-25T12:04:08.000Z</published>
    <updated>2020-11-03T08:43:52.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枪之骑士—Lancer"><a href="#枪之骑士—Lancer" class="headerlink" title="枪之骑士—Lancer"></a>枪之骑士—Lancer</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>是个性格非常豪放磊落的汉子。对他来说成为Servant最重要的事情不是得到圣杯，而是痛快地战斗。虽然很粗暴而且不会对敌人手下留情，却也非常忠实于自己的信念。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>库·丘林<br>Cuchulainn，库丘林，也译作库夫林，是远古时爱尔兰的英雄。他父亲是太阳神Lugh，母亲是人类，所以是半人半神的存在。通过“影之国”女王的考验，并从女王那里得到了武器“Gae bolg”，传说他单手拿枪战斗终身。这是一把带有诅咒的魔枪，不仅让自己的儿子和好友被此枪刺死，就连Cuchulainn本人也死在这把枪下。据说爱尔兰现在还有他的坟墓，但也有人说其实是座空坟，他们认为Cuchulainn还活在大海远处的青春之岛，因为在凯尔特万圣节这天，Cuchulainn会重返此地，在墓地周围走动。凯尔特万圣节是在十月末举行的召唤死者的节日，相信英雄们在这一天也会从青春之岛返回这里。<br>爱尔兰的大英雄。凯尔特神话中半人半神的英雄，光之神鲁格与阿尔斯特王康纳之妹黛毕特拉公主，小时候他的名字叫瑟坦塔，在他小时候就有人预言说“这个孩子生来就是要当英雄之人”。<br>活跃在公元1世纪左右Conor MacNessa王统治下的爱尔兰部族国家Alster。原名瑟坦特(SATANTA)，他7岁的时候误杀了一个叫古兰的富商所养的看门犬。因此他向古兰发誓：“这只狗的孩子就由我来养育，我一定将它培养成同样强的看门犬。在那之前，就让我来保护您。”，并立誓一生不吃狗肉。而此后，瑟坦塔就因空手搏杀有名的古兰之猛犬所展现出的力量，以及那能体会失去了爱犬只剩小狗的主人的心情所展现出的胸襟而为人所称道，因此得名“库·丘林”。<br>健壮地长大成人的库·丘林，为了与一位女性结婚，答应了要他前往被称为[影之国]的魔境这个条件，库·丘林跨越了重重难关，到达了影之国。那个国家的主人——魔女斯卡哈很欣赏他，让他留下来锻炼修行，学到了精湛的武艺、兵法。之后库·丘林得到了成为他的象征的那把魔枪——Gáe·Bolg。然后他离开了影之国。<br>成年后组建了著名的[赤枝骑士团]，活跃在前线保卫自己的祖国。他在战场上所向披靡，只要开始战斗，头发会变得火红，眼光慑人，令敌人望而生畏。凯尔特的战士有着发誓服从被称为“誓约（Cash）”的各种各样戒条的习俗，违背誓约之人将受到诅咒。库·丘林交换的誓约中比较有名的，是在与其宿敌——美伊芙女王之间所约定的“一天只接受一个战士的挑战”的战斗中，与老朋友费格斯之间交换的“一胜一败”之誓约。但他所交换的这些誓约，却正是日后使他丧命的主因。在与敌国的交战中，为了守护国力弱于他国的阿尔斯特，库·丘林不顾自己的生命接受了很多的誓约，其代价是让敌国也背负上不利的誓约。<br>然而跟他在战场上的风光相比，他的一生非常不幸，在不知情的情况下，为了履行职责杀死了自己的唯一的儿子。在与康诺特的女王美伊芙的丈夫之间的斗牛比赛的胜利时，想要得到栖息于阿尔斯特的黄金之牛的女王，毫不讲理地使用了很多卑鄙手段，由此暴发了两个阵营之间的战争。库·丘林在七年里一直支持着居于劣势的阿尔斯特军，对抗自康诺特发动进攻的三国联合军，终于将他们打退。在那时，库·丘林抓住了战争的元凶美伊芙，但是他坚持“不能杀女人”而将她释放，阿尔斯特和康诺特之间终于迎来了和平。<br>但是女王美伊芙视他的释放为最大的侮辱，以个人的力量向库·丘林发起了报复行动。而她诸多策略所造成的结果，便是让库·丘林打破了自己背负的其中一个誓约，失去了所有的力量，侧腹部中了一枪。高傲的库·丘林不愿就那么倒在地上死去，就把自己绑在了柱子上。在临终之时，他看到有只水獭贪婪地吮吸自己渗进河流的血液，然后他便一边高声地嘲笑它，一边屹立而亡。绑住Chulainn死去的石柱现在成为北爱尔兰一块有争议之石，因为新教徒跟天主教徒都宣称自己是Chulainn的后裔，是石柱的继承者。<br>豪爽的库·丘林受到掌管死与破坏的女神摩根的佑护。但是，她的方法却并不普通。一开始，库·丘林居然拒绝了女神的佑护。摩根觉得自己受到了侮辱，就变化为各种各样的动物想要杀了库·丘林。但是库·丘林不只是每次都将她打败，还反过来为受了伤的摩根疗伤。摩根叹服于他高尚的人格，便决定在他看不到的地方默默地支持他。她为了不侮辱库·丘林的荣耀，在他陷入绝地之时没有伸出援手，只是注视着他以一个英雄应有的方式而死去。<br>顺便介绍一下他父亲：Lugh(Rugh)<br>中译名鲁格，凯尔特神话的光明之神，手持魔枪布琉纳克，拥有出众的战斗技能。虽然是受人景仰的光之神，他的祖父却是无恶不作，率领弗莫尔军团蹂躏爱尔兰的邪眼魔王——巴罗尔，他和巴罗尔的女儿加芙迪尼亚生下了凯尔特神话最大的英雄库夫林。并在达南神族与弗莫尔军团的决战中射穿了巴罗尔的魔眼消灭了他。继先代神王战死以后成为达南神族新王。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Gáe Bolg<br>穿刺之死棘枪<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/lancer-bkju1.webp"><br>一击便必定将对手的心脏贯穿的诅咒之枪。魔枪Gáe Bolg的必杀一刺。<br>事实上，这是一种因果的逆转，在得到枪命中对手的心脏这一结果之后，才导出枪向对手放出这一原因。<br>既然在枪被放出之前枪就已经命中了心脏，那么在结果已经造成之后使用什么、防御和回避都是不可能的。<br>要回避Gáe Bolg并不需要AGI（敏捷）比较高，而是在Gáe Bolg发动前扭转命运的能力——也就是LCK（幸运）的高低比较重要。<br>是一个发动宝具的必要魔力量较少，而且可以一击毙敌的高效率宝具。<br>Gáe Bolg<br>突穿之死翔枪<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/lancer-bkju2.webp"><br>将Gáe Bolg的诅咒最大限度地解放，以浑身的力量投掷的特殊使用宝具。<br>因为Gáe Bolg本来就是投枪，这样的使用法才是正确的。<br>与死棘枪不同，比起对心脏的命中力，它更重视的是破坏力，一投便可以将一个部队炸飞。就如同爆裂弹一般。<br>其伤害力、形状都与凯尔特的光之神鲁格持有的“轰击五星”（Brionac）相近，“无论躲避多少次也能刺穿对手”这种能力可与北欧的主神奥丁的“大神宣言”（Gungnir）相提并论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;枪之骑士—Lancer&quot;&gt;&lt;a href=&quot;#枪之骑士—Lancer&quot; class=&quot;headerlink&quot; title=&quot;枪之骑士—Lancer&quot;&gt;&lt;/a&gt;枪之骑士—Lancer&lt;/h1&gt;&lt;h2 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;he</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Stay Night--Saber</title>
    <link href="https://matthew84.cf/archives/d2e2a457.html"/>
    <id>https://matthew84.cf/archives/d2e2a457.html</id>
    <published>2020-10-24T13:52:24.000Z</published>
    <updated>2020-11-03T08:42:46.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑之骑士—Saber"><a href="#剑之骑士—Saber" class="headerlink" title="剑之骑士—Saber"></a>剑之骑士—Saber</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>亚瑟王称为保护不列颠的赤龙，持有龙之血统的人本身就带有龙的魔力。不必拥有魔术回路，只要顺着血液循环一呼一吸之间就会产生魔力,跟魔术师是不同级数的“魔术炉心”。Saber之所以强并不在于她的剑技而是因其庞大的魔力之故。跟Berserker战斗之时魔力量有1000左右，那场战斗消耗了两百左右的魔力。<br>宝具是风王结界跟Excalibur。剑鞘登场时已失。以风封印剑，经由压缩的风改变光的折射率，看上去像是透明一般，风被解开后可以自由操纵。<br>铠甲以Saber的魔力编成，可以实现瞬间着脱，通常穿着私服以节约魔力。比起铠甲的修复治愈肉体花费的魔力更多。<br>魔力的回复量一天为8，维持肉体必须量为6，因此以每天增加2来计算。不过对手是Servent的话战斗一次就要消耗数十到数百不等.魔力量可达到数千。<br>有对飞行道具的耐性，通过风声跟自己的直感来读出轨道。<br>作为王将私人事情排在后面不作为优先考虑。去掉这层外皮之后是与其年纪相仿的女子。因拔出选定王者之剑身体的成长停止了，肉体的年龄比士郎小一岁左右。<br>食欲旺盛，生前似乎无福享受好吃的食物，以补充魔力为名执着于进食，没有讨厌的食物，除了章鱼。不过话说回来，在成为Servent之前身体的成长已经停止了，就算吃得再多也不会胖，不吃也不会瘦…<br>以前曾跟小狮子生活有一个月的时间，从此对狮子很在意。<br>一般认为头上的呆毛（日本动漫觉得绘制的一种角色属性特点）是称王之时由リエンス王剃落的，貌似以后守护国家的荣耀=保护头上的呆毛，就算是王妃也不允许触摸。被碰到的话会条件反射性地进入防御状态。<br>被抓住酷毛的话会立即黑化(并非被黑影污染而是转变为黑暗的一面)，喜欢吃的食物也变为junk food。<br>有时在做梦的时候会无意识的武装。受到湖之精灵的守护可以在水上行走，但却不会游泳。<br>最近的爱好是收集菜单，对金钱的观念感稀薄。擅长器械运动跟赌博，喜欢精细的食物跟狮子，讨厌粗略的食物跟过多的装饰。<br>她的便服为凛所赠，原本是绮礼作为生日礼物送给凛的。<br>她的便服是言峰绮礼赠送给远坂凛的东西。睡衣为白底蓝花的和服。</p><h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>亚瑟王<br>P1:<br>被歌颂为“存在于过去，复活于未来之王”，英格兰传说中的英雄——亚瑟王。<br>其人是被作为骑士的代名词广为传颂的英雄。并非仅存于传说，而是实际存在的人物。<br>实际上亚瑟王是一个在英格兰北部（高德丁 Gododdin，不列颠古王国之一）率领着十二王抵御皮克特人与苏格兰人等外族入侵的名将，被称为“Dux Bellorum”（战争之王）。<br>P2:<br>现实中的名将亚瑟王，其出身众说纷纭，也有说法认为符合这个王的形象的人有两位。<br>一个是身为纯粹的英格兰人的亚瑟王，另一个是罗马人亚尔托利乌斯。<br>这两个人的传说混合起来变成了一个人的故事，这就是现代流传的亚瑟王传说的原型。<br>P3:<br>亚瑟王的传说实在是非常地出名。<br>亚瑟王将绝世的大魔术师梅林准备的刻有“拔出此剑者即英格兰之王”的铭文的剑(石中剑Caliburn)拔出，从此被承认为英格兰的王者。<br>与其麾下的圆桌骑士们一起共同演绎出了许许多多的故事并广为人们所相传。<br>P4:<br>亚瑟是不列颠王优瑟·蟠龙，与家臣康沃尔公爵其妻、碧眼之依格琳所生之子。<br>优瑟恋上依格琳，借魔术士梅林的帮助与其结为连理的代价，便是将他和依格琳所生的孩子交给梅林。<br>“我要帮助这个孩子逃离王室的危机，引导其作为一个背负伟大命运的孩子而长大，让其免于误入歧途。”<br>P5:<br>亚瑟被梅林交给了优瑟的忠实骑士埃克托爵士，直至其拔出选定王的圣剑之前，都是作为他的养子而被抚养长大。<br>亚瑟王将剑拔起，成王之后那精彩曲折的战斗故事，如同一部绘满了中世纪骑士精神的画卷。<br>亚瑟王成为伟大的骑士王进驻卡米洛特城堡，多名骑士遵从于他，拯救英格兰于水火之中，作为一个英雄来说他几乎可以说没有什么缺点。<br>P6:<br>亚瑟王所持有的那把有名的圣剑Excalibur也称“王者之剑”，Fate中称之为“誓约胜利之剑，并非是选定王的剑，而是失去那把剑之后，经由梅林的引导，从湖中妖精那里得到的妖精乡的宝剑。<br>湖中妖精的公主薇薇安在授予亚瑟王Excalibur之后就成为了他的守护者。<br>虽然亚瑟王终生的敌人——妖后摩尔甘与身为亚瑟王之守护者的薇薇安是互相对立的存在，但摩尔甘本身却也是守护王的湖中妖精的一员。<br>P7:<br>亚瑟王命令圆桌骑士们去寻找“圣杯”。<br>虽然寻找圣杯是亚瑟王传说里，圆桌骑士的故事中一个最核心的章节，但受命的骑士却只有三名，亚瑟王自身也未曾踏上寻找圣杯的旅程。<br>三名骑士之中，要数兰斯洛特最为完美，但是由于不贞的污秽导致他永远不能取得圣杯，而他的儿子加拉哈德虽然得到了圣杯，但是由于其精神上的无欲，最后又将圣杯放弃。<br>P8:<br>传说的最后，是以亚瑟王之死闭幕。<br>亚瑟王的异父姐姐——妖后摩尔甘多次欲置其于死地。而最后，因她的策略而出生的骑士莫德雷德达成了这个目标，为传说划上了休止符。<br>亚瑟王开始走下坡路，是从其最信赖的骑士兰斯洛特因为与亚瑟王之妻桂妮薇的不贞之事而失踪开始。<br>失去了可以信赖的骑士，失去了圣剑的鞘，在远征途中国家被攻陷的亚瑟王在一处名唤剑栏之地迎来了最后的战斗。<br>P9:<br>亚瑟王在临死之前，将圣剑Excalibur交给了贝狄威尔骑士，归还给了湖中妖精。<br>而亚瑟王的遗体则被湖中妖精们带到了英雄们的长眠之地——阿瓦隆（Avalon），传说亚瑟王在英格兰陷于存亡危机、水深火热之时，便会于阿瓦隆的长眠中觉醒过来，去拯救其祖国。<br>亚瑟背负着不列颠人民的象征——赤龙，而其自身也有着龙的属性。因为有着身为神秘与超越之具现的龙的因子，其特性是拥有着强大的魔力。但相对地，在面对有着除龙的传说背景的英雄之时会比较不利。</p><h2 id="宝具"><a href="#宝具" class="headerlink" title="宝具"></a>宝具</h2><p>Invisible·Air<br>风王结界<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/bkju1.webp"><br>Excalibur<br>誓约胜利之剑<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/bkju2.webp"><br>Avalon<br>远离尘世的理想乡<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/bkju3.webp"><br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/bkju4.webp"><br>Excalibur之鞘的能力。<br>失落的第三件宝具。<br>圣剑之鞘是爱因兹贝伦家在康沃尔发掘出来的，跨越了几千年的时光回到其主之手。<br>在亚瑟王的传说中，圣剑真正的能力是这个鞘的“不死能力”。<br>它有着治愈其所有者的伤和停止其老化的能力，实际上它可以被称为单兵用的“移动要塞”。<br>展开剑鞘，将自身置于妖精乡之中，就可以屏蔽所有的物理影响。<br>甚至可以防御“平行世界干涉”这个魔法。</p><h1 id="黑暗Saber—堕落阿尔托莉雅"><a href="#黑暗Saber—堕落阿尔托莉雅" class="headerlink" title="黑暗Saber—堕落阿尔托莉雅"></a>黑暗Saber—堕落阿尔托莉雅</h1><p><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/black-saber.webp"></p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>阿尔托莉雅<br>Saber被谜之影污染后的产物。<br>她之所以会是最强，并不是因其作为剑士的能力，而是那因拥有龙之因子而得到的庞大魔力量。<br>Servant会因为得不到足够的魔力而不能发挥出生前的战斗力，而这个状态的她却拥有着比生前更强的破坏力。<br>若单纯就攻击力而言，她无疑是最强的存在。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑之骑士—Saber&quot;&gt;&lt;a href=&quot;#剑之骑士—Saber&quot; class=&quot;headerlink&quot; title=&quot;剑之骑士—Saber&quot;&gt;&lt;/a&gt;剑之骑士—Saber&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="人物简介" scheme="https://matthew84.cf/categories/article/%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="Fate/stay night" scheme="https://matthew84.cf/tags/Fate-stay-night/"/>
    
    <category term="命运之夜" scheme="https://matthew84.cf/tags/%E5%91%BD%E8%BF%90%E4%B9%8B%E5%A4%9C/"/>
    
    <category term="英灵" scheme="https://matthew84.cf/tags/%E8%8B%B1%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>2020年10月--Hacktoberfest活动</title>
    <link href="https://matthew84.cf/archives/93ef14f7.html"/>
    <id>https://matthew84.cf/archives/93ef14f7.html</id>
    <published>2020-10-23T12:29:05.000Z</published>
    <updated>2020-11-03T08:46:51.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hacktoberfest"><a href="#Hacktoberfest" class="headerlink" title="Hacktoberfest"></a>Hacktoberfest</h1><p>Hacktoberfest 是由知名云服务商 DigitalOcean 发起的一个推广、支持开源的年度在线活动，任何一个开源爱好者都可以参与。只要在10月份内向 GitHub 上的任意开源项目提交若干 Pull Request，就算完成活动任务，并将得到由 DigitalOcean、GitHub 等活动赞助商提供的纪念品。通常是限量版T恤、贴纸若干。</p><p>那么，Hacktoberfest 这个奇怪的名字是什么意思呢？这不是一个原生的英文单词，是由几个代表着这个活动的核心精神的单词缩写组合而成。其中的 Hacktober 是由 Hackathon（黑客马拉松） 和 October（十月） fest 则是 Festival（节日）的前几个字幕。看到这里，大家应该就明白了吧， Hacktoberfest 就是开源爱好者在每年的十月份通过做开源贡献的方式来传播、庆祝开源。</p><p>不懂代码？完全没关系，有很多项目或者社区需要您其他方面的技能，包括当不仅限于：文档编写、文档翻译、图片设计、字幕等等。</p><p>好了，心动不如行动，赶快点击下面的链接注册报名吧：<br><a href="https://hacktoberfest.digitalocean.com/">https://hacktoberfest.digitalocean.com</a></p><p>注册过程中，你大致需要做下面的三件事：</p><ul><li>通过 GitHub 登录</li><li>选择邮箱、角色（活动组织者、贡献者、项目维护者）</li><li>是否接收相关资讯邮件</li></ul><p>如果你看到了类似下面的画面，那么，恭喜你，已经完成活动注册。<br><img src= "/img/loading.gif" data-lazy-src="//cdn.jsdelivr.net/gh/long-zhi/static@latest/img/hacktoberfest02.webp"><br>开源的方舟你已经登上，接下来再看看到底有哪些项目可以参与，以及了解下今年的活动情况。</p><ul><li>2020年，Hacktoberfest 是由三家公司联合组织，包括：DigitalOcean、intel、DEV。其中，intel 是今年新加入的</li><li>从需要完成的 PR 数量来看，相比去年少了一个，只需要完成4个即可</li><li>从活动奖励上来看，多了一个选项，可以在限量版T恤或者种树之间选择一个）</li><li>今年T恤的颜色可以是白色或者蓝色</li><li>如何种树？请看这里 <a href="https://tree-nation.com/profile/digitalocean">https://tree-nation.com/profile/digitalocean</a></li></ul><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ul><li>我提交的 PR 必须要合并后才算吗？答：只要提交 PR 即可，除非被标记为无效的。</li><li>issues 算数吗？答：不算！</li><li>我可以向 GitHub 以外的平台提交 PR 吗？答：不可以！</li></ul><p>即使我已经努力向各位介绍活动细节了，但如果还有不清楚的地方的话，可以访问下面的官方 FAQ 链接。<br><a href="https://hacktoberfest.digitalocean.com/faq">https://hacktoberfest.digitalocean.com/faq</a></p><p>据说YouTube上有一位外国小哥介绍了如何白嫖这个活动的T恤，所以官方规则有所更改，详见<br><a href="https://hacktoberfest.digitalocean.com/hacktoberfest-update">https://hacktoberfest.digitalocean.com/hacktoberfest-update</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hacktoberfest&quot;&gt;&lt;a href=&quot;#Hacktoberfest&quot; class=&quot;headerlink&quot; title=&quot;Hacktoberfest&quot;&gt;&lt;/a&gt;Hacktoberfest&lt;/h1&gt;&lt;p&gt;Hacktoberfest 是由知名云服务商 Dig</summary>
      
    
    
    
    <category term="文章" scheme="https://matthew84.cf/categories/article/"/>
    
    <category term="T恤活动" scheme="https://matthew84.cf/categories/article/T%E6%81%A4%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="实物奖品" scheme="https://matthew84.cf/tags/%E5%AE%9E%E7%89%A9%E5%A5%96%E5%93%81/"/>
    
    <category term="Hacktoberfest" scheme="https://matthew84.cf/tags/Hacktoberfest/"/>
    
    <category term="T恤" scheme="https://matthew84.cf/tags/T%E6%81%A4/"/>
    
  </entry>
  
</feed>
